
diff -puN Kconfig~parser Kconfig
--- reiser4/Kconfig~parser	2005-06-28 22:55:48.767849360 +0400
+++ reiser4-demidov/Kconfig	2005-06-28 23:12:54.000000000 +0400
@@ -100,3 +100,5 @@ config REISER4_ZLIB
           here. But if you need best compression ratio, say Y.
         select ZLIB_INFLATE
         select ZLIB_DEFLATE
+
+source "fs/reiser4/parser/Kconfig"
diff -puN Makefile~parser Makefile
--- reiser4/Makefile~parser	2005-06-28 22:55:53.658105928 +0400
+++ reiser4-demidov/Makefile	2005-06-28 23:15:04.000000000 +0400
@@ -97,3 +97,5 @@ reiser4-y := \
 		   plugin/file/file.o \
 		   plugin/file/regular.o \
 		   plugin/file/tail_conversion.o
+
+obj-$(CONFIG_REISER4_FS_SYSCALL) += parser/
diff -puN /dev/null lnode.c
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/lnode.c	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,431 @@
+/* Copyright 2001, 2002, 2003 by Hans Reiser, licensing governed by reiser4/README */
+
+/* Lnode manipulation functions. */
+/* Lnode is light-weight node used as common data-structure by both VFS access
+   paths and reiser4() system call processing.
+
+   One of the main targets of reiser4() system call is to allow manipulation
+   on potentially huge number of objects. This makes use of inode in reiser4()
+   impossible. On the other hand there is a need to synchronize reiser4() and
+   VFS access.
+
+   To do this small object (lnode) is allocated (on the stack if possible) for
+   each object involved into reiser4() system call. Such lnode only contains
+   lock, information necessary to link it into global hash table, and
+   condition variable to wake up waiters (see below).
+
+   In other words, lnode is handle that reiser4 keeps for a file system object
+   while object is being actively used. For example, when read is performed by
+   reiser4_read(), lnode exists for inode being read. When reiser4_read()
+   exits lnode is deleted, but inode is still there in the inode cache.
+
+   As lnode only exists while object is being actively manipulated by some
+   threads, it follows that lnodes can always live on the stack of such
+   threads.
+
+   Case-by-case:
+
+     A. access through VFS (reiser4_{read|write|truncate|*}()):
+
+       1. operation starts with inode supplied by VFS.
+
+       2. lget( &local_lnode, LNODE_INODE, inode -> i_ino ) is called. This,
+       if necessary, will wait until sys_reiser4() access to this file is
+       finished, and
+
+       3. add lnode to the per super block hash table.
+
+     B. creation of new inode in reiser4_iget():
+
+       1. create new empty inode (iget(), or icreate())
+
+       2. step A.3. A.2 is not necessary, because we are creating new object
+       and parent is in VFS access (hence sys_reiser4() cannot add/delete
+       objects in parent).
+
+       3. read stat data from disk and initialise inode
+
+     C. sys_reiser4() access:
+
+       1. check for existing inode in a hash-table.
+
+          Rationale: if inode is already here it is advantageous to use it,
+          because it already has information from stat data.
+
+          If inode is found proceed as in case A.
+
+       2. otherwise, lget( &local_lnode, LNODE_LW, oid ) is called.
+
+
+   NOT FINISHED.
+
+
+
+
+
+
+
+   INTERNAL NOTES:
+
+   1. fs/inode.c:inode_lock is not static: we can use it. Good.
+
+   2. but fs/inode.c:find_inode() is. Either write own version, or remove
+   static and EXPORT_SYMBOL-ize it.
+
+
+
+*/
+
+#include "debug.h"
+#include "kcond.h"
+#include "key.h"
+#include "kassign.h"
+#include "plugin/plugin_header.h"
+#include "plugin/plugin_set.h"
+#include "lnode.h"
+#include "super.h"
+#include "reiser4.h"
+
+#include <linux/fs.h>		/* for struct super_block  */
+#include <linux/spinlock.h>
+
+static reiser4_key *lnode_dentry_key(const lnode * node, reiser4_key * result);
+static reiser4_key *lnode_inode_key(const lnode * node, reiser4_key * result);
+static reiser4_key *lnode_lw_key(const lnode * node, reiser4_key * result);
+static int lnode_inode_eq(const lnode * node1, const lnode * node2);
+static int lnode_lw_eq(const lnode * node1, const lnode * node2);
+
+#if REISER4_DEBUG
+static int lnode_valid_type(lnode_type type);
+#endif
+
+/* Common operations for various types of lnodes.
+
+   NOTE-NIKITA consider making this plugin. */
+static struct {
+	/* get a key of the corresponding file system object */
+	reiser4_key *(*key) (const lnode * node, reiser4_key * result);
+	/* get a plugin suitable for the corresponding file system object */
+	int (*get_plugins) (const lnode * node, plugin_set * area);
+	/* set a plugin suitable for the corresponding file system object */
+	int (*set_plugins) (lnode * node, const plugin_set * area);
+	/* true if @node1 and @node2 refer to the same object */
+	int (*eq) (const lnode * node1, const lnode * node2);
+} lnode_ops[LNODE_NR_TYPES] = {
+	[LNODE_DENTRY] = {
+		.key = lnode_dentry_key,
+		.get_plugins = NULL,
+		.set_plugins = NULL,
+		.eq = NULL
+	},
+	[LNODE_INODE] = {
+		.key = lnode_inode_key,
+		.get_plugins = NULL,
+		.set_plugins = NULL,
+		.eq = lnode_inode_eq
+	},
+	/*
+	[LNODE_PSEUDO] = {
+		.key = NULL,
+		.get_plugins = NULL,
+		.set_plugins = NULL,
+		.eq = NULL
+	},
+	*/
+	[LNODE_LW] = {
+		.key = lnode_lw_key,
+		.get_plugins = NULL,
+		.set_plugins = NULL,
+		.eq = lnode_lw_eq
+	}
+};
+
+/* hash table support */
+
+/* compare two block numbers for equality. Used by hash-table macros */
+/* Audited by: green(2002.06.15) */
+static inline int
+oid_eq(const oid_t * o1 /* first oid to compare */ ,
+       const oid_t * o2 /* second oid to compare */ )
+{
+	return *o1 == *o2;
+}
+
+/* Hash znode by block number. Used by hash-table macros */
+/* Audited by: green(2002.06.15) */
+static inline __u32
+oid_hash(ln_hash_table *table, const oid_t * o /* oid to hash */ )
+{
+	return *o & (LNODE_HTABLE_BUCKETS - 1);
+}
+
+/* The hash table definition */
+#define KMALLOC(size) kmalloc((size), GFP_KERNEL)
+#define KFREE(ptr, size) kfree(ptr)
+TYPE_SAFE_HASH_DEFINE(ln, lnode, oid_t, h.oid, h.link, oid_hash, oid_eq);
+#undef KFREE
+#undef KMALLOC
+
+ln_hash_table lnode_htable;
+spinlock_t    lnode_guard = SPIN_LOCK_UNLOCKED;
+
+
+/* true if @required lnode type is @compatible with @set lnode type. If lnode
+   types are incompatible, then thread trying to obtain @required type of
+   access will wait until all references (lnodes) of the @set type to the file
+   system object are released.
+
+   For example, thread trying to manipulate object through VFS (@required type
+   is LNODE_INODE) will wait if object is currently manipulated through
+   reiser4() call (that is, there are lnodes with type LNODE_LW).
+
+*/
+/* Audited by: green(2002.06.15) */
+reiser4_internal int
+lnode_compatible_type(lnode_type required /* required lnode type */ ,
+		      lnode_type set /* lnode type already set */ )
+{
+	return !((set == LNODE_LW) && (required != LNODE_INODE));
+}
+
+/* initialise lnode module for @super. */
+/* Audited by: green(2002.06.15) */
+reiser4_internal int
+lnodes_init(void)
+{
+	ln_hash_init(&lnode_htable, LNODE_HTABLE_BUCKETS, NULL);
+	return 0;
+}
+
+/* free lnode resources associated with @super. */
+/* Audited by: green(2002.06.15) */
+reiser4_internal int
+lnodes_done(void)
+{
+	ln_hash_done(&lnode_htable);
+	return 0;
+}
+
+/* Acquire handle to file system object.
+
+   First check whether there is already lnode for this oid in a hash table.
+   If no---initialise @node and add it into the hash table. If hash table
+   already contains lnode with such oid, and incompatible type, wait until
+   said lnode is deleted. If compatible lnode is found in the hash table,
+   increase its reference counter and return.
+
+
+
+
+*/
+/* Audited by: green(2002.06.15) */
+reiser4_internal lnode *
+lget(                 /*lnode * node ,  lnode to add to the hash table */
+     lnode_type type /* lnode type */ , oid_t oid /* objectid */ )
+{
+	lnode *result;
+
+	//	assert("nikita-1862", node != NULL);
+	assert("nikita-1866", lnode_valid_type(type));
+
+	spin_lock(&lnode_guard);
+	/* check hash table */
+	while ((result = ln_hash_find(&lnode_htable, &oid)) != 0) {
+		if (!lnode_compatible_type(type, result->h.type)) {
+			int ret;
+
+			/* if lnode is of incompatible type, wait until all
+			   incompatible users go away. For example, if we are
+			   requesting lnode for VFS access (and our @type is
+			   LNODE_INODE), wait until all reiser4() system call
+			   manipulations with this object finish.
+			*/
+			ret = kcond_wait(&result->h.cvar, &lnode_guard, 1);
+			if (ret != 0) {
+				result = ERR_PTR(ret);
+				break;
+			}
+		} else {
+			/* compatible lnode found in the hash table. Just
+			   return it. */
+			++result->h.ref;
+			break;
+		}
+	}
+	if (result == NULL) {
+		/* lnode wasn't found in the hash table, initialise @node and
+		   add it into hash table. */
+		result = ( lnode * ) kmalloc( sizeof( lnode ), GFP_KERNEL);
+		xmemset(result, 0, sizeof( lnode ));
+		result->h.type = type;
+		result->h.oid = oid;
+		kcond_init(&result->h.cvar);
+		result->h.ref = 1;
+		ln_hash_insert(&lnode_htable, result);
+	}
+	spin_unlock(&lnode_guard);
+	return result;
+}
+
+/* release reference to file system object */
+/* Audited by: green(2002.06.15) */
+reiser4_internal void
+lput(lnode * node /* lnode to release */ )
+{
+	assert("nikita-1864", node != NULL);
+	assert("nikita-1961", lnode_valid_type(node->h.type));	/* man in
+								 * a
+								 * space */
+	spin_lock(&lnode_guard);
+	assert("nikita-1878", ln_hash_find(&lnode_htable, &node->h.oid) == node);
+	if (--node->h.ref == 0) {
+		ln_hash_remove(&lnode_htable, node);
+		kcond_broadcast(&node->h.cvar);
+		kfree(node);
+	}
+	spin_unlock(&lnode_guard);
+}
+
+reiser4_internal lnode *
+lref(lnode * node)
+{
+	assert("nikita-3241", node != NULL);
+	assert("nikita-3242", lnode_valid_type(node->h.type));
+
+	spin_lock(&lnode_guard);
+	++ node->h.ref;
+	spin_unlock(&lnode_guard);
+	return node;
+}
+
+/* true if @node1 and @node2 refer to the same object */
+/* Audited by: green(2002.06.15) */
+reiser4_internal int
+lnode_eq(const lnode * node1 /* first node to compare */ ,
+	 const lnode * node2 /* second node to compare */ )
+{
+	assert("nikita-1921", node1 != NULL);
+	assert("nikita-1922", node2 != NULL);	/* Finnegans Wake started */
+
+	if (node1->h.oid != node2->h.oid)
+		return 0;
+	else if (node1->h.type != node2->h.type)
+		return 0;
+	else
+		return lnode_ops[node1->h.type].eq(node1, node2);
+}
+
+/* return key of object behind @node */
+/* Audited by: green(2002.06.15) */
+reiser4_internal reiser4_key *
+lnode_key(const lnode * node /* lnode to query */ ,
+	  reiser4_key * result /* result */ )
+{
+	assert("nikita-1849", node != NULL);
+	assert("nikita-1855", lnode_valid_type(node->h.type));
+	return lnode_ops[node->h.type].key(node, result);
+}
+
+/* return plugins of object behind @node */
+/* Audited by: green(2002.06.15) */
+reiser4_internal int
+get_lnode_plugins(const lnode * node /* lnode to query */ ,
+		  plugin_set * area /* result */ )
+{
+	assert("nikita-1853", node != NULL);
+	assert("nikita-1858", lnode_valid_type(node->h.type));
+	return lnode_ops[node->h.type].get_plugins(node, area);
+}
+
+/* set plugins of object behind @node */
+/* Audited by: green(2002.06.15) */
+reiser4_internal int
+set_lnode_plugins(lnode * node /* lnode to modify */ ,
+		  const plugin_set * area /* plugins to install */ )
+{
+	assert("nikita-1859", node != NULL);
+	assert("nikita-1860", lnode_valid_type(node->h.type));
+	return lnode_ops[node->h.type].set_plugins(node, area);
+}
+
+#if REISER4_DEBUG
+/* true if @type is valid lnode type */
+/* Audited by: green(2002.06.15) */
+static int
+lnode_valid_type(lnode_type type /* would-be lnode type */ )
+{
+	return type < LNODE_NR_TYPES;
+}
+#endif
+
+/* return key of object behind dentry-based @node */
+reiser4_internal reiser4_key *
+lnode_dentry_key(const lnode * node /* lnode to query */ ,
+		reiser4_key * result /* result */ )
+{
+	return build_sd_key(node->l_dentry.dentry->d_inode, result);
+}
+
+
+
+/* return key of object behind inode-based @node */
+/* Audited by: green(2002.06.15) */
+static reiser4_key *
+lnode_inode_key(const lnode * node /* lnode to query */ ,
+		reiser4_key * result /* result */ )
+{
+	return build_sd_key(node->l_inode.inode, result);
+}
+
+/* return key of object behind lighweight @node */
+/* Audited by: green(2002.06.15) */
+static reiser4_key *
+lnode_lw_key(const lnode * node /* lnode to query */ ,
+	     reiser4_key * result /* result */ )
+{
+	*result = *node->l_lw.key;
+	return result;
+}
+
+/* compare two inodes */
+/* Audited by: green(2002.06.15) */
+static int
+lnode_inode_eq(const lnode * node1 /* first node to compare */ ,
+	       const lnode * node2 /* second node to compare */ )
+{
+	assert("nikita-1923", node1 != NULL);
+	assert("nikita-1924", node2 != NULL);
+
+	assert("nikita-1927", node1->l_inode.inode != NULL);
+	assert("nikita-1928", node2->l_inode.inode != NULL);
+
+	return (node1->l_inode.inode == node2->l_inode.inode);
+
+}
+
+/* compare two lw objects */
+/* Audited by: green(2002.06.15) */
+static int
+lnode_lw_eq(const lnode * node1 UNUSED_ARG	/* first node to
+						 * compare */ ,
+	    const lnode * node2 UNUSED_ARG	/* second node to
+						 * compare */ )
+{
+	assert("nikita-1925", node1 != NULL);
+	assert("nikita-1926", node2 != NULL);
+
+	/* we only get there if oids are equal */
+	assert("nikita-1929", node1->h.oid == node2->h.oid);
+	assert("nikita-1930", keyeq(node1->l_lw.key, node2->l_lw.key));
+	return 1;
+}
+
+/* Make Linus happy.
+   Local variables:
+   c-indentation-style: "K&R"
+   mode-name: "LC"
+   c-basic-offset: 8
+   tab-width: 8
+   fill-column: 120
+   End:
+*/
diff -puN /dev/null lnode.h
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/lnode.h	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,179 @@
+/* Copyright 2002, 2003 by Hans Reiser, licensing governed by reiser4/README */
+
+/* Declaration of lnode (light-weight node). */
+
+#ifndef __LNODE_H__
+#define __LNODE_H__
+
+#include "forward.h"
+#include "dformat.h"
+#include "kcond.h"
+#include "type_safe_hash.h"
+#include "plugin/plugin_header.h"
+#include "plugin/plugin_set.h"
+#include "key.h"
+
+#include <linux/types.h>	/* for __u??  */
+#include <linux/fs.h>		/* for struct super_block, etc.  */
+#include <linux/dcache.h>	/* for struct super_block, etc.  */
+
+typedef enum {
+	LNODE_DENTRY,
+	LNODE_INODE,
+	LNODE_REISER4_INODE,
+	LNODE_LW,
+	LNODE_COORD,
+//	LNODE_RANGE,
+	LNODE_PSEUDO,
+	LNODE_NR_TYPES
+} lnode_type;
+
+typedef union lnode lnode;
+
+/* declare hash table of lnode_lw's */
+TYPE_SAFE_HASH_DECLARE(ln, lnode);
+
+/* common part of various lnode types */
+typedef struct lnode_header {
+	/* lnode type. Taken from lnode_type enum. Never changed after
+	   initialisation, so needs no locking.  */
+	__u8 type;
+	/* unused. Alignment requires this anyway. */
+	__u8 flags;
+	/* condition variable to wake up waiters */
+	kcond_t cvar;
+	/* hash table linkage. Updated under hash-table spinlock. */
+	ln_hash_link link;
+	/* objectid of underlying file system object. Never changed after
+	   initialisation, so needs no locking.  */
+	oid_t oid;
+	/* reference counter. Updated under hash-table spinlock. */
+	int ref;
+} lnode_header;
+
+typedef struct lnode_dentry {
+	lnode_header h;
+	atomic_t * lock;
+	struct dentry *dentry;
+	struct vfsmount *mnt;
+} lnode_dentry;
+
+typedef struct lnode_inode {
+	lnode_header h;
+	struct inode *inode;
+} lnode_inode;
+
+typedef struct lnode_reiser4_inode {
+	lnode_header h;
+	struct reiser4_inode *inode;
+} lnode_reiser4_inode;
+
+typedef struct lnode_lw {
+	lnode_header h;
+	struct super_block * lw_sb;
+	reiser4_key *key;
+} lnode_lw;
+
+typedef struct lnode_coord {
+	lnode_header h;
+	struct super_block * lw_sb;
+	coord_t *coord;
+} lnode_coord;
+
+
+struct assign_result {
+	loff_t len ;
+	int return_code ;
+};
+
+#if 0
+typedef enum {
+	RANGE_CUT,
+	RANGE_ZERRO,
+	RANGE_TRANSPARENT,
+	RANGE_NR 
+}  range_type;
+
+typedef enum {
+	UNITS_BYTE,
+	UNITS_LINE,
+	UNITS_ITEM,
+	UNITS_DELIMITER,
+	UNITS_NR
+} units_type;
+
+typedef enum {
+	COMMAND_UNITS,
+	COMMAND_TYPE,
+	COMMAND_OFFSET,
+	COMMAND_LAST,
+	COMMAND_FIRST,
+	COMMAND_LEN,
+	COMMAND_NR
+} rng_command;
+
+typedef struct {
+	int comm;
+	ssize_t value;
+} rng_command_t;
+
+typedef struct rng {
+	loff_t offset; /* begin of window */
+	ssize_t size; /* end of window */
+	int units_type;
+	int type;
+} rng_t;
+
+typedef struct lnode_range {
+	lnode_header h;
+	lnode *host; /* host to be range*/
+	rng_t * rng;
+} lnode_range;
+
+#endif
+
+typedef struct lnode_pseudo {
+	lnode_header h;
+	struct assign_result rez;
+
+	//	lnode *host;
+	/* something to identify pseudo file type, like name or plugin */
+} lnode_pseudo;
+
+union lnode {
+	lnode_header h;
+	lnode_dentry        l_dentry;
+	lnode_inode         l_inode;
+	lnode_reiser4_inode l_reiser4_inode;
+	lnode_lw            l_lw;
+	lnode_coord         l_coord;
+//	lnode_range         l_range;
+	lnode_pseudo        l_pseudo;
+};
+
+extern int lnodes_init(void);
+extern int lnodes_done(void);
+
+extern lnode *lget( lnode_type type, oid_t oid);
+extern void lput(lnode * node);
+extern int lnode_eq(const lnode * node1, const lnode * node2);
+extern lnode *lref(lnode * node);
+
+extern struct inode *inode_by_lnode(const lnode * node);
+extern reiser4_key *lnode_key(const lnode * node, reiser4_key * result);
+
+extern int get_lnode_plugins(const lnode * node, plugin_set * area);
+extern int set_lnode_plugins(lnode * node, const plugin_set * area);
+
+/* __LNODE_H__ */
+#endif
+
+/* Make Linus happy.
+   Local variables:
+   c-indentation-style: "K&R"
+   mode-name: "LC"
+   c-basic-offset: 8
+   tab-width: 8
+   fill-column: 120
+   End:
+*/
diff -puN /dev/null parser/current.txt
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/current.txt	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,144 @@
+the current condition of sys_reiser4
+
+
+
+The last changes:
+
+1.  bison(1) is to used to build parser.tab.c
+
+    directory fs/reiser4/parser/bison-1.875 contains bison's 5 skeleton
+    files slightly modified for ours needs. 
+    Later, we can instead keep there only mentioned changes.
+
+2. fs/reiser4/parser/parser_syntax.doc contains sys_reiser4 syntax description.
+
+sys_reiser4 can do now:
+
+1.      sys_reiser4("NAME <= A <- B");
+
+	NAME<=A<-B;
+
+	A and B are names of existing files.
+	As result of this file A gets content of file B.
+	NAME is temporary thing which stores result of operation (<- is an 
+	assign operaion). NAME/assign_result and NAME/assign_length could be
+	used further in command. 
+
+2.      sys_reiser4("A <- B");
+
+	The same as the above, but result can be obtains from A/assign_result
+	and A/assign_length.
+
+
+If NAME matches a name of existing file, that existing file is not
+touched. This works as it is supposed to.
+
+lets consider the following
+sys_reiser4("/A/B/c <= a <- b");
+
+/A/B/c is not  a full file name.
+It is internal name where result of operation is stored temporary:
+until either sys_reiser4 completes or closeing brace is encountered.
+
+
+NAME lives inside surrounding brackets enclosing it or up to the end of
+command if it is not inside of brackets.
+
+Results of tested operations (assign operator) get stored
+NAME/assign_result and NAME/assign_length.
+
+If operation failed  NAME/assign_result contains error code.
+NAME/assign_length contains number of bytes written before error
+happened.
+
+It is checked that the following
+reiser4("(A <= B <- C); C <- A");
+works correctly: that is A as result of B <- C does not get to C <-A.
+
+The above is also checked when A does not exist. A from braces is not
+used in C <- A even if file with name A does not exist.
+
+This says that commands like:
+reiser4("a <= b < c; (a <= d <- e; (a <= f <- g)); h <- a");
+were tested and proper value of a were used in each cases. Nested
+operators are implemeneted using stack data structure.
+
+
+NAMES (thing which is created when  it appears to the left of "<=") can
+be used further in a command everywhere where file name can be used.
+The only difference is that accessing its metadata (file size, for
+instance) will cause error.
+
+NAME is not necessarily end name. It can contain a path section just
+like any file. So far such NAMES were not tested yet completely.
+
+sys_reiser4 has only assign operator so far.
+
+
+
+
+So we need to implement the /process/range stuff (what did I call it,
+not stuff, but flow?  pseudofile? tube?  sigh, it has been too long,
+please remind me.....)  fairly urgently, yes?
+
+
+sys_reiser4("foo <- \"Hello, world\n\"");
+
+As a result of this operation file foo will get new content :"Hello, world\n".
+If file foo does not exist - error -ENOENT will be returned.
+
+
+>
+What do we need this for?
+When we discussed this last with you and Nikita we did not come to agreement how that can be implemented:
+
+If we use strings like /process/range/* in sys_reiser4 command to refer to process address space we restrict namespace.
+That is if strings like /process/range/* are handled  specially - there will be a problem to have regulal file /process/range.
+
+Maybe, we can modify procfs to have /proc/PID/mem/range/ and use it to access address space of processes?
+
+
+Mr. Saveliev has an ignorant  proposal:
+Do we really need to deal with something looking like a path trying to specify memory range in process address space?
+To access process address space from sys_reiser4 command can we just create a special operand?
+Something like: MEMRANGE(100,200) where 100 is address of beginning of range, 200 is size of range? 
+
+
+/memrange/100-200 is ok with me.
+
+
+
+
+      The "NAME"  is not a object of file system. ok tested
+      Rule for it name is common rule for object of FS, exept one rule: names in path no need corresponded object in FS. tested
+      Time of a life of it limited to surrounding brackets or the end of the command string. (tested.)
+      After this operator this name will have subnames "assign_result" and "assign_length", (ok tested)
+      which will contain error code of assign and number of bytes written to file A. (ok tested)
+
+      After name is dead the previously value of name is restored. (ok tested)
+      This rule not depended of exist or not file in FS with same name. (ok tested)
+
+      if file "name" exist in current directory, then it's value(lnode) pushed to stack. New value is created. (ok tested)
+
+      This names is avalable in any expression as a file. (Only body of file. no any meta data) ?? (ok tested)
+      parent of it is a current directory, or defined path. (tested current directory, need test for full pathname)
+      It means we can use full pathname for access to it. ( tested, need more test)
+
+
+
+
+   not yet ready create, remove and ets...
+
+3. Realized in sys_reiser4 the method of analysis in the form of a tree.
+   This means accommodation in memory of all tree of analysis with all elements of the file system, found during analysis.
+   It will not allow to create, copy, etc. in one expression a plenty of files - the order of one million. (Hans's requirement)
+
+     there are begun works on change for optimization of a method of analysis,
+     partial replacement of a subtree with a stack of expressions,
+     reduction of area of construction of a tree.
+
+
+
+
+
+iso-8859-1
\ No newline at end of file
diff -puN /dev/null parser/Kconfig
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/Kconfig	2005-06-29 18:07:19.000000000 +0400
@@ -0,0 +1,49 @@
+config REISER4_FS_SYSCALL
+	tristate "Enable reiser4 system call"
+	default y
+	depends on REISER4_FS
+	---help---
+      Adds sys_reiser4() syscall.
+      This code is not in good shape yet.  If unsure say no.
+
+config REISER4_FS_SYSCALL_DEBUG
+	bool "Enable reiser4 system call debug"
+	depends on REISER4_DEBUG && REISER4_FS_SYSCALL
+	help
+	  Turns on debug reiser4_system_call.
+	  Don't use this unless you are debugging reiser4 syscall.
+
+
+
+config REISER4_FS_SYSCALL_GENERATE
+        bool "Recompile the sys_reiser4() grammar. (if unsure say no)."
+        default n
+	depends on REISER4_FS_SYSCALL
+	---help---
+     Use the bison/yacc code generator for recompile the sys_reiser4()
+     grammar if you have changed it.
+
+choice
+        prompt "Type of code generator"
+	depends on REISER4_FS_SYSCALL_GENERATE
+        default REISER4_FS_SYSCALL_BISON
+
+config REISER4_FS_SYSCALL_BISON
+	bool "bison"
+	depends on REISER4_FS_SYSCALL
+	---help---
+      Invoke bison to compile fs/reiser4/parser/parser.y.  Only needed if you
+      have changed the sys_reiser4() grammar.
+
+config REISER4_FS_SYSCALL_YACC
+	bool "yacc"
+	depends on REISER4_FS_SYSCALL
+	---help---
+      Invoke yacc to compile fs/reiser4/parser/parser.y.
+      Only needed if you have changed the sys_reiser4() grammar.
+      If you don't know if you have changed it, then you haven't.
+      Before using this you need to use a patch for yacc from
+      ftp://ftp.namesys.com/pub/reiserfsprogs/yacc_reiser4.patch
+
+endchoice
+
diff -puN /dev/null parser/lex.l
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/lex.l	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,65 @@
+%Start Normal
+
+LETTER          [A-Za-z_]
+DIG             [0-9]
+WRD             ({LETTER}|{DIG})+
+SP              [ \t\n]+
+SPECIAL         [\[\]\{\}\/\\\,\:\;\*\$\@\!\`\']
+
+
+
+%%
+
+%{
+BEGIN Normal;
+%}
+
+{SP}"/"{SP}                                       {return BLANK_SLASH_BLANK;}
+
+{SP}?";"{SP}?                                     {return SEMICOLON;}
+{SP}?","{SP}?                                     {return COMMA;}
+{SP}?"+"{SP}?                                     {return PLUS;}
+{SP}?"("{SP}?                                     {return L_PARENT;}
+{SP}?")"{SP}?                                     {return R_PARENT;}
+{SP}?"{"{SP}?                                     {return L_FLX_PARENT;}
+{SP}?"}"{SP}?                                     {return R_FLX_PARENT;}
+{SP}?"["{SP}?                                     {return L_SKW_PARENT;}
+{SP}?"]"{SP}?                                     {return R_SKW_PARENT;}
+
+{SP}?eq{SP}?                                      {return EQ;}
+{SP}?ne{SP}?                                      {return NE;}
+{SP}?le{SP}?                                      {return LE;}
+{SP}?ge{SP}?                                      {return GE;}
+{SP}?lt{SP}?                                      {return LT;}
+{SP}?gt{SP}?                                      {return GT;}
+{SP}?is{SP}?                                      {return IS;}
+{SP}?and{SP}?                                     {return AND;}
+{SP}?or{SP}?                                      {return OR;}
+{SP}?not{SP}?                                     {return NOT;}
+{SP}?if{SP}?                                      {return IF;}
+{SP}?then{SP}?                                    {return THEN;}
+{SP}?else{SP}?                                    {return ELSE;}
+{SP}?exist{SP}?                                   {return EXIST;}
+
+{SP}?"<""-"{SP}?                                  {return L_ASSIGN;}
+{SP}?"<""-""="{SP}?                               {return L_SYMLINK;}
+
+{SP}?tw"/""("{SP}?                                {return TRANSCRASH;}
+
+"/"process                                        {return SLASH_PROCESS;}
+"/"stat                                           {return SLASH_STAT;}
+"/"range                                          {return SLASH_RANGE;}
+"/""("                                            {return SLASH_L_PARENT;}
+"/"                                               {return SLASH;}
+
+
+{SP}?"]"{SP}?                                     {return BLANK_SLASH_BLANK;}
+
+
+{WRD}                                             { return  WORD ;}
+
+.                                                 { return  0 ;}
+%%
+
+
+
diff -puN /dev/null parser/lib.c
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/lib.c	2005-06-30 22:20:32.334003232 +0400
@@ -0,0 +1,2519 @@
+/*
+ * Copyright 2001, 2002, 2003, 2004, 2005 by Hans Reiser, licensing governed by reiser4/README
+ */
+
+/*
+ * functions for parser.y
+ */
+
+#include "pars.yacc.h"
+#include "lib.h"
+#include "pars.cls.h"
+#include <linux/mount.h>
+
+
+
+static expr_v4_t *
+init_root_pwd(struct reiser4_syscall_w_space *,
+	      pars_var_t * ,
+	      char * );
+
+#if 0
+#define w_printk(e) printk(e)
+#else
+#define w_printk(e) 
+#endif
+
+static void
+print_pwd_count(char * mess)
+{
+	printk ("\n%s rootmnt=%d, root_de=%d,pwdmnt=%d, pwd_de=%d\n",
+		mess,
+		current->fs->rootmnt->mnt_count,
+		current->fs->root->d_count,
+		current->fs->pwdmnt->mnt_count,
+		current->fs->pwd->d_count);
+}
+
+
+
+#define reiser4_get( ws, current_fs, mnt, de ) \
+{\
+	(ws)->nd.mnt =  (current_fs)->(mnt); \
+	(ws)->nd.dentry =  (current_fs)->(de) ;\
+}
+
+
+static lnode_dentry *
+reiser4_get_ln(struct reiser4_syscall_w_space *ws,
+	       lnode_dentry * l_de)
+{
+	assert("VD-reiser4_get_ln: l_de ==NULL",   l_de != NULL);
+	assert("VD-reiser4_get_ln: LNODE_DENTRY",  l_de->h.type == LNODE_DENTRY );
+	assert("VD-reiser4_get_ln: dentry",        ws->nd.dentry != NULL );
+	assert("VD-reiser4_get_ln: mnt",           ws->nd.mnt != NULL );
+	//	assert("VD-reiser4_get_ln: dentry",        l_de->dentry != NULL );
+	//	assert("VD-reiser4_get_ln: mnt",           l_de->mnt != NULL );
+#if 0
+	read_lock(&current->fs->lock);
+	l_de->mnt    = mntget( ws->nd.mnt );
+	l_de->dentry = dget  ( ws->nd.dentry ) ;
+	read_unlock(&current->fs->lock);
+#else
+	l_de->mnt    =  ws->nd.mnt;
+	l_de->dentry =  ws->nd.dentry;
+#endif
+	return l_de;
+}
+
+static void
+path4_release(lnode_dentry * l_de )
+{
+	assert("VD-path4_release: l_de ==NULL",   l_de != NULL);
+	assert("VD-path4_release: LNODE_DENTRY",  l_de->h.type == LNODE_DENTRY );
+	assert("VD-path4_release: dentry",        l_de->dentry != NULL );
+	assert("VD-path4_release: mnt",           l_de->mnt != NULL );
+#if 0
+	dput( l_de->dentry );
+	mntput( l_de->mnt );
+#endif
+}
+
+
+#define LEX_XFORM  1001
+#define LEXERR2    1002
+#define LEX_Ste    1003
+
+#if defined(CONFIG_REISER4_FS_SYSCALL_BISON)
+static void yyerror(char * message)
+{
+	printk("%s\n", message);
+}
+#else
+/* printing errors for parsing */
+static void
+yyerror( struct reiser4_syscall_w_space *ws  /* work space ptr */,
+	 int msgnum  /* message number */, ...)
+{
+	char errstr[120]={"\nreiser4 parser:"};
+	char * s;
+	va_list args;
+	va_start(args, msgnum);
+	switch (msgnum) {
+	case   101:
+		strcat(errstr,"yacc stack overflow");
+		break;
+	case LEX_XFORM:
+		strcat(errstr,"x format has odd number of symbols");
+		break;
+	case LEXERR2:
+/*			int state = va_arg(args, int);*/
+		strcat(errstr,"internal lex table error");
+		break;
+	case LEX_Ste:
+		strcat(errstr,"wrong lexem");
+		break;
+	case 11111:
+		{
+			int state = va_arg(args, int);
+			{
+				char ss[16];
+/*				int s = va_arg(args, int);*/
+				sprintf( ss,"%4d ", state);
+				strcat( errstr, ss );
+			}
+			strcat( errstr, " syntax error:" );
+			switch(state) {
+//		case 4:
+//			strcat(errstr," wrong operation");
+//			break;
+			case 6:
+				strcat(errstr," wrong assign operation");
+				break;
+			case 7:
+			case 12:
+				strcat(errstr," wrong name");
+				break;
+			case 27:
+				strcat(errstr," wrong logical operation");
+				break;
+			case 10:
+				strcat(errstr," wrong THEN keyword");
+				break;
+			case 34:
+			case 50:
+				strcat(errstr," wrong separatop");
+				break;
+			default:
+				strcat(errstr," strange error");
+				break;
+			}
+		}
+		break;
+	}
+	va_end(args);
+	printk( "\n%s\n", ws->ws_inline );
+	for (s=ws->ws_inline; s<curr_symbol(ws); s++)
+		{
+			if (*s=='\t' ) {
+				printk("\t");
+			} else {
+				printk(" ");
+			}
+		}
+	printk("^");
+	printk(errstr);
+	printk("\n");
+//	printk("\n%s",curr_symbol(ws));
+}
+#endif
+
+
+/* free lists of work space*/
+static void
+freeList(free_space_t * list /* head of list to be fee */)
+{
+	free_space_t * curr,* next;
+	next = list;
+	while (next) {
+		curr = next;
+		next = curr->free_space_next;
+		kfree(curr);
+	}
+}
+
+static void
+pop_all_val(struct reiser4_syscall_w_space * ws ,
+	    pars_var_t  * var )
+{
+	while ( (var->val) != NULL ) {
+		pop_var_val_stack( ws, var->val, 0 );
+	}
+}
+
+/* free work space*/
+static int
+reiser4_pars_free(struct reiser4_syscall_w_space * ws /* work space ptr */)
+{
+	pars_var_t  * var;
+	//	pars_var_value_t * val;
+	assert("VD-reiser4_pars_free:ws_level",        ws->ws_level >= 0);
+	assert("VD-reiser4_pars_free:cur_exp" ,        ws->cur_level->cur_exp != NULL);
+
+	var = ws->Head_pars_var;
+	while( var!=NULL ) {
+		pop_all_val( ws, var );
+		var = var->next;
+	}
+
+	//	free_expr( ws, ws->cur_level->cur_exp );
+	//	free_expr( ws, ws->root_e );
+	if ( ws->freeSpHead ) {
+		freeList(ws->freeSpHead);
+	}
+
+	kfree(ws);
+	return 0;
+}
+
+static void
+print_all_val( pars_var_t  * var )
+{
+	pars_var_value_t * val;
+	val=var->val;
+	while ( val != NULL ) {
+		val = val->prev;
+	}
+}
+
+/* free work space*/
+static void
+print_var_values(struct reiser4_syscall_w_space * ws /* work space ptr */)
+{
+	pars_var_t  * var;
+	var = ws->Head_pars_var;
+	while( var!=NULL ) {
+		print_all_val( var );
+		var = var->next;
+	}
+}
+
+#define INITNEXTFREESPACE(fs)	(fs)->free_space_next = NULL;                                      \
+                                (fs)->freeSpaceMax   = (fs)->freeSpaceBase+FREESPACESIZE;         \
+			        (fs)->freeSpace      = (fs)->freeSpaceBase
+
+/* allocate work space */
+static free_space_t *
+free_space_alloc()
+{
+	free_space_t * fs;
+	fs = ( free_space_t * ) kmalloc( sizeof( free_space_t ), GFP_KERNEL ) ;
+	assert("VD kmalloc work space",fs!=NULL);
+	memset( fs , 0, sizeof( free_space_t ));
+	INITNEXTFREESPACE(fs);
+	return fs;
+}
+
+#define GET_FIRST_FREESPHEAD(ws) (ws)->freeSpHead
+#define GET_NEXT_FREESPHEAD(curr) (curr)->free_space_next
+
+/* allocate next work space */
+static free_space_t *
+freeSpaceNextAlloc(struct reiser4_syscall_w_space * ws /* work space ptr */ )
+{
+	free_space_t * curr,* next;
+	curr=NULL;
+	next = GET_FIRST_FREESPHEAD(ws);
+	while (next) {
+		curr = next;
+		next = GET_NEXT_FREESPHEAD(curr);
+	}
+	next = free_space_alloc();
+	if(curr==NULL) 		{
+		ws->freeSpHead=next;
+	}
+	else {
+		curr->free_space_next=next;
+	}
+	next->free_space_next=NULL;
+	return next;
+}
+
+/* allocate field lenth=len in work space */
+static char*
+list_alloc(struct reiser4_syscall_w_space * ws /* work space ptr */,
+	   int len  /* lenth of structures to be allocated in bytes */)
+{
+	char * rez;
+	if( (ws->freeSpCur->freeSpace+len) > (ws->freeSpCur->freeSpaceMax) ) {
+		ws->freeSpCur = freeSpaceNextAlloc(ws);
+	}
+	rez = ws->freeSpCur->freeSpace;
+	ws->freeSpCur->freeSpace += ROUND_UP(len);
+	return rez;
+}
+
+/* allocate new level of parsing in work space */
+static streg_t *
+alloc_new_level(struct reiser4_syscall_w_space * ws /* work space ptr */ )
+{
+	return ( streg_t *)  list_alloc(ws,sizeof(streg_t));
+}
+
+/* allocate structure of new variable of input expression */
+static pars_var_t *
+alloc_pars_var(struct reiser4_syscall_w_space * ws /* work space ptr */,
+	       pars_var_t * last_pars_var /* last of allocated pars_var or NULL if list is empty */)
+{
+	pars_var_t * pars_var;
+	pars_var = (pars_var_t *)list_alloc( ws, sizeof( pars_var_t ) );
+	if ( last_pars_var == NULL ) {
+		ws->Head_pars_var = pars_var;
+	}
+	else {
+		last_pars_var->next = pars_var;
+	}
+	pars_var->val  = NULL;
+	pars_var->next = NULL;
+	return pars_var;
+}
+
+
+static unsigned long atol(char *str)
+{
+	unsigned long	val;
+	int		base, c;
+	char		*sp;
+
+	val = 0;
+	sp = str;
+	if ((*sp == '0') && (*(sp+1) == 'x')) {
+		base = 16;
+		sp += 2;
+	} else if (*sp == '0') {
+		base = 8;
+		sp++;
+	} else {
+		base = 10;
+	}
+
+	for (; (*sp != 0); sp++) {
+		c = (*sp > '9') ? (TOLOWER(*sp) - 'a' + 10) : (*sp - '0');
+		if ((c < 0) || (c >= base)) {
+			break;
+		}
+		val = (val * base) + c;
+	}
+	return(val);
+}
+
+
+/* free lnodes used in expression */
+static int
+free_expr( struct reiser4_syscall_w_space * ws,
+	   expr_v4_t * expr)
+{
+	expr_list_t * tmp;
+	int ret = 0;
+	assert("VD-free_expr", expr!=NULL);
+	switch (expr->h.type) {
+	case EXPR_WRD:
+		break;
+	case EXPR_RANGE:
+		ret = free_expr( ws, expr->rng.host);
+		kfree(expr);
+		break;
+	case EXPR_PARS_VAR:
+		pop_var_val_stack( ws, expr->pars_var.v->val, 1 );
+		break;
+	case EXPR_LIST:
+		tmp=&expr->list;
+		while (tmp) {
+			assert("VD-free_expr.EXPR_LIST", tmp->h.type==EXPR_LIST);
+			ret |= free_expr( ws, tmp->source );
+			tmp = tmp->next;
+		}
+		break;
+	case EXPR_ASSIGN:
+		ret = pop_var_val_stack( ws, expr->assgn.target->val, 1 );
+		ret |= free_expr( ws, expr->assgn.source );
+		break;
+	case EXPR_LNODE:
+		assert("VD-free_expr.lnode.lnode", expr->lnode.lnode != NULL );
+		if ( expr->lnode.lnode->h.type == LNODE_DENTRY ) {
+			path4_release( &(expr->lnode.lnode->l_dentry) );
+		}
+		lput( expr->lnode.lnode ); 
+		break;
+	case EXPR_FLOW:
+		break;
+	case EXPR_OP2:
+		ret  = free_expr( ws, expr->op2.op_r );
+		ret |= free_expr( ws, expr->op2.op_l );
+		break;
+	case EXPR_OP:
+		ret = free_expr( ws, expr->op.op );
+		break;
+	}
+	return ret;
+}
+
+
+//ln->inode.inode->i_op->lookup(struct inode *,struct dentry *);
+//current->fs->pwd->d_inode->i_op->lookup(struct inode *,struct dentry *);
+
+#if 0
+/* alloca the space for lnode */
+static lnode *
+alloc_lnode(struct reiser4_syscall_w_space * ws /* work space ptr */ )
+{
+	lnode * ln;
+	ln = ( lnode * ) kmalloc( sizeof( lnode ), GFP_KERNEL);
+	assert("VD-alloc_pars_var", ln != NULL );
+	memset( ln , 0, sizeof( lnode ));
+	return ln;
+}
+#endif
+
+/* make lnode_dentry from inode for root and pwd */
+static lnode *
+get_lnode(struct reiser4_syscall_w_space * ws /* work space ptr */ )
+{
+	lnode * ln;
+	//	reiser4_key key, * k_rez,* l_rez;
+	
+#if 0                      /*def NOT_YET*/
+	if ( is_reiser4_inode( ws->nd.dentry->inode ) ) {
+
+		k_rez             = build_sd_key( ws->nd.dentry->inode, &key);
+		ln                = lget(  LNODE_REISER4_INODE, get_inode_oid( ws->nd.dentry->inode) );
+		//			ln->lw.lw_sb = ws->nd.dentry->inode->isb;
+		ln->reiser4_inode.inode = /*????*/  ws->nd.dentry->inode->isb;
+		ln->reiser4_inode.inode = /*????*/  ws->nd.dentry->inode->isb;
+		PTRACE( ws, "r4: lnode=%p", ln );
+	}
+	else
+#endif
+		{
+			ln                = lget( LNODE_DENTRY, get_inode_oid( ws->nd.dentry->d_inode) );
+
+		}
+	return ln;
+}
+
+/*  allocate work space, initialize work space, tables, take root inode and PWD inode */
+static struct reiser4_syscall_w_space *
+reiser4_pars_init(void)
+{
+	struct reiser4_syscall_w_space * ws;
+
+	/* allocate work space for parser working variables, attached to this call */
+	ws = kmalloc( sizeof( struct reiser4_syscall_w_space ), GFP_KERNEL );
+	assert("VD_allock work space", ws != NULL);
+	memset( ws, 0, sizeof( struct reiser4_syscall_w_space ));
+
+#if defined(CONFIG_REISER4_FS_SYSCALL_YACC)
+	ws->ws_yystacksize = MAXLEVELCO; /* must be 500 by default */
+	ws->ws_yymaxdepth  = MAXLEVELCO; /* must be 500 by default */
+#endif
+	                                                    /* allocate first part of working tables
+							       and initialise headers */
+	ws->freeSpHead          = free_space_alloc();
+	ws->freeSpCur           = ws->freeSpHead;
+	ws->wrdHead             = NULL;
+	ws->cur_level           = alloc_new_level(ws);
+	//	ws->root_e              = init_root(ws);
+	//	ws->cur_level->cur_exp  = init_pwd(ws);
+
+
+	ws->root_e              = init_root_pwd( ws, NULL, "/" );
+	ws->cur_level->cur_exp  = init_root_pwd( ws, ws->root_e->pars_var.v, current->fs->pwd->d_name.name );
+
+
+
+	ws->cur_level->wrk_exp  = ws->cur_level->cur_exp;                        /* current wrk for new level */
+	ws->cur_level->prev     = NULL;
+	ws->cur_level->next     = NULL;
+	ws->cur_level->level    = 0;
+	ws->cur_level->stype    = 0;
+	return ws;
+}
+
+#if 0
+static expr_v4_t *
+named_level_down(struct reiser4_syscall_w_space *ws /* work space ptr */,
+		 expr_v4_t * e /* name for expression  */,
+		 expr_v4_t * e1,
+		 long type /* type of level we going to */)
+{
+	struct qstr *u;
+	char * ret
+	static int push_var_val_stack( ws, struct pars_var * var, long type )
+
+	rezult->u.data  = kmalloc( SIZEFOR_ASSIGN_RESULT, GFP_KERNEL ) ;
+	sprintf( rezult->u.data, "%d", ret_code );
+
+	level_down( ws, , type2 );
+	return e1;
+}
+
+
+/* level up of parsing level */
+static void
+level_up_named(struct reiser4_syscall_w_space *ws /* work space ptr */,
+	       expr_v4_t * e1 /* name for expression  */,
+	       long type /* type of level we going to */)
+{
+	pars_var_t * rezult;
+
+	assert("wrong type of named expression", type == CD_BEGIN );
+
+	rezult =  e1->pars_var.v;
+	switch ( e1->pars_var.v->val->vtype) {
+	case VAR_EMPTY:
+		break;
+	case VAR_LNODE:
+		break;
+	case VAR_TMP:
+		break;
+	}
+
+	/* make name for w in this level. ????????
+	   not yet worked */
+
+
+	rezult =  lookup_pars_var_word( ws , sink, make_new_word(ws, ASSIGN_RESULT ), VAR_TMP);
+	rezult->u.data  = kmalloc( SIZEFOR_ASSIGN_RESULT, GFP_KERNEL ) ;
+	sprintf( rezult->u.data, "%d", ret_code );
+	
+?????
+
+	level_up( ws, type );
+}
+
+#endif
+
+
+static expr_v4_t *
+target_name( expr_v4_t *assoc_name,
+	     expr_v4_t *target )
+{
+	target->pars_var.v->val->associated = assoc_name->pars_var.v;
+	return target;
+}
+
+/* level up of parsing level */
+static void
+level_up(struct reiser4_syscall_w_space *ws /* work space ptr */,
+	 long type /* type of level we going to */)
+{
+	if (ws->cur_level->next==NULL) {
+		ws->cur_level->next        = alloc_new_level(ws);
+		ws->cur_level->next->next  = NULL;
+		ws->cur_level->next->prev  = ws->cur_level;
+		ws->cur_level->next->level = ws->cur_level->level+1;
+	}
+	ws->cur_level           = ws->cur_level->next;
+	ws->cur_level->stype    = type;
+	ws->cur_level->cur_exp  = ws->cur_level->prev->wrk_exp;                  /* current pwd for new level */
+	ws->cur_level->wrk_exp  = ws->cur_level->cur_exp;                        /* current wrk for new level */
+}
+
+
+/* level down of parsing level */
+static  void
+level_down(struct reiser4_syscall_w_space * ws /* work space ptr */,
+	   long type1 /* type of level that was up( for checking) */,
+	   long type2 /* type of level that is down(for checking)*/)
+{
+	pars_var_value_t * ret,*next;
+	assert("VD-level_down: type mithmatch", type1 == type2 );
+	assert("VD-level_down: type mithmatch with level", type1 == ws->cur_level->stype );
+	assert("VD-level_down: This is top level, prev == NULL", ws->cur_level->prev != NULL);
+	ret = ws->cur_level->val_level;
+	while( ret != NULL )
+		{
+			next = ret->next_level;
+			assert("VD: level down: not top value was pop", ret == ret->host->val);
+			pop_var_val_stack( ws, ret, 1 );
+			ret = next;
+		}
+	free_expr( ws, ws->cur_level->prev->wrk_exp );
+	ws->cur_level->prev->wrk_exp = ws->cur_level->wrk_exp ;           /* current wrk for prev level */
+	ws->cur_level                = ws->cur_level->prev;
+}
+
+/* copy name from param to free space,*/
+static  wrd_t *
+make_new_word(struct reiser4_syscall_w_space * ws /* work space ptr */,
+	      char *txt /* string to put in name table */)
+{
+	ws->tmpWrdEnd = ws->freeSpCur->freeSpace;
+	strcat( ws->tmpWrdEnd, txt );
+	ws->tmpWrdEnd += strlen(txt) ;
+	*ws->tmpWrdEnd++ = 0;
+	return _wrd_inittab( ws );
+}
+
+
+/* move_selected_word - copy term from input bufer to free space.
+ * if it need more, move freeSpace to the end.
+ * otherwise next term will owerwrite it
+ *  freeSpace is a kernel space no need make getnam().
+ * exclude is for special for string: store without ''
+ */
+static void
+move_selected_word(struct reiser4_syscall_w_space * ws /* work space ptr */,
+		   int exclude  /* TRUE - for storing string without first and last symbols
+				   FALS - for storing names */,
+		   int press )
+{
+	int i;
+	/*	char * s= ws->ws_pline;*/
+	if (exclude) {
+		ws->yytext++;
+	}
+	for( ws->tmpWrdEnd = ws->freeSpCur->freeSpace; ws->yytext < curr_symbol(ws); ) {
+		i=0;
+#if 0
+		if ( lcls == Ste ) {
+			while( *ws->yytext == '\"' ) {
+				ws->yytext++;
+				i++;
+			}
+			while ( ws->yytext >  curr_symbol(ws) ) {
+				i--;
+				ws->yytext--;
+			}
+		}
+		if ( i ) for ( i/=2; i; i-- )      *ws->tmpWrdEnd++='\"';    /*   in source text for each "" - result will "   */
+#endif
+		/*         \????????   */ 
+		if ( press && *ws->yytext == '\\' ) {
+			int tmpI;
+			ws->yytext++;
+			switch ( tolower( (int)*(ws->yytext) ) ) {
+			case 'x':                       /*  \x01..9a..e  */
+				i = 0;
+				tmpI = 1;
+				while( tmpI) {
+					if (isdigit( (int)*(ws->yytext) ) ) {
+						i = (i << 4) + ( *ws->yytext++ - '0' );
+					}
+					else if( tolower( (int) *(ws->yytext) ) >= 'a' && tolower( (int)*(ws->yytext) ) <= 'e' ) {
+						i = (i << 4) + ( *ws->yytext++ - 'a' + 10 );
+						}
+					else {
+						if ( tmpI & 1 ) {
+#if defined(CONFIG_REISER4_FS_SYSCALL_BISON)
+							yyerror("x format has odd number of symbols");
+#else
+							yyerror( ws, LEX_XFORM ); /* x format has odd number of symbols */
+#endif
+						}
+						tmpI = 0;
+					}
+					if ( tmpI && !( tmpI++ & 1 ) ) {
+						*ws->tmpWrdEnd++ = (unsigned char) i;
+						i = 0;
+					}
+				}
+				break;
+			}
+		}
+		else *ws->tmpWrdEnd++ = *ws->yytext++;
+		if( ws->tmpWrdEnd > (ws->freeSpCur->freeSpaceMax - sizeof(wrd_t)) ) {
+			free_space_t * tmp;
+			int i;
+			assert ("VD sys_reiser4. selectet_word:Internal space buffer overflow: input token exceed size of bufer",
+				ws->freeSpCur->freeSpace > ws->freeSpCur->freeSpaceBase);
+			/* we can reallocate new space and copy all
+			   symbols of current token inside it */
+			tmp=ws->freeSpCur;
+			ws->freeSpCur = freeSpaceNextAlloc(ws);
+			assert ("VD sys_reiser4:Internal text buffer overflow: no enouse mem", ws->freeSpCur !=NULL);
+			i = ws->tmpWrdEnd - tmp->freeSpace;
+			memmove( ws->freeSpCur->freeSpace, tmp->freeSpace, i );
+			ws->tmpWrdEnd = ws->freeSpCur->freeSpace + i;
+		}
+	}
+	if (exclude) {
+		ws->tmpWrdEnd--;
+	}
+	*ws->tmpWrdEnd++ = '\0';
+}
+
+
+/* compare parsed word with keywords*/
+static int
+b_check_word(struct reiser4_syscall_w_space * ws /* work space ptr */)
+{
+	int i, j, l;
+	j=sizeof(pars_key)/(sizeof(char*)+sizeof(int))-1;
+	l=0;
+	while( ( j - l ) >= 0 ) {
+		i  =  ( j + l /*+ 1*/ ) >> 1;
+		switch( strcmp( pars_key[i].wrd, ws->freeSpCur->freeSpace ) ) {
+		case  0:
+			return( pars_key[i].class );
+			break;
+		case  1: j = i - 1;               break;
+		default: l = i + 1;               break;
+		}
+	}
+	return(0);
+}
+
+
+/* comparing parsed word with already stored words, if not compared, storing it */
+static
+//__inline__
+wrd_t *
+_wrd_inittab(struct reiser4_syscall_w_space * ws /* work space ptr */ )
+{
+	wrd_t * cur_wrd;
+	wrd_t * new_wrd;
+	int len;
+	new_wrd =  ws->wrdHead;
+#if 0
+	len = strlen( ws->freeSpCur->freeSpace) ;
+#else
+	len = ws->tmpWrdEnd - ws->freeSpCur->freeSpace - 1 ;
+#endif
+	cur_wrd = NULL;
+	while ( !( new_wrd == NULL ) ) {
+		cur_wrd = new_wrd;
+		if ( cur_wrd->u.len == len ) {
+			if( !memcmp( cur_wrd->u.name, ws->freeSpCur->freeSpace, cur_wrd->u.len ) ) {
+				return cur_wrd;
+			}
+		}
+		new_wrd = cur_wrd->next;
+	}
+	new_wrd         = ( wrd_t *)(ws->freeSpCur->freeSpace + ROUND_UP( len+1 ));
+	new_wrd->u.name = ws->freeSpCur->freeSpace;
+	new_wrd->u.len  = len;
+	ws->freeSpCur->freeSpace= (char*)new_wrd + ROUND_UP(sizeof(wrd_t));
+	new_wrd->next   = NULL;
+	if (cur_wrd==NULL) {
+		ws->wrdHead   = new_wrd;
+	}
+	else {
+		cur_wrd->next = new_wrd;
+	}
+	return new_wrd;
+}
+
+/* lexical analisator for yacc automat */
+static int
+reiser4_lex(YYSTYPE *par_yylval,
+	    YYLTYPE * par_yylloc,
+	    struct reiser4_syscall_w_space * ws /* work space ptr */)
+{
+	char term, n, i = 0;
+	int ret = 0;
+	char lcls;
+//	char * s ;
+
+//	s = curr_symbol(ws);              /* first symbol or Last readed symbol of the previous token parsing */
+	if ( *curr_symbol(ws) == 0 ) return  0;        /* end of string is EOF */
+
+	while(ncl[(int)*curr_symbol(ws)]==Blk) {
+		next_symbol(ws);
+		if ( *curr_symbol(ws) == 0 ) return  0;  /* end of string is EOF */
+	}
+
+
+	lcls    =       ncl[(int)*curr_symbol(ws)];
+	ws->yytext  = curr_symbol(ws);
+	term = 1;
+	while( term ) {
+		n=lcls;
+		while (  n > 0   ) {
+			next_symbol(ws);
+			lcls=n;
+			n = lexcls[ (int)lcls ].c[ (int)i=ncl[ (int)*curr_symbol(ws) ] ];
+		}
+		if ( n == OK ) {
+			term=0;
+		}
+		else {
+#if defined(CONFIG_REISER4_FS_SYSCALL_BISON)
+			yyerror("internal lex table error");
+#else
+			yyerror ( ws, LEXERR2, (lcls-1)* 20+i );
+#endif
+			return(0);
+		}
+	}
+	switch (lcls) {
+	case Blk:
+#if defined(CONFIG_REISER4_FS_SYSCALL_BISON)
+		yyerror("wrong lexem");
+#else
+		yyerror(ws,LEX_Ste);
+#endif
+		break;
+	case Wrd:
+	case W_e: /*`......"*/
+		if ( lcls == W_e ) {
+			move_selected_word( ws, lexcls[(int) lcls ].c[0], 0 );
+		}
+		else {
+			move_selected_word( ws, lexcls[(int) lcls ].c[0], 1 );
+		}
+		                                                    /* if ret>0 this is keyword */
+		if ( !(ret = b_check_word(ws)) ) {                          /*  this is not keyword. tray check in worgs. ret = Wrd */
+			ret=lexcls[(int) lcls ].term;
+			ws->ws_yylval.wrd = _wrd_inittab(ws);
+		}
+		break;
+	case Int:
+	case Ptr:
+	case Pru:
+	case Ste: 
+		move_selected_word( ws, lexcls[(int) lcls ].c[0], 1 );
+		ret=lexcls[(int) lcls ].term;
+		ws->ws_yylval.wrd = _wrd_inittab(ws);
+		break;
+		/*
+		  move_selected_word( ws, lexcls[ lcls ].c[0], 1 );
+		  ret=lexcls[ lcls ].term;
+		  ws->ws_yyval.w = _wrd_inittab(ws);
+		  break;
+		*/
+	case Com:
+	case Mns:
+	case Les:
+	case Slh:
+	case Bsl: /*\ */
+	case Sp1: /*;*/
+	case Sp2: /*:*/
+	case Dot: /*.*/
+	case Sp4: /*=*/
+	case Sp5: /*>*/
+	case Sp6: /*?*/
+	case ASG:/*<-*/
+	case App:/*<<-*/ /*???*/
+	case Lnk:/*->*/
+	case Pls:/*+*/
+	case Nam:/*<=*/
+		ret=lexcls[(int) lcls ].term;
+		break;
+	case Lpr:
+	case Rpr:
+		ws->ws_yylval.charType = CD_BEGIN ;
+		ret=lexcls[(int) lcls ].term;
+		break;
+	case Lsq:
+	case Rsq:
+		ws->ws_yylval.charType = UNORDERED ;
+		ret=lexcls[(int) lcls ].term;
+		break;
+	case Lfl:
+	case Rfl:
+		ws->ws_yylval.charType = ASYN_BEGIN ;
+		ret=lexcls[(int) lcls ].term;
+		break;
+	default :                                /*  others  */
+		ret=*ws->yytext;
+		break;
+	}
+	return ret;
+}
+
+
+
+/*==========================================================*/
+
+/* allocate new expression @type */
+static expr_v4_t *
+alloc_new_expr(struct reiser4_syscall_w_space * ws /* work space ptr */,
+	       int type /* type of new expression */)
+{
+	expr_v4_t * e;
+	e         = ( expr_v4_t *)  list_alloc( ws, sizeof(expr_v4_t));
+	e->h.type = type;
+	return e;
+}
+
+/* store NULL name in word table */
+static wrd_t *
+nullname(struct reiser4_syscall_w_space * ws /* work space ptr */)
+{
+	return make_new_word(ws,"");
+}
+
+#if 0
+
+/* initialize node  for PWD lnode */
+static expr_v4_t *
+init_pseudo_name(struct reiser4_syscall_w_space * ws /* work space ptr */,
+		 char *name /* name of pseudo */)
+{
+	expr_v4_t * e;
+	e                     = alloc_new_expr(ws,EXPR_PARS_VAR);
+	e->pars_var.v         = alloc_pars_var(ws,ws->root_e->pars_var.v);
+	e->pars_var.v->w      = make_new_word(ws, name);
+	e->pars_var.v->parent = ws->root_e->pars_var.v;
+
+	current->total_link_count = 0;
+	push_var_val_stack( ws, e->pars_var.v, VAR_LNODE );
+	e->pars_var.v->val->u.ln = get_lnode( ws );
+	return e;
+}
+
+static expr_v4_t *
+pars_lookup(struct reiser4_syscall_w_space * ws,
+	    expr_v4_t * e1,
+	    expr_v4_t * e2)
+{
+	not ready;
+	pars_var_t * rez_pars_var;
+	pars_var_t * this_l;
+	this_l = getFirstPars_Var(e1);
+	while(this_l != NULL ) {
+	}
+	assert("pars_lookup:lnode is null",rez_pars_var->ln!=NULL);
+	memcpy( &curent_dentry.d_name   , w, sizeof(struct qstr));<---------------
+		if( ( rez_pars_var->ln = pars_var->ln->d_inode->i_op->lookup( pars_var->ln->d_inode, &curent_dentry) ) == NULL ) {
+			/* lnode not exist: we will not need create it. this is error*/
+		}
+}
+
+#endif
+
+
+/* initialize node  for ROOT and PWD lnode  */
+static expr_v4_t *
+init_root_pwd(struct reiser4_syscall_w_space * ws /* work space ptr */,
+	      pars_var_t * parent,
+	      char * name)
+{
+	expr_v4_t * e;
+	e                     = alloc_new_expr( ws, EXPR_PARS_VAR);
+	e->pars_var.v         = alloc_pars_var( ws, parent);
+	e->pars_var.v->parent = parent;
+	e->pars_var.v->w          = make_new_word( ws, name ) ;
+	current->total_link_count = 0;
+
+	if ( push_var_val_stack( ws, e->pars_var.v, VAR_LNODE ) ) {
+		printk("VD-init_pwd: push_var_val_stack error\n");
+	}
+	else {
+		e->pars_var.v->val->u.ln                  = get_lnode( ws );
+		e->pars_var.v->val->u.ln->h.type          = LNODE_DENTRY;
+		if ( parent == NULL ) {
+			//	walk_init_root( "/", (&ws->nd));   /* from namei.c walk_init_root */
+			read_lock(&current->fs->lock);
+			e->pars_var.v->val->u.ln->l_dentry.mnt    = mntget( current->fs->rootmnt); 
+			e->pars_var.v->val->u.ln->l_dentry.dentry = dget( current->fs->root);
+			read_unlock(&current->fs->lock);
+		}
+		else {
+			read_lock(&current->fs->lock);
+			e->pars_var.v->val->u.ln->l_dentry.mnt    = mntget(current->fs->pwdmnt);
+			e->pars_var.v->val->u.ln->l_dentry.dentry = dget(current->fs->pwd);
+			read_unlock(&current->fs->lock);
+		}
+	}
+	return e;
+}
+
+
+
+#if 0
+/* initialize node  for ROOT and PWD lnode  */
+static expr_v4_t *
+init_root_pwd(struct reiser4_syscall_w_space * ws /* work space ptr */,
+	      pars_var_t * parent,
+	      char * name)
+{
+	expr_v4_t * e;
+	e                     = alloc_new_expr( ws, EXPR_PARS_VAR);
+	e->pars_var.v         = alloc_pars_var( ws, parent);
+	e->pars_var.v->parent = parent;
+	if ( parent == NULL ) {
+		//	walk_init_root( "/", (&ws->nd));   /* from namei.c walk_init_root */
+		read_lock(&current->fs->lock);
+		ws->nd.mnt    = mntget( current->fs->rootmnt); 
+		ws->nd.dentry = dget( current->fs->root);
+		read_unlock(&current->fs->lock);
+		print_pwd_count("dget root ");
+	}
+	else {
+		//	path_lookup(".",,&(ws->nd));   /* from namei.c path_lookup */
+		read_lock(&current->fs->lock);
+		ws->nd.mnt    = mntget(current->fs->pwdmnt);
+		ws->nd.dentry = dget(current->fs->pwd);
+		read_unlock(&current->fs->lock);
+		print_pwd_count("dget pwd ");
+	}
+	e->pars_var.v->w          = make_new_word( ws, name ) ;
+	current->total_link_count = 0;
+	if ( push_var_val_stack( ws, e->pars_var.v, VAR_LNODE ) ) {
+		printk("VD-init_pwd: push_var_val_stack error\n");
+	}
+	else {
+		e->pars_var.v->val->u.ln                  = get_lnode( ws );
+		e->pars_var.v->val->u.ln->l_dentry.mnt    = ws->nd.mnt;
+		e->pars_var.v->val->u.ln->l_dentry.dentry = ws->nd.dentry;
+	}
+	return e;
+}
+#endif
+
+
+
+
+
+/*    Object_Name : begin_from name                 %prec ROOT       { $$ = pars_expr( ws, $1, $2 ) ; }
+                  | Object_Name SLASH name                           { $$ = pars_expr( ws, $1, $3 ) ; }  */
+static expr_v4_t *
+pars_expr(struct reiser4_syscall_w_space * ws /* work space ptr */,
+	  expr_v4_t * e1 /* first expression ( not yet used)*/,
+	  expr_v4_t * e2 /* second expression*/)
+{
+	ws->cur_level->wrk_exp = e2;
+	print_var_values(ws);
+	return e2;
+}
+
+/* not yet */
+static pars_var_t *
+getFirstPars_VarFromExpr(struct reiser4_syscall_w_space * ws )
+{
+	pars_var_t * ret = 0;
+	expr_v4_t * e = ws->cur_level->wrk_exp;
+	switch (e->h.type) {
+	case EXPR_PARS_VAR:
+		ret = e->pars_var.v;
+		break;
+		//	default:
+
+	}
+	return ret;
+}
+
+/* seach @parent/w in internal table. if found return it, else @parent->lookup(@w) */
+static pars_var_t *
+lookup_pars_var_word(struct reiser4_syscall_w_space * ws /* work space ptr */,
+		     pars_var_t * parent /* parent for w       */,
+		     wrd_t * w        /* to lookup for word */,
+		     int type)
+{
+	pars_var_t * rez_pars_var;
+	struct dentry *de;
+	//	int rez;
+	pars_var_t * last_pars_var;
+	last_pars_var  = NULL;
+	rez_pars_var   = ws->Head_pars_var;
+	while ( rez_pars_var != NULL ) {
+		if( rez_pars_var->parent == parent &&
+		    rez_pars_var->w      == w ) {
+			rez_pars_var->val->count++;
+			return rez_pars_var;
+		}
+		last_pars_var = rez_pars_var;
+		rez_pars_var  = rez_pars_var->next;
+	}
+//	reiser4_fs        = 0;
+	rez_pars_var         = alloc_pars_var(ws, last_pars_var);
+	rez_pars_var->w      = w;
+	rez_pars_var->parent = parent;
+
+	switch (parent->val->vtype) {
+	case VAR_EMPTY:
+		break;
+	case VAR_LNODE:
+		switch (parent->val->u.ln->h.type) {
+		case LNODE_DENTRY:
+			ws->nd.dentry = parent->val->u.ln->l_dentry.dentry;
+			ws->nd.mnt    = parent->val->u.ln->l_dentry.mnt;
+			ws->nd.flags  = LOOKUP_NOALT ;
+			if ( link_path_walk( w->u.name, &(ws->nd) ) ) /* namei.c */ {
+				printk("lookup error: w->u.name=%s\n", w->u.name);
+				push_var_val_stack( ws, rez_pars_var, VAR_TMP );
+				rez_pars_var->val->u.data = NULL;
+			}
+			else {
+				push_var_val_stack( ws, rez_pars_var, VAR_LNODE );
+				oid_t oid = get_inode_oid( ws->nd.dentry->d_inode);
+				rez_pars_var->val->u.ln = reiser4_get_ln( ws, lget( LNODE_DENTRY, oid ) );
+			}
+			break;
+		case LNODE_INODE:  /* not use it ! */
+			de = d_alloc_anon(parent->val->u.ln->l_inode.inode);
+			break;
+		case LNODE_REISER4_INODE:
+			rez_pars_var->val->u.ln->h.type        = LNODE_REISER4_INODE /* LNODE_LW */;
+#if 0                   /*   NOT_YET  ???? */
+			//			ln                = lget( LNODE_DENTRY, get_key_objectid(&key ) );
+			result = coord_by_key(get_super_private(parent->val->ln->lw.lw_sb)->tree,
+					      parent->val->ln->lw.key,
+					      &coord,
+					      &lh,
+					      ZNODE_READ_LOCK,
+					      FIND_EXACT,
+					      LEAF_LEVEL,
+					      LEAF_LEVEL,
+					      CBK_UNIQUE,
+					      0);
+			//			if (REISER4_DEBUG && result == 0)
+			//				check_sd_coord(coord, key);
+			if (result != 0) {
+				lw_key_warning(parent->val->ln->lw.key, result);
+			}
+			else {
+				switch(item_type_by_coord(coord)) {
+				case STAT_DATA_ITEM_TYPE:
+				case DIR_ENTRY_ITEM_TYPE:
+					iplug = item_plugin_by_coord(coord);
+					if (iplug->b.lookup != NULL) {
+						iplug->b.lookup();   /*????*/
+					}
+					
+				case INTERNAL_ITEM_TYPE:
+					w_printk("VD-item type is INTERNAL\n");
+				case ORDINARY_FILE_METADATA_TYPE:
+				case OTHER_ITEM_TYPE:
+					w_printk("VD-item type is OTHER\n");
+				}
+			}
+			/*??  lookup_sd     find_item_obsolete */
+#endif
+		case LNODE_LW: /* not yet work */
+			break;
+		case LNODE_COORD:  /* not use it ! */
+			break;
+//		case LNODE_PSEUDO:
+//			PTRACE(ws, "parent pseudo=%p",parent->val->u.ln->l_pseudo);
+//			break;
+
+		}
+		break;
+	case VAR_TMP:
+		push_var_val_stack( ws, rez_pars_var, VAR_TMP );
+		rez_pars_var->val->u.data = NULL;
+		break;
+	}
+
+	return rez_pars_var;
+}
+
+
+/* search pars_var for @w */
+static expr_v4_t *
+lookup_word(struct reiser4_syscall_w_space * ws /* work space ptr */,
+	    wrd_t * w /* word to search for */)
+{
+	expr_v4_t * e;
+	pars_var_t * cur_pars_var;
+#if 1           /* tmp.  this is fist version.  for II we need do "while" throus expression for all pars_var */
+	cur_pars_var        = ws->cur_level->wrk_exp->pars_var.v;
+#else
+	cur_pars_var       = getFirstPars_VarFromExpr(ws);
+	while(cur_pars_var!=NULL) {
+#endif
+		e                = alloc_new_expr( ws, EXPR_PARS_VAR );
+		e->pars_var.v    = lookup_pars_var_word( ws, cur_pars_var, w , VAR_LNODE);
+#if 0
+		cur_pars_var=getNextPars_VarFromExpr(ws);
+	}
+	all rezult mast be connected to expression.
+#endif
+	return e;
+}
+
+/* set work path in level to current in level */
+static inline expr_v4_t *
+pars_lookup_curr(struct reiser4_syscall_w_space * ws /* work space ptr */)
+{
+	ws->cur_level->wrk_exp  = ws->cur_level->cur_exp;                        /* current wrk for pwd of level */
+	return ws->cur_level->wrk_exp;
+}
+
+/* set work path in level to root */
+static inline expr_v4_t *
+pars_lookup_root(struct reiser4_syscall_w_space * ws)
+{
+	ws->cur_level->wrk_exp  = ws->root_e;                                    /* set current to root */
+	return ws->cur_level->wrk_exp;
+}
+
+static inline expr_v4_t *
+pars_lookup_process(struct reiser4_syscall_w_space * ws,
+		    val_range_t * val)
+{
+	ws->cur_level->wrk_exp  = ws->root_e;                                    /* set current to root */
+	return ws->cur_level->wrk_exp;
+}
+
+
+
+#if 0
+/*?????*/
+
+/* implementation of lookup_name() method for hashed directories
+
+   it looks for name specified in @w in reiser4_inode @parent and if name is found - key of object found entry points
+   to is stored in @key */
+reiser4_internal int
+lookup_name_hashed_reiser4(reiser4_inode *parent /* reiser4 inode of directory to lookup for name in */,
+			    wrd_t *w             /* name to look for */,
+			    reiser4_key *key     /* place to store key */)
+{
+	int result;
+	coord_t *coord;
+	lock_handle lh;
+	const char *name;
+	int len;
+	reiser4_dir_entry_desc entry;
+
+	assert("nikita-1247", parent != NULL);
+	assert("nikita-1248", w != NULL);
+
+??	assert("vs-1486", dentry->d_op == &reiser4_dentry_operations);
+
+	result = reiser4_perm_chk(parent, lookup, parent, &w->u);
+
+
+	if (result != 0)
+		return 0;
+
+	name = w->u.name;
+	len = w->u.len;
+
+	if ( len > parent->pset->dir_item)
+		/* some arbitrary error code to return */
+		return RETERR(-ENAMETOOLONG);
+
+	coord = &reiser4_get_dentry_fsdata(dentry)->dec.entry_coord; ???????
+	coord_clear_iplug(coord);
+
+
+
+
+	init_lh(&lh);
+
+	ON_TRACE(TRACE_DIR | TRACE_VFS_OPS, "lookup inode: %lli \"%s\"\n", get_inode_oid(parent), dentry->d_name.name);
+
+	/* find entry in a directory. This is plugin method. */
+
+
+	//	result = find_entry(parent, dentry, &lh, ZNODE_READ_LOCK, &entry);
+
+
+	if (result == 0) {
+		/* entry was found, extract object key from it. */
+		result = WITH_COORD(coord, item_plugin_by_coord(coord)->s.dir.extract_key(coord, key));
+	}
+	done_lh(&lh);
+	return result;
+
+}
+
+node_plugin_by_node(coord->node)->lookup(coord->node, key, FIND_MAX_NOT_MORE_THAN, &twin);
+item_type_by_coord(coord)
+
+/*
+ * try to look up built-in pseudo file by its name.
+ */
+reiser4_internal int
+lookup_pseudo_file(reiser4_inode *parent /* reiser4 inode of directory to lookup for name in */,
+		   wrd_t *w             /* name to look for */,
+		   reiser4_key *key     /* place to store key */)
+     //		   struct dentry * dentry)
+{
+	reiser4_plugin *plugin;
+	const char     *name;
+	struct inode   *pseudo;
+	int             result;
+
+
+
+
+
+
+	assert("nikita-2999", parent != NULL);
+	assert("nikita-3000", dentry != NULL);
+
+	/* if pseudo files are disabled for this file system bail out */
+	if (reiser4_is_set(parent->i_sb, REISER4_NO_PSEUDO))
+		return RETERR(-ENOENT);
+
+	name = dentry->d_name.name;
+	pseudo = ERR_PTR(-ENOENT);
+	/* scan all pseudo file plugins and check each */
+	for_all_plugins(REISER4_PSEUDO_PLUGIN_TYPE, plugin) {
+		pseudo_plugin *pplug;
+
+		pplug = &plugin->pseudo;
+		if (pplug->try != NULL && pplug->try(pplug, parent, name)) {
+			pseudo = add_pseudo(parent, pplug, dentry);
+			break;
+		}
+	}
+	if (!IS_ERR(pseudo))
+		result = 0;
+	else
+		result = PTR_ERR(pseudo);
+	return result;
+}
+
+#endif
+
+static int
+lookup_pars_var_lnode(struct reiser4_syscall_w_space * ws /* work space ptr */,
+		      pars_var_t * parent /* parent for w       */,
+		      wrd_t * w        /* to lookup for word */)
+{
+	//	struct dentry  * de, * de_rez;
+	int rez;
+	//	pars_var_t * rez_pars_var;
+	//	reiser4_key key,* k_rez;
+	//	coord_t coord;
+	//	lock_handle lh;
+	//	item_plugin *iplug;
+
+//		case EXPR_PARS_VAR:
+//			/* not yet */
+//			ws->nd.dentry=parent->ln->dentry.dentry;
+//			de_rez = link_path_walk( w->u.name, &(ws->nd) ); /* namei.c */
+//			break;
+
+	
+	return rez;
+
+}
+
+
+
+
+/* if_then_else procedure */
+static expr_v4_t *
+if_then_else(struct reiser4_syscall_w_space * ws /* work space ptr */,
+	     expr_v4_t * e1 /* expression of condition */,
+	     expr_v4_t * e2 /* expression of then */,
+	     expr_v4_t * e3 /* expression of else */ )
+{
+	return e1;
+}
+
+/* not yet */
+static expr_v4_t *
+if_then(struct reiser4_syscall_w_space * ws /* work space ptr */,
+	expr_v4_t * e1 /**/,
+	expr_v4_t * e2 /**/ )
+{
+	return e1;
+}
+
+/* not yet */
+static void
+goto_end(struct reiser4_syscall_w_space * ws /* work space ptr */)
+{
+}
+
+
+/* STRING_CONSTANT to expression */
+static expr_v4_t *
+const_to_expr(struct reiser4_syscall_w_space * ws /* work space ptr */,
+	      wrd_t * e1 /* constant for convert to expression */)
+{
+	expr_v4_t * new_expr = alloc_new_expr(ws, EXPR_WRD );
+	new_expr->wd.s = e1;
+	return new_expr;
+}
+
+/* allocate EXPR_OP2  */
+static expr_v4_t *
+allocate_expr_op2(struct reiser4_syscall_w_space * ws /* work space ptr */,
+		  expr_v4_t * e1 /* first expr */,
+		  expr_v4_t * e2 /* second expr */,
+		  int  op        /* expression code */)
+{
+	expr_v4_t * ret;
+	ret = alloc_new_expr( ws, EXPR_OP2 );
+	assert("VD alloc op2", ret!=NULL);
+	ret->h.exp_code = op;
+	ret->op2.op_l = e1;
+	ret->op2.op_r = e2;
+	return ret;
+}
+
+/* allocate EXPR_OP  */
+static expr_v4_t *
+allocate_expr_op(struct reiser4_syscall_w_space * ws /* work space ptr */,
+		 expr_v4_t * e1 /* first expr */,
+		 int  op        /* expression code */)
+{
+	expr_v4_t * ret;
+	ret = alloc_new_expr(ws, EXPR_OP );
+	assert("VD alloc op2", ret!=NULL);
+	ret->h.exp_code = op;
+	ret->op.op = e1;
+	return ret;
+}
+
+
+/* concatenate expressions */
+static expr_v4_t *
+concat_expression(struct reiser4_syscall_w_space * ws /* work space ptr */,
+		  expr_v4_t * e1 /* first expr of concating */,
+		  expr_v4_t * e2 /* second expr of concating */)
+{
+	return allocate_expr_op2( ws, e1, e2, CONCAT );
+}
+
+
+/* compare expressions */
+static expr_v4_t *
+compare_EQ_expression(struct reiser4_syscall_w_space * ws /* work space ptr */,
+		      expr_v4_t * e1 /* first expr of comparing */,
+		      expr_v4_t * e2 /* second expr of comparing */)
+{
+	return allocate_expr_op2( ws, e1, e2, COMPARE_EQ );
+}
+
+
+static expr_v4_t *
+compare_NE_expression(struct reiser4_syscall_w_space * ws /* work space ptr */,
+		      expr_v4_t * e1 /* first expr of comparing */,
+		      expr_v4_t * e2 /* second expr of comparing */)
+{
+	return allocate_expr_op2( ws, e1, e2, COMPARE_NE );
+}
+
+
+static expr_v4_t *
+compare_LE_expression(struct reiser4_syscall_w_space * ws /* work space ptr */,
+		      expr_v4_t * e1 /* first expr of comparing */,
+		      expr_v4_t * e2 /* second expr of comparing */)
+{
+	return allocate_expr_op2( ws, e1, e2, COMPARE_LE );
+}
+
+
+static expr_v4_t *
+compare_GE_expression(struct reiser4_syscall_w_space * ws /* work space ptr */,
+		      expr_v4_t * e1 /* first expr of comparing */,
+		      expr_v4_t * e2 /* second expr of comparing */)
+{
+	return allocate_expr_op2( ws, e1, e2, COMPARE_GE );
+}
+
+
+static expr_v4_t *
+compare_LT_expression(struct reiser4_syscall_w_space * ws /* work space ptr */,
+		      expr_v4_t * e1 /* first expr of comparing */,
+		      expr_v4_t * e2 /* second expr of comparing */)
+{
+	return allocate_expr_op2( ws, e1, e2, COMPARE_LT );
+}
+
+
+static expr_v4_t *
+compare_GT_expression(struct reiser4_syscall_w_space * ws /* work space ptr */,
+		      expr_v4_t * e1 /* first expr of comparing */,
+		      expr_v4_t * e2 /* second expr of comparing */)
+{
+	return allocate_expr_op2( ws, e1, e2, COMPARE_GT );
+}
+
+
+static expr_v4_t *
+compare_OR_expression(struct reiser4_syscall_w_space * ws /* work space ptr */,
+		      expr_v4_t * e1 /* first expr of comparing */,
+		      expr_v4_t * e2 /* second expr of comparing */)
+{
+	return allocate_expr_op2( ws, e1, e2, COMPARE_OR );
+}
+
+
+static expr_v4_t *
+compare_AND_expression(struct reiser4_syscall_w_space * ws /* work space ptr */,
+		       expr_v4_t * e1 /* first expr of comparing */,
+		       expr_v4_t * e2 /* second expr of comparing */)
+{
+	return allocate_expr_op2( ws, e1, e2, COMPARE_AND );
+}
+
+
+static expr_v4_t *
+not_expression(struct reiser4_syscall_w_space * ws /* work space ptr */,
+	       expr_v4_t * e1 /* first expr of comparing */)
+{
+	return allocate_expr_op( ws, e1, COMPARE_NOT );
+}
+
+
+/**/
+static expr_v4_t *
+check_exist(struct reiser4_syscall_w_space * ws /* work space ptr */,
+	    expr_v4_t * e1 /* first expr of comparing */)
+{
+	return e1;
+}
+
+/* union lists */
+static expr_v4_t *
+union_lists(struct reiser4_syscall_w_space * ws /* work space ptr */,
+	    expr_v4_t * e1 /* first expr of connecting */,
+	    expr_v4_t * e2 /* second expr of connecting */)
+{
+	expr_list_t *next, *last;
+	assert("VD-connect_list", e1->h.type == EXPR_LIST);
+
+	last = (expr_list_t *)e1;
+	next = e1->list.next;
+                   /* find last in list */
+	while ( next ) {
+		last = next;
+		next = next->next;
+	}
+	if ( e2->h.type == EXPR_LIST ) {                       /* connect 2 lists */
+		last->next = (expr_list_t *) e2;
+	}
+	else {                      /* add 2 EXPR to 1 list */
+		next = (expr_list_t *) alloc_new_expr(ws, EXPR_LIST );
+		assert("VD alloct list", next!=NULL);
+		next->next = NULL;
+		next->source = e2;
+		last->next = next;
+	}
+	return e1;
+}
+
+
+/*  make list from expressions */
+static expr_v4_t *
+list_expression(struct reiser4_syscall_w_space * ws /* work space ptr */,
+		expr_v4_t * e1 /* first expr of list */,
+		expr_v4_t * e2 /* second expr of list */)
+{
+	expr_v4_t * ret;
+
+	if ( e1->h.type == EXPR_LIST ) {
+		ret = union_lists( ws, e1, e2);
+	}
+	else {
+		
+		if ( e2->h.type == EXPR_LIST ) {
+			ret = union_lists( ws, e2, e1);
+		}
+		else {				
+			ret = alloc_new_expr(ws, EXPR_LIST );
+			assert("VD alloct list 1", ret!=NULL);
+			ret->list.source = e1;
+			ret->list.next = (expr_list_t *)alloc_new_expr(ws, EXPR_LIST );
+			assert("VD alloct list 2",ret->list.next!=NULL);
+			ret->list.next->next = NULL;
+			ret->list.next->source = e2;
+		}
+	}
+	return ret;
+}
+
+static expr_v4_t *
+list_async_expression(struct reiser4_syscall_w_space * ws,
+		      expr_v4_t * e1,
+		      expr_v4_t * e2 )
+{
+	return list_expression( ws, e1 , e2  );
+}
+
+/*not yet ready*/
+static expr_v4_t *
+unname( struct reiser4_syscall_w_space * ws,
+	expr_v4_t * e1 )
+{
+	return e1;
+}
+
+/*not yet ready*/
+static expr_v4_t *
+name( struct reiser4_syscall_w_space * ws,
+      expr_v4_t * e1 )
+{
+	return e1;
+}
+
+/*not yet ready*/
+static expr_v4_t *
+transcrash( struct reiser4_syscall_w_space * ws,
+	    expr_v4_t * e1 )
+{
+	return e1;
+}
+
+#define INIT_RNG(rn,ex,u_t,r_t,of,sz)\
+	(rn)->rng.host = (ex);\
+	(rn)->rng.units_type = (u_t);\
+	(rn)->rng.range_type = (r_t);\
+	(rn)->rng.offset= (of);\
+	(rn)->rng.size = (sz);
+
+
+
+
+
+
+
+
+static expr_v4_t *
+assign(struct reiser4_syscall_w_space * ws,
+       expr_v4_t * e1,
+       expr_v4_t * e2,
+       int mode )
+{
+	val_range_t * rng;
+	expr_v4_t * e;
+	int ret;
+
+	/* while for each pars_var in e1 */
+
+	switch(e1->h.type) {
+	case EXPR_WRD:    /*?????????????*/
+		break;
+	case EXPR_RANGE:
+		ret = pump( ws, e1, e2, mode );
+		break;
+	case EXPR_PARS_VAR:
+#if 0
+		e = alloc_new_expr(ws, EXPR_RANGE);
+		INIT_RNG(e, e1, UNITS_BYTE, RANGE_CUT, 0, -1);
+		ret = pump( ws, e, e2, mode );
+#endif
+		ret = pump( ws, e1->pars_var.v, e2, mode ); 
+		break;
+	case EXPR_LIST:
+#if 0
+		{    not yet ready.
+			make_var(tmp); /*1 create a tmp name, ???????*/
+			assign(ws, tmp, e2, mode); /*2 assign the e2 to tmp????*/
+			expr_v4_t * source;
+			expr_v4_t * last;
+			expr_v4_t * cur;
+			cur = e1;	
+			while( cur ) { /*3 loop for each expression in list*/
+				source = cur->source;
+				assign(ws, source, tmp, mode);
+				cur = cur->next;
+			}
+		}
+#endif
+		break;
+	case EXPR_ASSIGN:  /*??????????*/
+		break;
+	case EXPR_LNODE:   /*?????????*/
+		break;
+	case EXPR_FLOW:
+		break;
+	case EXPR_OP2:
+		/*
+
+		 */
+		break;
+	case EXPR_OP:
+		break;
+	}
+
+	return ret;
+}
+
+/* not yet */
+static expr_v4_t *
+assign_invert(struct reiser4_syscall_w_space * ws,
+	      expr_v4_t * e1,
+	      expr_v4_t * e2, int mode)
+{
+	return assign(ws, e1, e2, mode); /* not yet ready */
+}
+
+/* not yet */
+static expr_v4_t *
+symlink(struct reiser4_syscall_w_space * ws,
+	expr_v4_t * e1,
+	expr_v4_t * e2)
+{
+	return e2;
+}
+
+static rng_command_t *
+range_expression2command(struct reiser4_syscall_w_space * ws,
+			 int command,
+			 wrd_t * val)
+{
+	rng_command_t * rez;
+	rez = kmalloc(sizeof(rng_command_t), GFP_KERNEL);
+	rez->comm = command;
+	rez->value = atol(val->u.name);
+	return rez;
+}
+
+static rng_command_t *
+range_units_type(struct reiser4_syscall_w_space * ws,
+		 int command,
+		 int val)
+{
+	rng_command_t * rez;
+	rez = kmalloc(sizeof(rng_command_t), GFP_KERNEL);
+	rez->comm = command;
+	rez->value = val; 
+	return rez;
+}
+
+static expr_v4_t *
+add_range(struct reiser4_syscall_w_space * ws,
+	  expr_v4_t * rng,
+	  rng_command_t * command)
+{
+
+	switch (command->comm) {
+	case COMMAND_UNITS:
+		rng->rng.units_type = command->value;
+		break;
+	case COMMAND_TYPE:
+		rng->rng.range_type = command->value;
+		break;
+	case COMMAND_OFFSET:
+		rng->rng.offset = command->value;
+		break;
+	case COMMAND_LAST:
+		rng->rng.size = command->value - rng->rng.offset; /*??? if no offset or the last is before offset*/
+		break;
+	case COMMAND_FIRST:
+		rng->rng.offset = command->value;
+		break;
+	case COMMAND_LEN:
+		rng->rng.size = command->value;
+		break;
+	default:
+	}
+	kfree(command);
+	return rng;
+}
+
+static expr_v4_t *
+new_range(struct reiser4_syscall_w_space * ws,
+	  rng_command_t * command)
+{
+	expr_v4_t * rez;
+	rez         = alloc_new_expr( ws, EXPR_RANGE );
+	add_range(ws, rez, command);
+	return rez;
+}
+
+static inline expr_v4_t *
+range2expr(struct reiser4_syscall_w_space * ws,
+	   expr_v4_t * host,
+	   expr_v4_t * val)
+{
+	val->rng.host = host;
+	return val;
+}
+
+/*
+ A flow is a source from which data can be obtained. A Flow can be one of these types:
+
+   1. memory area in user space. (char *area, size_t length)
+   2. memory area in kernel space. (caddr_t *area, size_t length)
+   3. file-system object (lnode *obj, loff_t offset, size_t length)
+*/
+#if 0
+typedef struct connect connect_t;
+struct connect
+{
+	expr_v4_t * (*u)(pars_var_t *dst, expr_v4_t *src);
+};
+
+static expr_v4_t *
+reiser4_assign( pars_var_t *dst,
+		expr_v4_t *src )
+{
+    int           ret_code;
+    file_plugin  *src_fplug;
+    file_plugin  *dst_fplug;
+    connect_t     connection;
+
+    /*
+     * select how to transfer data from @src to @dst.
+     *
+     * Default implementation of this is common_transfer() (see below).
+     *
+     * Smart file plugin can choose connection based on type of @dst.
+     *
+     */
+    connection.u=common_transfer;
+    connection = dst->v->fplug -> select_connection( src, dst );
+
+    /* do transfer */
+    return common_transfer( &dst, &src );
+}
+#endif
+
+
+static  int
+source_not_empty(expr_v4_t *source)
+{
+	return 0;
+}
+
+static mm_segment_t __ski_old_fs;	
+
+
+#define START_KERNEL_IO_GLOB	                \
+		__ski_old_fs = get_fs();	\
+		set_fs( KERNEL_DS )
+
+#define END_KERNEL_IO_GLOB			\
+		set_fs( __ski_old_fs );		
+
+#define PUMP_BUF_SIZE (PAGE_CACHE_SIZE)
+
+
+static int
+push_tube_stack( tube_t * tube,
+		 long type,
+		 void * pointer )
+{
+	sourece_stack_t * ret;
+	ret = kmalloc( sizeof(struct sourece_stack), GFP_KERNEL );
+	if (!IS_ERR(ret)) {
+		ret->prev        = tube->st_current;
+		ret->type        = type;
+		ret->u.pointer   = pointer;
+		tube->st_current = ret;
+		return 0;
+	}
+	else {
+		return PTR_ERR(ret);
+	}
+}
+
+static int
+push_tube_list_stack_done(tube_t * tube)
+{
+	tube->next->prev = tube->st_current;
+	tube->st_current = tube->last;
+	tube->last       = NULL;
+	tube->next       = NULL;
+	return 0;
+}
+
+
+static int
+push_tube_list_stack_init( tube_t * tube,
+			   long type,
+			   void * pointer )
+{
+	//	sourece_stack_t * ret;
+	tube->last = kmalloc( sizeof(struct sourece_stack), GFP_KERNEL );
+	if (!IS_ERR(tube->last)) {
+		tube->next            = tube->last;
+		tube->last->type      = type;
+		tube->last->u.pointer = pointer;
+		return 0;
+	}
+	else {
+		return PTR_ERR(tube->last);
+	}
+}
+
+static int
+push_tube_list_stack(tube_t * tube,
+		     long type,
+		     void * pointer )
+{
+	sourece_stack_t * ret;
+	ret = kmalloc( sizeof(struct sourece_stack), GFP_KERNEL );
+	if (!IS_ERR(ret)) {
+		tube->next->prev = ret;
+		ret->type        = type;
+		ret->u.pointer   = pointer;
+		tube->next       = ret;
+		return 0;
+	}
+	else {
+		return PTR_ERR(ret);
+	}
+}
+
+static int
+change_tube_stack(tube_t * tube,
+		  long type,
+		  void * pointer )
+{
+	tube->st_current->type       = type;
+	tube->st_current->u.pointer  = pointer;
+	return 0;
+}
+
+static int
+pop_tube_stack( tube_t * tube )
+{
+	sourece_stack_t * ret;
+	if ( tube->st_current == NULL ) {
+		return -1;
+	}
+	else {
+		ret              = tube->st_current;
+		tube->st_current = tube->st_current->prev;
+		kfree( ret );
+		return 0;
+	}
+}
+
+static int
+push_var_val_stack(struct reiser4_syscall_w_space *ws /* work space ptr */,
+		   struct pars_var * var,
+		   long type)
+{
+	pars_var_value_t * ret;
+	ret = kmalloc( sizeof(pars_var_value_t), GFP_KERNEL );
+	if (!IS_ERR(ret)) {
+		memset( ret , 0, sizeof( pars_var_value_t ));
+		ret->prev       = var->val;
+		ret->vtype      = type;
+		ret->host       = var;
+		ret->count      = 1;
+		ret->next_level = ws->cur_level->val_level;
+		ws->cur_level->val_level = ret;
+		var->val        = ret;
+		return 0;
+	}
+	else {
+		return PTR_ERR(ret);
+	}
+}
+
+static void
+free_val(struct reiser4_syscall_w_space *ws /* work space ptr */,
+	 pars_var_value_t * val /* value for free */)
+{
+	val->host->val           = val->prev;
+	ws->cur_level->val_level = val->next_level;
+	kfree( val );
+}
+
+
+
+static int
+pop_var_val_stack( struct reiser4_syscall_w_space *ws /* work space ptr */,
+		   pars_var_value_t * val, /* value for free */
+		   int tmp_only /* free only if tmp value */)
+{
+	//	pars_var_value_t * ret;
+	if ( val == NULL ) {
+		return -1;
+	}
+	else {
+		if (val->destruct!=NULL) {
+			val->destruct(ws, val);
+		}
+		switch(val->vtype) {
+		case VAR_EMPTY:
+			break;
+		case VAR_LNODE:
+			if ( !tmp_only )
+				{
+					assert("VD-pop_var_val_stack.VAR_LNODE", val->u.ln!=NULL);
+//		if ( !--var->val->count )
+					{
+						path4_release( &(val->u.ln->l_dentry) );
+						lput( val->u.ln );
+					}
+					free_val(ws, val);
+				}
+			break;
+		case VAR_TMP:
+			if (val->u.data!=NULL) {
+				kfree( val->u.data );
+			}
+			free_val(ws, val);
+			break;
+		}
+		return 0;
+	}
+}
+
+
+/*  pop onto stack for calculate expressions one step */
+static void
+put_tube_src(tube_t * tube)
+{
+	/*  close readed file and pop stack */
+	switch (tube->st_current->type) {
+	case 	ST_FILE:
+		filp_close(tube->st_current->u.file, current->files );
+	case 	ST_DE:
+	case 	ST_WD:
+	case 	ST_DATA:
+		pop_tube_stack(tube);
+		break;
+	}
+}
+
+
+/* push & pop onto stack for calculate expressions one step */
+static int
+get_tube_next_src_var_lnode(tube_t * tube)
+{
+	lnode *ln;
+	int ret;
+	ln = tube->st_current->u.expr->pars_var.v->val->u.ln;
+	assert("VD-free_expr.EXPR_PARS_VAR.ln", ln!=NULL);
+	switch(ln->h.type)
+		{
+		case LNODE_DENTRY:
+			{
+				struct dentry * de;
+				struct file * fl;
+				de = ln->l_dentry.dentry;
+				if ( S_ISREG(de->d_inode->i_mode) ) {
+					fl=  dentry_open( de,ln->l_dentry.mnt, O_RDONLY ) ;
+					if ( !IS_ERR(fl) ) {
+						change_tube_stack( tube, ST_FILE, fl);
+						ret =0;
+					}
+					else {
+						printk("error for open source\n");
+						ret = -1;
+					}
+				}
+#if 0         // not yet ready
+				else if ( S_ISDIR(de->d_inode->i_mode) ) {
+					while(!EOF readdir) {
+						fl=  dentry_open( readdir_back_order(de), ln->l_dentry.mnt, O_RDONLY ) ;
+						if ( !IS_ERR(fl) ) {
+							push_tube_stack( tube, ST_FILE, fl);
+							ret = 0 ;
+						}
+						else {
+							printk("error for open source\n");
+							ret = -1;
+						}
+					}
+				}
+#endif
+			}
+			break;
+		case LNODE_INODE: /* newer use it */
+			ret = -1;
+			break;
+		case LNODE_REISER4_INODE: /* */
+			ret = -1;
+			break;
+		case LNODE_LW:            /* for reiser4 partition */
+			ret = -1;
+			break;
+		case LNODE_COORD:
+			ret = -1;
+			break;
+		case LNODE_PSEUDO:
+			ret = -1;
+			break;
+		}
+	return ret;
+}
+
+/* push & pop onto stack for calculate expressions one step */
+static int
+get_tube_next_src(tube_t * tube)
+{
+	expr_v4_t * s;
+	expr_list_t * tmp;
+	int ret;
+
+	tube->readoff=0;
+	assert ("VD stack is empty", tube->st_current != NULL );
+
+	/* check stack and change its head */
+	switch (tube->st_current->type) {
+	case 	ST_FILE:
+	case 	ST_DE:
+	case 	ST_WD:
+		ret = 0;
+		break;
+	case 	ST_EXPR:
+		s = tube->st_current->u.expr;
+		switch (s->h.type) {
+		case EXPR_WRD:
+			change_tube_stack( tube, ST_WD , s->wd.s );
+			break;
+		case EXPR_RANGE:
+			/*
+make new assign with rng->size  as the lhs
+
+	alloc the area with val->size and with tmpname,
+		assign the host to allocated tmpname with val-offset,val-size parameters,
+		set the type of result for EXPR_FLOW or ???, return it.
+
+			*/
+
+
+
+			break;
+		case EXPR_PARS_VAR:
+			assert("VD-s->pars_var.v.EXPR_PARS_VAR", s->pars_var.v!=NULL);
+			assert("VD-s->pars_var.v->val.EXPR_PARS_VAR", s->pars_var.v->val!=NULL);
+			switch( s->pars_var.v->val->vtype) {
+			case VAR_EMPTY:
+				break;
+			case VAR_LNODE:
+				get_tube_next_src_var_lnode(tube);
+				ret = 0;
+				break;
+			case VAR_TMP:
+				if ( s->pars_var.v->val->u.data == NULL ) {
+					pop_tube_stack( tube );
+					ret = 1;
+				}
+				else {
+					change_tube_stack( tube, ST_DATA , s->pars_var.v->val->u.data);
+					ret = 0;
+				}
+				break;
+			}
+			break;
+		case EXPR_LIST:
+			tmp = &s->list;
+			push_tube_list_stack_init( tube, ST_EXPR , tmp->source );
+			while (tmp) {
+				tmp = tmp->next;
+				push_tube_list_stack( tube, ST_EXPR, tmp->source );
+			}
+			pop_tube_stack( tube );
+			push_tube_list_stack_done( tube );
+			ret = 1;
+			break;
+		case EXPR_ASSIGN:
+#if 0   // not yet
+			assert("VD-free_expr.EXPR_ASSIGN", s->assgn.target!=NULL);
+			assert("VD-free_expr.EXPR_ASSIGN.ln", s->assgn.target->ln!=NULL);
+			assert("VD-free_expr.EXPR_ASSIGN.count", s->assgn.target->val->count>0);
+			( s->assgn.target->ln);
+			( s->assgn.source );
+#endif
+			break;
+		case EXPR_LNODE:
+			assert("VD-free_expr.lnode.lnode", s->lnode.lnode!=NULL);
+//					if ( S_ISREG(s->lnode.lnode->dentry.dentry->d_inode) )
+			{
+				change_tube_stack( tube, ST_FILE ,
+						   dentry_open( s->lnode.lnode->l_dentry.dentry,
+								s->lnode.lnode->l_dentry.mnt, O_RDONLY ) );
+			}
+			ret = 0;
+			break;
+		case EXPR_FLOW:
+			break;
+#if 0
+		case EXPR_OP2:
+			change_tube_stack( tube, ST_EXPR , s->op2.op_r );
+			push_tube_stack( tube, ST_EXPR , s->op2.op_l );
+			push_tube_stack( tube, COMMAND, s->h.exp_code); ??????????
+			ret = 1;
+			break;
+		case EXPR_OP:
+			change_tube_stack( tube, ST_EXPR , s->op.op );
+			push_tube_stack( tube, COMMAND, s->h.exp_code ); ??????????
+			ret = 1;
+			break;
+#endif
+		}
+		break;
+	}
+	return ret;
+}
+
+
+static size_t
+target_rng_doing(tube_t * tube)
+{
+	if (tube->target_rng == NULL) {
+		tube->writeoff = 0;
+	}
+	else {
+
+	}
+}
+
+
+static tube_t *
+get_tube_general(tube_t * tube,
+		 expr_v4_t *sink,
+//		 pars_var_t *sink,
+		 expr_v4_t *source,
+		 int mode)
+{
+	expr_v4_t *cur,
+
+	//	char * buf;
+	tube = kmalloc( sizeof(struct tube), GFP_KERNEL);
+	if (!IS_ERR(tube)) {
+		START_KERNEL_IO_GLOB;
+		memset( tube , 0, sizeof( struct tube ));
+		assert("VD get_tube_general: no tube",!IS_ERR(tube));
+		cur = sink;
+
+		while (cur->h.type == EXPR_RANGE) {
+			tube->target_rng = reverse_rng(tube->target_rng, cur);
+			cur = cur->host;
+		}
+
+
+		assert(cur->h.type == EXPR_PARS_VAR);
+
+		tube->target = cur;
+
+		switch( cur->val->vtype ) {
+		case VAR_EMPTY:
+			break;
+		case VAR_LNODE:
+			assert("VD get_tube_general: dst no dentry",
+			       cur->val->u.ln->h.type== LNODE_DENTRY);
+			tube->dst = dentry_open( cur->val->u.ln->l_dentry.dentry,
+						 cur->val->u.ln->l_dentry.mnt,
+						 O_WRONLY|mode );
+			break;
+		case VAR_TMP:
+			break;
+		}
+		tube->writeoff = target_rng_doing(tube);
+		tube->st_current  = NULL;
+		push_tube_stack( tube, ST_EXPR, (long *)source );
+	}
+	return tube;
+}
+
+static size_t
+reserv_space_in_sink(tube_t * tube )
+{
+	tube->buf = kmalloc( PUMP_BUF_SIZE, GFP_KERNEL);
+	if (!IS_ERR(tube->buf)) {
+		memset( tube->buf  , 0, PUMP_BUF_SIZE);
+		return PUMP_BUF_SIZE;
+	}
+	else {
+		return 0;
+	}
+}
+
+static size_t
+get_available_src_len(tube_t * tube)
+{
+	size_t len;
+	size_t s_len;
+	int ret = 1;
+	len = PUMP_BUF_SIZE;
+	while ( tube->st_current != NULL && ret ) {
+		ret = 0;
+		switch( tube->st_current->type ) {
+		case 	ST_FILE:
+			s_len = tube->st_current->u.file->f_dentry->d_inode->i_size;
+			/* for reiser4 find_file_size() */
+			break;
+		case 	ST_DE:
+			break;
+		case 	ST_WD:
+			s_len = tube->st_current->u.wd->u.len;
+			break;
+		case 	ST_EXPR:
+			while( tube->st_current != NULL && get_tube_next_src( tube ) ) ;
+			len = -1;
+			ret = 1;
+			break;
+		case ST_DATA:
+			s_len = tube->st_current->u.qstr->len;
+//			s_len = strlen((char *)tube->st_current->u.pointer);
+			break;
+			}
+	}
+	s_len -= tube->readoff;
+	if (tube->st_current == NULL) {
+		len = 0;
+	}
+	else {
+		if ( len > s_len ) len = s_len;
+	}
+	return len;
+}
+
+static size_t
+prep_tube_general(tube_t * tube)
+{
+	size_t ret;
+	if ( tube->st_current != NULL ) {
+		ret = get_available_src_len( tube ) ;
+	}
+	else {
+		ret = 0;
+	}
+	tube->len = ret;
+	return ret;
+}
+
+
+
+static size_t
+source_to_tube_general(tube_t * tube)
+{
+	//	tube->source->fplug->read(tube->offset,tube->len);
+	size_t ret;
+	switch( tube->st_current->type ) {
+	case 	ST_FILE:
+		ret = vfs_read(tube->st_current->u.file, tube->buf, tube->len, &tube->readoff);
+		tube->len = ret;
+		break;
+	case 	ST_DE:
+		break;
+	case 	ST_WD:
+		if ( tube->readoff < tube->st_current->u.wd->u.len ) {
+			assert ("VD source to tube(wd)", tube->readoff+tube->len <= tube->st_current->u.wd->u.len);
+			memcpy( tube->buf,  tube->st_current->u.wd->u.name + tube->readoff, ret = tube->len );
+			tube->readoff += ret;
+		}
+		else ret = 0;
+		break;
+	case ST_DATA:
+		if ( tube->readoff < tube->st_current->u.qstr->len ) {
+			memcpy( tube->buf,  tube->st_current->u.qstr->name + tube->readoff, ret = tube->len );
+			tube->readoff += ret;
+		}
+		else ret = 0;
+		break;
+	}
+	return ret;
+}
+
+static size_t
+tube_to_sink_general(tube_t * tube)
+{
+	size_t ret;
+//	tube->sink->fplug->write(tube->offset,tube->len);
+//	tube->offset += tube->len;
+	switch(tube->target->val->vtype) {
+	case VAR_EMPTY:
+		break;
+	case VAR_LNODE:
+		ret = vfs_write(tube->dst, tube->buf, tube->len, &tube->writeoff);
+		break;
+	case VAR_TMP:
+		if (tube->target->val->u.data == NULL) {
+			tube->target->val->u.data = kmalloc(sizeof(struct qstr) + tube->len, GFP_KERNEL);
+			tube->target->val->u.data->len = tube->len;
+			tube->target->val->u.data->name = (char *)tube->target->val->u.data + sizeof(struct qstr);
+			tube->writeoff = 0;
+		}
+		else {
+			struct qstr * old_data;
+			old_data = tube->target->val->u.data;
+			tube->target->val->u.data = kmalloc(tube->len + old_data->len + sizeof(struct qstr), GFP_KERNEL);
+			tube->target->val->u.data->name = (char *)tube->target->val->u.data + sizeof(struct qstr);
+			memmove(tube->target->val->u.data->name, old_data->name, old_data->len);
+			kfree(old_data);
+		}
+		memmove(tube->target->val->u.data->name + tube->writeoff, tube->buf, tube->len);
+		tube->writeoff += tube->len;
+		break;
+	}
+	return ret;
+
+}
+
+static void
+put_tube(tube_t * tube)
+{
+	END_KERNEL_IO_GLOB;
+	assert("VD :stack not empty ",tube->st_current == NULL);
+	switch(tube->target->val->vtype) {
+	case VAR_EMPTY:
+		break;
+	case VAR_LNODE:
+		do_truncate( tube->dst->f_dentry, tube->writeoff);
+		filp_close(tube->dst, current->files );
+		break;
+	case VAR_TMP:
+		break;
+	}
+	kfree(tube->buf);
+	kfree(tube);
+}
+
+static int
+create_result_field(struct reiser4_syscall_w_space * ws,
+		    pars_var_t *parent,   /* parent for name */
+		    char * name ,         /* created name    */
+		    int result_len,       /* length of allocated space for value */
+		    int result)
+{
+	int ret;
+	wrd_t * tmp_wrd;
+	pars_var_t * rezult;
+
+	tmp_wrd = make_new_word(ws, name );
+	rezult =  lookup_pars_var_word( ws , parent, tmp_wrd, VAR_TMP);
+	if ( rezult != NULL ) {
+		rezult->val->u.data  = kmalloc(sizeof(struct qstr) + result_len, GFP_KERNEL ) ;
+		rezult->val->u.data->len = result_len;
+		rezult->val->u.data->name = (char *)rezult->val->u.data + sizeof(struct qstr);
+		if ( rezult->val->u.data->name ) {
+			sprintf( rezult->val->u.data->name, "%d", result );
+			ret=0;
+		}
+	}
+	else {
+		ret = 1;
+	}
+	return ret;
+}
+
+static int
+create_result(struct reiser4_syscall_w_space * ws,
+	      pars_var_t *parent,   /* parent for name       */
+	      int err_code ,        /* error code of assign  */
+	      int length)           /* length of assign      */
+{
+	int ret;
+	ret  = create_result_field( ws, parent,
+			     ASSIGN_RESULT, SIZEFOR_ASSIGN_RESULT, err_code );
+	ret += create_result_field( ws, parent,
+			     ASSIGN_LENGTH, SIZEFOR_ASSIGN_LENGTH, length );
+	return ret;
+}
+
+
+
+/*
+  Often connection() will be a method that employs memcpy(). Sometimes
+  copying data from one file plugin to another will mean transforming
+  the data. What reiser4_assign does depends on the type of the flow
+  and sink. If @flow is based on the kernel-space area, memmove() is
+  used to copy data. If @flow is based on the user-space area,
+  copy_from_user() is used. If @flow is based on a file-system object,
+  flow_place() uses the page cache as a universal translator, loads
+  the object's data into the page cache, and then copies them into
+  @area. Someday methods will be written to copy objects more
+  efficiently than using the page cache (e.g. consider copying holes
+  [add link to definition of a hole]), but this will not be
+  implemented in V4.0.
+*/
+static expr_v4_t *
+pump(struct reiser4_syscall_w_space * ws,
+     expr_v4_t *sink,
+//     pars_var_t *sink,
+     expr_v4_t *source,
+     int mode )
+{
+	//	pars_var_t * assoc;
+	expr_v4_t * ret;
+	tube_t * tube;
+	int ret_code;
+	size_t (*prep_tube)(tube_t *);
+	size_t (*source_to_tube)(tube_t *);
+	size_t (*tube_to_sink)(tube_t *);
+
+	/* remember to write code for freeing tube, error handling, etc. */
+#if 0
+	ret_code = sink->fplug -> get_tube( tube, sink, source);
+	prep_tube = sink->fplug->prep_tube (tube);
+	source_to_tube = source->fplug->source_to_tube;
+	tube_to_sink = sink->fplug->tube_to_sink;
+#else
+	tube       = get_tube_general( tube, sink, source, mode);
+	if ( tube == NULL ) {
+		ret_code = -1;
+	}
+	else {
+		prep_tube      = prep_tube_general;
+		source_to_tube = source_to_tube_general;
+		tube_to_sink   = tube_to_sink_general;
+#endif
+		reserv_space_in_sink( tube );
+
+		while ( tube->st_current != NULL ) {
+			ret_code = prep_tube( tube );
+			while ( ( ret_code > 0 ) &&
+				( ret_code = source_to_tube( tube ) > 0 ) ) {
+				ret_code = tube_to_sink( tube )  ;
+			}
+			if ( ret_code < 0 ) {
+				printk("IO error\n");
+			}
+			put_tube_src( tube );
+
+
+		}
+
+
+		ret=alloc_new_expr( ws, EXPR_PARS_VAR );
+		ret->pars_var.v = sink;
+
+		if ( sink->val->associated == NULL) {
+			create_result( ws, sink, ret_code, tube->writeoff );
+			//			ret->pars_var.v = sink;
+		}
+		else {
+			create_result( ws, sink->val->associated, ret_code, tube->writeoff );
+			//			ret->pars_var.v = sink->val->associated;
+			sink->val->associated = NULL;
+		}
+		put_tube( tube );
+      }
+      return ret;
+}
+
+
+
+
+/* Make Linus happy.
+   Local variables:
+   c-indentation-style: "K&R"
+   mode-name: "LC"
+   c-basic-offset: 8
+   tab-width: 8
+   fill-column: 120
+   End:
+*/
diff -puN /dev/null parser/lib.h
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/lib.h	2005-06-29 19:59:06.000000000 +0400
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2001, 2002 by Hans Reiser, licensing governed by reiser4/README
+ */
+
+/*
+ * functions for parser.y
+ */
+
+
+
+
+
+void print_pwd_count(char *);
+#if defined(CONFIG_REISER4_FS_SYSCALL_BISON)
+static void yyerror(char * );
+#else
+static void yyerror( struct reiser4_syscall_w_space *ws, int msgnum , ...);
+#endif
+static expr_v4_t * const_to_expr(struct reiser4_syscall_w_space *, wrd_t *);
+static expr_v4_t * unname( struct reiser4_syscall_w_space *, expr_v4_t *);
+static expr_v4_t * concat_expression(struct reiser4_syscall_w_space *, expr_v4_t *, expr_v4_t *);
+static int yywrap(void);
+static free_space_t * free_space_alloc(void);
+static void freeList(free_space_t * list);
+static int reiser4_pars_free(struct reiser4_syscall_w_space * ws);
+//static free_space_t * freeSpaceAlloc(void);
+static free_space_t * freeSpaceNextAlloc(struct reiser4_syscall_w_space * ws);
+static char* list_alloc(struct reiser4_syscall_w_space * ws, int size);
+static streg_t *alloc_new_level(struct reiser4_syscall_w_space * ws);
+static pars_var_t * alloc_pars_var(struct reiser4_syscall_w_space * ws, pars_var_t * last_pars_var);
+static int free_expr( struct reiser4_syscall_w_space * ws, expr_v4_t * expr);
+static lnode * get_lnode(struct reiser4_syscall_w_space * ws);
+static struct reiser4_syscall_w_space * reiser4_pars_init(void);
+static void level_up(struct reiser4_syscall_w_space *ws, long type);
+static  void  level_down(struct reiser4_syscall_w_space * ws, long type1, long type2);
+static void move_selected_word(struct reiser4_syscall_w_space * ws, int exclude, int press );
+static int b_check_word(struct reiser4_syscall_w_space * ws );
+static __inline__ wrd_t * _wrd_inittab(struct reiser4_syscall_w_space * ws );
+static int reiser4_lex(YYSTYPE *, YYLTYPE * , struct reiser4_syscall_w_space * ws );
+static expr_v4_t * alloc_new_expr(struct reiser4_syscall_w_space * ws, int type);
+wrd_t * nullname(struct reiser4_syscall_w_space * ws);
+static expr_v4_t *  init_root(struct reiser4_syscall_w_space * ws,pars_var_t * parent, char * name);
+//static expr_v4_t *  init_pwd(struct reiser4_syscall_w_space * ws);
+static expr_v4_t *  pars_expr(struct reiser4_syscall_w_space * ws, expr_v4_t * e1, expr_v4_t * e2);
+static expr_v4_t *  lookup_word(struct reiser4_syscall_w_space * ws, wrd_t * w);
+static inline expr_v4_t * pars_lookup_curr(struct reiser4_syscall_w_space * ws);
+static inline expr_v4_t * pars_lookup_root(struct reiser4_syscall_w_space * ws);
+static pars_var_t *  lookup_pars_var_word(struct reiser4_syscall_w_space * ws, pars_var_t * pars_var, wrd_t * w, int type);
+//static expr_v4_t * make_do_it(struct reiser4_syscall_w_space * ws, expr_v4_t * e1 );
+static expr_v4_t * if_then_else(struct reiser4_syscall_w_space * ws, expr_v4_t * e1, expr_v4_t * e2 , expr_v4_t * e3  );
+static expr_v4_t * if_then(struct reiser4_syscall_w_space * ws, expr_v4_t * e1, expr_v4_t * e2 );
+static void goto_end(struct reiser4_syscall_w_space * ws);
+//static expr_v4_t * constToExpr(struct reiser4_syscall_w_space * ws, wrd_t * e1 );
+//static expr_v4_t * connect_expression(struct reiser4_syscall_w_space * ws, expr_v4_t * e1, expr_v4_t * e2);
+static expr_v4_t * compare_EQ_expression(struct reiser4_syscall_w_space * ws, expr_v4_t * e1, expr_v4_t * e2);
+static expr_v4_t * compare_NE_expression(struct reiser4_syscall_w_space * ws, expr_v4_t * e1, expr_v4_t * e2);
+static expr_v4_t * compare_LE_expression(struct reiser4_syscall_w_space * ws, expr_v4_t * e1, expr_v4_t * e2);
+static expr_v4_t * compare_GE_expression(struct reiser4_syscall_w_space * ws, expr_v4_t * e1, expr_v4_t * e2);
+static expr_v4_t * compare_LT_expression(struct reiser4_syscall_w_space * ws, expr_v4_t * e1, expr_v4_t * e2);
+static expr_v4_t * compare_GT_expression(struct reiser4_syscall_w_space * ws, expr_v4_t * e1, expr_v4_t * e2);
+static expr_v4_t * compare_OR_expression(struct reiser4_syscall_w_space * ws, expr_v4_t * e1, expr_v4_t * e2);
+static expr_v4_t * compare_AND_expression(struct reiser4_syscall_w_space * ws, expr_v4_t * e1, expr_v4_t * e2);
+static expr_v4_t * not_expression(struct reiser4_syscall_w_space * ws, expr_v4_t * e1);
+static expr_v4_t * check_exist(struct reiser4_syscall_w_space * ws, expr_v4_t * e1);
+static expr_v4_t * list_expression(struct reiser4_syscall_w_space * ws, expr_v4_t * e1, expr_v4_t * e2 );
+static expr_v4_t * list_async_expression(struct reiser4_syscall_w_space * ws, expr_v4_t * e1, expr_v4_t * e2 );
+static expr_v4_t * assign(struct reiser4_syscall_w_space * ws, expr_v4_t * e1, expr_v4_t * e2, int mode);
+static expr_v4_t * assign_invert(struct reiser4_syscall_w_space * ws, expr_v4_t * e1, expr_v4_t * e2, int mode);
+static expr_v4_t * symlink(struct reiser4_syscall_w_space * ws, expr_v4_t * e1, expr_v4_t * e2);
+static  int source_not_empty(expr_v4_t *source);
+static tube_t * get_tube_general(tube_t * tube, expr_v4_t *sink, expr_v4_t *source, int mode);
+static size_t reserv_space_in_sink(tube_t * tube);
+//static size_t get_available_len(tube_t * tube);
+static size_t prep_tube_general(tube_t * tube);
+static size_t source_to_tube_general(tube_t * tube);
+static size_t tube_to_sink_general(tube_t * tube);
+static void put_tube(tube_t * tube);
+static expr_v4_t *  pump(struct reiser4_syscall_w_space * ws, expr_v4_t *sink, expr_v4_t *source, int mode );
+
+static int pop_var_val_stack( struct reiser4_syscall_w_space *ws /* work space ptr */,
+			      pars_var_value_t * val, int tmp_only );
+static int push_var_val_stack(struct reiser4_syscall_w_space *ws /* work space ptr */,
+			      struct pars_var * var,
+			      long type );
+static expr_v4_t *target_name( expr_v4_t *assoc_name, expr_v4_t *target );
+
+#define curr_symbol(ws) ((ws)->ws_pline)
+#define next_symbol(ws)  (++curr_symbol(ws))
+#define tolower(a) a
+#define isdigit(a) ((a)>=0 && (a)<=9)
+
diff -puN /dev/null parser/Makefile
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/Makefile	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,27 @@
+#    CONFIG_REISER4_FS_SYSCALL_BISON
+
+obj-$(CONFIG_REISER4_FS_SYSCALL) += sys_reiser4.o
+
+#sys_reiser4-y := sys_reiser4.o
+
+YFLAGS= -S yacc_reiser4.c  -r all  -b $(obj)/parser
+#YFLAGS= -S yacc.c -d -r all -b $(obj)/parser
+#YFLAGS= -y -d -r all -b $(obj)/parser
+
+YACC= bison
+
+$(obj)/sys_reiser4.o: $(obj)/parser.tab.c
+
+$(obj)/parser.tab.c: $(src)/parser.y
+	(BISON_PKGDATADIR=$(obj)/bison-1.875 ;\
+	export BISON_PKGDATADIR ;\
+	$(YACC) $(YFLAGS) $(src)/parser.y )
+
+
+
+
+
+
+
+
+
diff -puN /dev/null parser/pars.cls.h
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/pars.cls.h	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,242 @@
+/*
+ * Copyright 2001, 2002 by Hans Reiser, licensing governed by reiser4/README
+ */
+
+/*
+ * definitions of common constants for lex component of parser.y
+ */
+
+
+
+#define ERR  -128
+
+
+typedef enum {
+    OK   ,
+    Blk  ,   /* blank */
+    Wrd  ,   /* any symbol exept spec symbl */
+    Int  ,   /* numeric */
+
+    Ptr  ,   /* pointer */
+
+    Pru  ,   /* _pruner */
+
+    W_b  ,   /* ` string begin */
+    W_e  ,   /* ' string end */
+    Lpr  ,   /* ( */
+    Rpr  ,   /* ) */
+    Com  ,   /* , */
+    Mns  ,   /* - */
+
+
+    Les  ,   /* < */
+    Slh  ,   /* / */
+
+    Lsq  ,   /* [ */
+    Rsq  ,   /* ] */
+
+    Bsl  ,   /* \ */
+
+    Lfl  ,   /* { */
+    Rfl  ,   /* } */
+
+    Pip  ,   /* | */
+    Sp1  ,   /* : */
+    Sp2  ,   /* ; */
+
+    Dot  ,   /* . */
+
+    Sp4  ,   /* = */
+    Sp5  ,   /* > */
+    Sp6  ,   /* ? */
+    Pls  ,   /* +  ???*/
+    Res  ,   /*  */
+
+    Str  ,   /* " */
+    Ste  , 
+    ASG  ,
+    App  ,
+    Lnk  ,
+    Ap2  ,
+    Nam  ,
+    LastState
+} state;
+
+#define STRING_CONSTANT_EMPTY STRING_CONSTANT   /* tmp */
+
+static char   ncl     [256] = {
+	Blk,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,
+	ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,
+	ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,
+	ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,
+	/* 32*/
+      /*        !     "    #     $     %     &     ' */
+	Blk,  Res,  Str,  Res,  Res,  Res,  Res,  W_e,
+      /* (      )     *    +     ,     -     .     / */
+        Lpr,  Rpr,  Res,  Pls,  Com,  Mns,  Dot,  Slh,
+      /* 0      1     2    3     4     5     6     7 */
+	Int,  Int,  Int,  Int,  Int,  Int,  Int,  Int,
+      /* 8      9     :    ;     <     =     >     ? */
+	Int,  Int,  Sp1,  Sp2,  Les,  Sp4,  Sp5,  Sp6,
+
+	/* 64*/
+      /* @      A     B    C     D     E     F     G */
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+      /* H      I     J    K     L     M     N     O */
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+      /* P      Q     R    S     T     U     V     W */
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+      /* X      Y     Z    [     \     ]     ^     _ */
+	Wrd,  Wrd,  Wrd,  Lsq,  Bsl,  Rsq,  Res,  Pru,
+	/* 96*/
+      /* `      a     b    c     d     e     f     g */
+        W_b,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+      /* h      i     j    k     l     m     n     o */
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+      /* p      q     r    s     t     u     v     w */
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+      /* x      y     z    {     |     }     ~       */
+	Wrd,  Wrd,  Wrd,  Lfl,  Pip,  Rfl,  Wrd,  ERR,
+
+	/*128*/
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+	/*160*/
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+	/*192*/
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+	/*224*/
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,
+	Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  Wrd,  ERR
+};
+
+struct lexcls {
+  int term;
+  char c[32];
+} ;
+
+static struct {
+	char    *       wrd;
+	int             class;
+}
+pars_key [] = {
+  { "and"         ,    AND            },
+  { "else"        ,    ELSE           },
+  { "eq"          ,    EQ             },
+  { "ge"          ,    GE             },
+  { "gt"          ,    GT             },
+  { "if"          ,    IF             },
+  { "le"          ,    LE             },
+  { "lt"          ,    LT             },
+  { "ne"          ,    NE             },
+  { "not"         ,    NOT            },
+  { "or"          ,    OR             },
+  { "then"        ,    THEN           },
+  { "tw/"         ,    TRANSCRASH     }
+};
+
+
+struct lexcls lexcls[] = {
+/*
+..   a   1       _   `   '     (   )   ,   -   <   /   [   ]     \   {   }   |   ;   :   .   =     >   ?   +       "
+Blk Wrd Int Ptr Pru W_b W_e   Lpr Rpr Com Mns Les Slh Lsq Rsq   Bsl Lfl Rfl Pip Sp1 Sp2 Dot Sp4   Sp5 Sp6 Pls ... Str */
+[Blk]={ 0, {0,
+Blk,Wrd,Int,Ptr,Pru,Str,ERR,  Lpr,Rpr,Com,Mns,Les,Slh,Lsq,Rsq,  Bsl,Lfl,Rfl,Pip,Sp1,Sp2,Dot,Sp4,  Sp5,Sp6,ERR,ERR,ERR,ERR,ERR,ERR}},
+[Wrd]={  WORD, {0,
+OK ,Wrd,Wrd,Wrd,Wrd,Wrd,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  Bsl,OK ,OK ,OK ,OK ,OK ,Wrd,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+
+[Int]={  WORD, {0,
+OK ,Wrd,Int,Wrd,Wrd,OK ,OK ,  OK ,OK ,OK ,Wrd,OK ,OK ,OK ,OK ,  Wrd,OK ,OK ,OK ,OK ,OK ,Wrd,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+
+[Ptr]={  WORD,{0,
+OK ,Wrd,Wrd,Wrd,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  Wrd,OK ,OK ,OK ,OK ,OK ,Wrd,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+[Pru]={  P_RUNNER,{0,
+OK ,Pru,Pru,Pru,Pru,OK ,OK ,  OK ,OK ,OK ,Pru,OK ,OK ,OK ,OK ,  Pru,OK ,OK ,OK ,OK ,OK ,Pru,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+
+[W_b]={  0, {1,
+W_b,W_b,W_b,W_b,W_b,W_b,W_e,  W_b,W_b,W_b,W_b,W_b,W_b,W_b,W_b,  W_b,W_b,W_b,W_b,W_b,W_b,W_b,W_b,  W_b,W_b,W_b,W_b,W_b,W_b,W_b,W_b}},
+[W_e]={  WORD, {1,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+
+[Lpr]={  L_BRACKET /*L_PARENT*/,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+[Rpr]={  R_BRACKET,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+[Com]={  COMMA,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+[Mns]={  0,{0,
+ERR,ERR,ERR,ERR,ERR,ERR,ERR,  ERR,ERR,ERR,ERR,ERR,ERR,ERR,ERR,  ERR,ERR,ERR,ERR,ERR,ERR,ERR,ERR,  Lnk,ERR,ERR,ERR,ERR,ERR,ERR,ERR}},
+[Les]{  LT,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,ASG,App,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,Nam,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+
+[Slh]={  SLASH,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,Slh,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+
+[Lsq]={  L_BRACKET,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+[Rsq]={  R_BRACKET,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+[Bsl]={  0,{0,
+Wrd,Wrd,Wrd,Wrd,Wrd,Wrd,Wrd,  Wrd,Wrd,Wrd,Wrd,Wrd,Wrd,Wrd,Wrd,  Wrd,Wrd,Wrd,Wrd,Wrd,Wrd,Wrd,Wrd,  Wrd,Wrd,Wrd,Wrd,Wrd,Wrd,Wrd,Wrd}},
+[Lfl]={  L_BRACKET,{0,            /*mast removed*/
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+[Rfl]={  R_BRACKET,{0,            /*mast removed*/
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+[Pip]={  0,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+[Sp1]={  0,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+[Sp2]={  SEMICOLON,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+[Dot]={ WORD,{0,
+OK ,Wrd,Wrd,Wrd,Wrd,Wrd,Wrd,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,Dot,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+[Sp4]={  0,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+[Sp5]={  0,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+
+[Sp6]={  0,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+[Pls]={  PLUS,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+[Res]={  0,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+/*
+[Str]={  STRING_CONSTANT,{1,
+Str,Str,Str,Str,Str,Str,OK ,  Str,Str,Str,Str,Str,Str,Str,Str,  Str,Str,Str,Str,Str,Str,Str,Str,  Str,Str,Str,Str,Str,Str,Str,Str}},
+*/
+
+[Str]={  0,{0,
+Str,Str,Str,Str,Str,Str,Str,  Str,Str,Str,Str,Str,Str,Str,Str,  Str,Str,Str,Str,Str,Str,Str,Str,  Str,Str,Str,Str,Ste ,Str,Str,Str}},
+[Ste]={  STRING_CONSTANT,{1,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,Str ,OK ,OK ,OK }},
+
+[ASG]={  L_ASSIGN,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+[App]={  L_ASSIGN,{0,
+ERR,ERR,ERR,ERR,ERR,ERR,ERR,  ERR,ERR,ERR,ERR,Ap2,ERR,ERR,ERR,  ERR,ERR,ERR,ERR,ERR,ERR,ERR,ERR,  ERR,ERR,ERR,ERR,ERR,ERR,ERR,ERR}},
+/*
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,Ap2,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+*/
+[Lnk]={ L_SYMLINK,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  ERR ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+
+[Ap2]={  L_APPEND,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }},
+
+[Nam]={  NAMED,{0,
+OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK ,  OK ,OK ,OK ,OK ,OK ,OK ,OK ,OK }}
+
+};
+
+
diff -puN /dev/null parser/parser.code.c
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/parser.code.c	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,484 @@
+#ifndef lint
+/*static char yysccsid[] = "from: @(#)yaccpar	1.9 (Berkeley) 02/21/93";*/
+static char yyrcsid[] = "$Id: skeleton.c,v 1.4 1993/12/21 18:45:32 jtc Exp $\n 2002/10/22 VD reiser4";
+#endif
+#define YYBYACC 1
+#define YYMAJOR 1
+#define YYMINOR 9
+#define yyclearin (yychar=(-1))
+#define yyerrok (yyerrflag=0)
+#define YYRECOVERING (yyerrflag!=0)
+#define YYPREFIX "yy"
+#line 9 "fs/reiser4/parser/parser.y"
+typedef union 
+{
+	long charType;
+	expr_v4_t * expr;
+	wrd_t * wrd;
+} YYSTYPE;
+#line 20 "fs/reiser4/parser/parser.code.c"
+#define L_BRACKET 257
+#define R_BRACKET 258
+#define WORD 259
+#define P_RUNNER 260
+#define STRING_CONSTANT 261
+#define TRANSCRASH 262
+#define SEMICOLON 263
+#define COMMA 264
+#define L_ASSIGN 265
+#define L_APPEND 266
+#define L_SYMLINK 267
+#define PLUS 268
+#define SLASH 269
+#define INV_L 270
+#define INV_R 271
+#define EQ 272
+#define NE 273
+#define LE 274
+#define GE 275
+#define LT 276
+#define GT 277
+#define IS 278
+#define AND 279
+#define OR 280
+#define NOT 281
+#define IF 282
+#define THEN 283
+#define ELSE 284
+#define EXIST 285
+#define NAME 286
+#define UNNAME 287
+#define NAMED 288
+#define ROOT 289
+#define YYERRCODE 256
+#define YYTABLESIZE 422
+#define YYFINAL 5
+#ifndef YYDEBUG
+#define YYDEBUG 0
+#endif
+#define YYMAXTOKEN 289
+#if defined(YYREISER4_DEF)
+#define extern static
+#endif
+extern short yylhs[];
+extern short yylen[];
+extern short yydefred[];
+extern short yydgoto[];
+extern short yysindex[];
+extern short yyrindex[];
+extern short yygindex[];
+extern short yytable[];
+extern short yycheck[];
+#if YYDEBUG
+extern char *yyname[];
+extern char *yyrule[];
+#endif
+#if defined(YYREISER4_DEF)
+#define YYSTACKSIZE 500
+#define YYMAXDEPTH 500
+//#define yydebug ws->ws_yydebug 
+#define yynerrs ws->ws_yynerrs
+#define yyerrflag ws->ws_yyerrflag
+#define yychar ws->ws_yychar
+#define yyssp ws->ws_yyssp
+#define yyvsp ws->ws_yyvsp
+#define yyval ws->ws_yyval
+#define yylval ws->ws_yylval
+#define yyss ws->ws_yyss
+#define yyvs ws->ws_yyvs
+#define yystacksize ws->ws_yystacksize
+#else
+#ifdef YYSTACKSIZE
+#undef YYMAXDEPTH
+#define YYMAXDEPTH YYSTACKSIZE
+#else
+#ifdef YYMAXDEPTH
+#define YYSTACKSIZE YYMAXDEPTH
+#else
+#define YYSTACKSIZE 500
+#define YYMAXDEPTH 500
+#endif
+#endif
+int yydebug;
+int yynerrs;
+int yyerrflag;
+int yychar;
+short *yyssp;
+YYSTYPE *yyvsp;
+YYSTYPE yyval;
+YYSTYPE yylval;
+short yyss[YYSTACKSIZE];
+YYSTYPE yyvs[YYSTACKSIZE];
+#define yystacksize YYSTACKSIZE
+#endif
+#line 160 "fs/reiser4/parser/parser.y"
+
+
+#define yyversion "4.0.0"
+#include "pars.cls.h"
+#include "parser.tab.c"
+#include "pars.yacc.h"
+#include "lib.c"
+
+/* Make Linus happy.
+   Local variables:
+   c-indentation-style: "K&R"
+   mode-name: "LC"
+   c-basic-offset: 8
+   tab-width: 8
+   End:
+*/
+#line 132 "fs/reiser4/parser/parser.code.c"
+#define YYABORT goto yyabort
+#define YYREJECT goto yyabort
+#define YYACCEPT goto yyaccept
+#define YYERROR goto yyerrlab
+int
+#if defined(YYREISER4_DEF)
+yyparse(struct reiser4_syscall_w_space  * ws)
+#else
+#if defined(__STDC__)
+yyparse(void)
+#else
+yyparse()
+#endif
+#endif
+{
+    register int yym, yyn, yystate;
+#if YYDEBUG
+    register char *yys;
+    static char *getenv();
+
+    if (yys = getenv("YYDEBUG"))
+    {
+        yyn = *yys;
+        if (yyn >= '0' && yyn <= '9')
+            yydebug = yyn - '0';
+    }
+#endif
+
+    yynerrs = 0;
+    yyerrflag = 0;
+    yychar = (-1);
+
+    yyssp = yyss;
+    yyvsp = yyvs;
+    *yyssp = yystate = 0;
+
+yyloop:
+    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
+    if (yychar < 0)
+    {
+        if ((yychar = yylex()) < 0) yychar = 0;
+#if YYDEBUG
+        if (yydebug)
+        {
+            yys = 0;
+            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
+            if (!yys) yys = "illegal-symbol";
+            printf("%sdebug: state %d, reading %d (%s)\n",
+                    YYPREFIX, yystate, yychar, yys);
+        }
+#endif
+    }
+    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
+            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
+    {
+#if YYDEBUG
+        if (yydebug)
+            printf("%sdebug: state %d, shifting to state %d\n",
+                    YYPREFIX, yystate, yytable[yyn]);
+#endif
+        if (yyssp >= yyss + yystacksize - 1)
+        {
+            goto yyoverflow;
+        }
+        *++yyssp = yystate = yytable[yyn];
+        *++yyvsp = yylval;
+        yychar = (-1);
+        if (yyerrflag > 0)  --yyerrflag;
+        goto yyloop;
+    }
+    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
+            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
+    {
+        yyn = yytable[yyn];
+        goto yyreduce;
+    }
+    if (yyerrflag) goto yyinrecovery;
+#if defined(YYREISER4_DEF)
+    yyerror(ws,11111,yystate,yychar);
+#else 
+    yyerror("syntax error");
+#endif
+#ifdef lint
+    goto yyerrlab;
+#endif
+yyerrlab:
+    ++yynerrs;
+yyinrecovery:
+    if (yyerrflag < 3)
+    {
+        yyerrflag = 3;
+        for (;;)
+        {
+            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
+                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
+            {
+#if YYDEBUG
+                if (yydebug)
+                    printf("%sdebug: state %d, error recovery shifting\
+ to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
+#endif
+                if (yyssp >= yyss + yystacksize - 1)
+                {
+                    goto yyoverflow;
+                }
+                *++yyssp = yystate = yytable[yyn];
+                *++yyvsp = yylval;
+                goto yyloop;
+            }
+            else
+            {
+#if YYDEBUG
+                if (yydebug)
+                    printf("%sdebug: error recovery discarding state %d\n",
+                            YYPREFIX, *yyssp);
+#endif
+                if (yyssp <= yyss) goto yyabort;
+                --yyssp;
+                --yyvsp;
+            }
+        }
+    }
+    else
+    {
+        if (yychar == 0) goto yyabort;
+#if YYDEBUG
+        if (yydebug)
+        {
+            yys = 0;
+            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
+            if (!yys) yys = "illegal-symbol";
+            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
+                    YYPREFIX, yystate, yychar, yys);
+        }
+#endif
+        yychar = (-1);
+        goto yyloop;
+    }
+yyreduce:
+#if YYDEBUG
+    if (yydebug)
+        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
+                YYPREFIX, yystate, yyn, yyrule[yyn]);
+#endif
+    yym = yylen[yyn];
+    yyval = yyvsp[1-yym];
+    switch (yyn)
+    {
+case 1:
+#line 79 "fs/reiser4/parser/parser.y"
+{ yyval.charType = free_expr( ws, yyvsp[0].expr ); }
+break;
+case 2:
+#line 83 "fs/reiser4/parser/parser.y"
+{ yyval.expr = yyvsp[0].expr;}
+break;
+case 3:
+#line 84 "fs/reiser4/parser/parser.y"
+{ yyval.expr = const_to_expr( ws, yyvsp[0].wrd ); }
+break;
+case 4:
+#line 85 "fs/reiser4/parser/parser.y"
+{ yyval.expr = unname( ws, yyvsp[0].expr ); }
+break;
+case 5:
+#line 86 "fs/reiser4/parser/parser.y"
+{ yyval.expr = concat_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); }
+break;
+case 6:
+#line 87 "fs/reiser4/parser/parser.y"
+{ yyval.expr = list_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); }
+break;
+case 7:
+#line 88 "fs/reiser4/parser/parser.y"
+{ yyval.expr = list_async_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); }
+break;
+case 8:
+#line 89 "fs/reiser4/parser/parser.y"
+{ yyval.expr = yyvsp[0].expr; level_down( ws, IF_STATEMENT, IF_STATEMENT ); }
+break;
+case 9:
+#line 91 "fs/reiser4/parser/parser.y"
+{ yyval.expr = assign( ws, yyvsp[-2].expr, yyvsp[0].expr ); }
+break;
+case 10:
+#line 92 "fs/reiser4/parser/parser.y"
+{ yyval.expr = assign( ws, yyvsp[-2].expr, yyvsp[0].expr ); }
+break;
+case 11:
+#line 93 "fs/reiser4/parser/parser.y"
+{ yyval.expr = assign_invert( ws, yyvsp[-4].expr, yyvsp[-1].expr ); }
+break;
+case 12:
+#line 94 "fs/reiser4/parser/parser.y"
+{ yyval.expr = symlink( ws, yyvsp[-2].expr, yyvsp[0].expr ); }
+break;
+case 13:
+#line 103 "fs/reiser4/parser/parser.y"
+{ yyval.expr = if_then_else( ws, yyvsp[-3].expr, yyvsp[-2].expr, yyvsp[0].expr ); }
+break;
+case 14:
+#line 104 "fs/reiser4/parser/parser.y"
+{ yyval.expr = if_then( ws, yyvsp[-1].expr, yyvsp[0].expr) ;         }
+break;
+case 15:
+#line 108 "fs/reiser4/parser/parser.y"
+{ yyval.expr = yyvsp[0].expr; }
+break;
+case 16:
+#line 111 "fs/reiser4/parser/parser.y"
+{ level_up( ws, IF_STATEMENT ); }
+break;
+case 17:
+#line 115 "fs/reiser4/parser/parser.y"
+{ yyval.expr = not_expression( ws, yyvsp[0].expr ); }
+break;
+case 18:
+#line 116 "fs/reiser4/parser/parser.y"
+{ yyval.expr = check_exist( ws, yyvsp[0].expr ); }
+break;
+case 19:
+#line 117 "fs/reiser4/parser/parser.y"
+{ yyval.expr = compare_EQ_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); }
+break;
+case 20:
+#line 118 "fs/reiser4/parser/parser.y"
+{ yyval.expr = compare_NE_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); }
+break;
+case 21:
+#line 119 "fs/reiser4/parser/parser.y"
+{ yyval.expr = compare_LE_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); }
+break;
+case 22:
+#line 120 "fs/reiser4/parser/parser.y"
+{ yyval.expr = compare_GE_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); }
+break;
+case 23:
+#line 121 "fs/reiser4/parser/parser.y"
+{ yyval.expr = compare_LT_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); }
+break;
+case 24:
+#line 122 "fs/reiser4/parser/parser.y"
+{ yyval.expr = compare_GT_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); }
+break;
+case 25:
+#line 123 "fs/reiser4/parser/parser.y"
+{ yyval.expr = compare_OR_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); }
+break;
+case 26:
+#line 124 "fs/reiser4/parser/parser.y"
+{ yyval.expr = compare_AND_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); }
+break;
+case 27:
+#line 128 "fs/reiser4/parser/parser.y"
+{ goto_end( ws );}
+break;
+case 28:
+#line 132 "fs/reiser4/parser/parser.y"
+{ yyval.expr = yyvsp[0].expr;}
+break;
+case 29:
+#line 133 "fs/reiser4/parser/parser.y"
+{ yyval.expr = target_name( yyvsp[-2].expr, yyvsp[0].expr );}
+break;
+case 30:
+#line 137 "fs/reiser4/parser/parser.y"
+{ yyval.expr = pars_expr( ws, yyvsp[-1].expr, yyvsp[0].expr ) ; }
+break;
+case 31:
+#line 138 "fs/reiser4/parser/parser.y"
+{ yyval.expr = pars_expr( ws, yyvsp[-2].expr, yyvsp[0].expr ) ; }
+break;
+case 32:
+#line 142 "fs/reiser4/parser/parser.y"
+{ yyval.expr = pars_lookup_root( ws ) ; }
+break;
+case 33:
+#line 143 "fs/reiser4/parser/parser.y"
+{ yyval.expr = pars_lookup_curr( ws ) ; }
+break;
+case 34:
+#line 147 "fs/reiser4/parser/parser.y"
+{ yyval.expr = lookup_word( ws, yyvsp[0].wrd ); }
+break;
+case 35:
+#line 148 "fs/reiser4/parser/parser.y"
+{ yyval.expr = yyvsp[-1].expr; level_down( ws, yyvsp[-2].charType, yyvsp[0].charType );}
+break;
+case 36:
+#line 152 "fs/reiser4/parser/parser.y"
+{ yyval.charType = yyvsp[0].charType; level_up( ws, yyvsp[0].charType ); }
+break;
+#line 425 "fs/reiser4/parser/parser.code.c"
+    }
+    yyssp -= yym;
+    yystate = *yyssp;
+    yyvsp -= yym;
+    yym = yylhs[yyn];
+    if (yystate == 0 && yym == 0)
+    {
+#if YYDEBUG
+        if (yydebug)
+            printf("%sdebug: after reduction, shifting from state 0 to\
+ state %d\n", YYPREFIX, YYFINAL);
+#endif
+        yystate = YYFINAL;
+        *++yyssp = YYFINAL;
+        *++yyvsp = yyval;
+        if (yychar < 0)
+        {
+            if ((yychar = yylex()) < 0) yychar = 0;
+#if YYDEBUG
+            if (yydebug)
+            {
+                yys = 0;
+                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
+                if (!yys) yys = "illegal-symbol";
+                printf("%sdebug: state %d, reading %d (%s)\n",
+                        YYPREFIX, YYFINAL, yychar, yys);
+            }
+#endif
+        }
+        if (yychar == 0) goto yyaccept;
+        goto yyloop;
+    }
+    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
+            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
+        yystate = yytable[yyn];
+    else
+        yystate = yydgoto[yym];
+#if YYDEBUG
+    if (yydebug)
+        printf("%sdebug: after reduction, shifting from state %d \
+to state %d\n", YYPREFIX, *yyssp, yystate);
+#endif
+    if (yyssp >= yyss + yystacksize - 1)
+    {
+        goto yyoverflow;
+    }
+    *++yyssp = yystate;
+    *++yyvsp = yyval;
+    goto yyloop;
+yyoverflow:
+#if defined(YYREISER4_DEF)
+    yyerror(ws,101); /*yacc stack overflow*/
+#else 
+    yyerror("yacc stack overflow");
+#endif
+yyabort:
+    return (1);
+yyaccept:
+    return (0);
+}
diff -puN /dev/null parser/parser.doc
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/parser.doc	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,467 @@
+/* Parser for the reiser4() system call */
+
+/* Takes a string and parses it into a set of commands which are
+   executed.  */
+
+/*
+
+If you want to read about where future versions of this syntax will
+go, and what the grand scheme is, please go to
+www.namesys.com/future_vision.html.
+
+Names resolve into sets of keys.  In Reiser4, the sets of keys all
+consist of exactly one key, but this will change in future versions.
+
+Keys are not immutable objectids ala inode numbers.  The use of
+immutable objectids that all objects could be found by was the
+original architecture, and before coding was started this was realized
+to require lower performance due to creating immutable, and therefor
+poor, locality of reference when resolving them.  Keys currently do
+contain unique objectids, but this objectid does not suffice for
+finding the object.
+
+Name compounders construct names from subnames.  / and [] ([] is not
+implemented in reiser4, see www.namesys.com/future_vision.html for
+what it will do in a later version) are name compounders.  Name
+compounders can use any name which can be resolved into a key as a
+subname.  This provides "closure", in which the type of the result of
+every name operation is the same as the type of what the name
+operators operate on.  (Persons who create abstract models tend to
+place a high value on achieving closure in their design.  For more
+about closure, read www.namesys.com/future_vision.html.)
+
+A/B indicates that B is to be passed to A, and A will resolve its
+meaning.  This is consistent with Unix usage of /.  B is considered
+a subname of A in this example.
+
+Reiser4 supports a plugin that implements Unix regular files (regfile),
+and a plugin that implements Unix regular directories (regdir). (NIKITA-FIXME-HANS: use those names in the code)
+
+Plugins may resolve a subname by invoking a plugin of another object,
+or by invoking methods built into themselves.
+
+Special characters are whitespace plus []{}()/\,:;*$@!`' and keywords
+are <- and ->
+
+<-, ->,  are assignment operators.
+
+
+'A<-B' uses B's read method to read B, and uses A'S write method to
+write to A what was read from B.  It is a copy command similar to
+sendfile().
+
+The righthand side of an assignment defines a flow.  We calculate the flow,
+and then invoke the the write method defined by the lefthand side of
+the assignment.
+
+Example:
+
+A<-B
+
+assigns the contents of the object named B to A, overwriting the contents of A if A exists.
+
+` and ' indicate that all special characters between them should be
+ignored and parsed as a single string. That is, A<-`some text' causes A to have
+contents equal to a file named `some text'.  Quotes are allowed to nest.
+
+" indicates that the next word is inlined text.  Sorry, " is the
+symbol least useful for something else, so it got used.
+
+A<-"(this is a string not a name of a file)  // German style quoting: ,,ksdajfhkasdh``
+
+assigns (sans the single quotes) the string `this is a string not a name of a file' to A.
+
+A<-"`I think that using " in a language for delimiting quoting is bad style because delimiters should be matching pairs not matching identical singletons if nesting is to work at all.'
+
+assigns the string `I think that using " in a language for delimiting quoting is bad style because delimiters should be matching pairs not matching identical singletons if nesting is to work at all.' to A
+
+
+
+
+special case ??? (not yet work.)
+
+E<-name
+
+where E is directory.
+in this case in directory E will create or owerwrite files assign_length assign_result with correspended values.
+
+
+
+General rules for tmp names.
+If lookup can't find any name in FS for specified path, this name is a TMP name. It can have a value and a children. but no metadata.
+Of course it have a parent. Life time of this name limited by surrounding brackets or the end of the command string.
+Fist name in path, which is TMP name my have a subtree of TMP names, and ony TMP names.
+It can be used on the left hand of assign. In this case it will have value as a copy of value of the right hand.
+
+
+
+Different between TMP names and named assign.
+1. The name of named assign can be exist in file system. TMP name - not.
+2. We can recursively define named assign with same name as stack of value. TMP name has only one value.
+(need to check if we use TMP name and same named assign )
+3. The name of named assign will have 2 child for assign result with fixed names.
+
+All other properties is equivalent.
+while life time we can add any new name as child, if it not exist.
+
+A<<-B
+
+appends file B to file A (not yet ready)
+
+
+
+
+
+
+We need to define multiple aspects of the object when creating it.
+Additionally, we need to assign default values to those aspects of the
+definition not defined.  The problem arises when we have a multi-part
+definition.  We should avoid assigning one part, then assigning
+default values for all other parts, then overwriting those default
+values, some of which actually cannot be overwritten (e.g. pluginid).
+
+This means we need to name the object, and then perform multiple
+assignments in its creation.
+
+(x_ and )x_ where x is any sequence (including the null sequence) of
+non-special characters, are `named parenthesis'.  They have the usual meaning of
+parenthesis in most languages, and delimit what should be treated as a
+single unit by operators.  If you use named parenthesis you can avoid
+the "LISP bird nest" effect.  The disadvantage is that if you leave
+off the whitespace following the open parenthesis you will get an
+unintended effect.  Note that there must be no space between ( and x.
+(not yet ready)
+
+Referencing the contents of parenthesis by the name of the parenthesis
+is planned in later versions..
+
+It is an unenforced but encouraged style convention that subnames
+which contain meta-information about the object, and pseudo-files that
+implement methods of the object, begin with `..'.  IT IS NOT A
+REQUIREMENT THAT THEY START WITH `..', READ THAT AGAIN!  Sorry, got
+tired of the complaints about the non-existent requirement.  It all
+depends on how you write your plugins that use the meta-information
+whether the meta-data starts with `..'.
+
+Since what is meta-information, what is a method of the object, and
+what is contained information, or methods of sub-objects, are not
+necessarily always inherently susceptible to precise natural
+distinction, and since we desire to allow users maximal stylistic
+freedom to extend reiser4 into emulating other syntaxes, this is only
+an optional plugin design convention for use when appropriate.
+
+One can specify whether a file is listed by readdir in reiser4.  Using
+that feature, subnames of files containing meta-information about
+other files are by convention not listed by readdir, but can be listed
+by using the command reiser4("A_listing<-A/..list"), and then reading
+the file A_listing.
+
+For instance, if A is a regfile or regdir, then A/..owner resolves to
+a file containing the owner of A, and reading the A directory shows no
+file named ..owner.  More generally, all of the fields returned by
+stat() have a corresponding name of the form A/..field_name for all
+regfiles and regdirs.  The use of'..' avoids clashes between method
+names and filenames.  More extreme measures could be taken using
+something more obscure than '..' as a prefix, but I remember that
+Clearcase and WAFL never really had much in the way of problems with
+namespace collisions affecting users seriously, so I don't think one
+should excessively inconvenience a syntax for such reasons.
+
+DEMIDOV-FIXME-HANS: the paragraph below conflicts with the above
+*A (similar to C language dereference) means take the contents of
+that object which A is the name for, and treat those contents as a name.
+
+
+*`A B' is a reference to a file whose name consists of the characters
+A and a space and a B.
+
+
+A;B indicates that B is not to be executed until A completes.  So, `/'
+orders subnames within a compound name, and `;' orders operations.
+
+
+A,B indicates that A and B are independent of each other and
+unordered.
+
+A/B indicates that the plugin for A is to be passed B,
+and asked to handle it in its way, whatever that way is.
+
+/ and \ are considered equivalent, as a kindness to former windows users
+
+C/..invert<-A +"(some text)+ B
+
+indicates that C when read shall return the contents of A followed by
+'some text' as a delimiter followed by the contents of B.
+
+if  A  and   B  are object expressions then
+               A+B  is object expression
+               A\B  is object expression
+               A<-B is possible operation
+
+
+
+
+--------------
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+So, let us discuss the following example:
+
+Assume 357 is the user id of Michael Jackson.
+
+The following 3 expressions are equivalent:
+
+ascii_command = "/home/teletubbies/(..new(..name<-"glove_location", ..object_t<-audit/regular, ..perm_t<-acl); glove_location/..acl<-( uid<-357, access<-denied ); glove_location/..audit<-mailto<-teletubbies@pbs.org; glove_location<-'we stole it quite some number of years ago, and put it in the very first loot pile (in the hole near the purple flower.')";
+
+ascii_command = "/home/teletubbies/(glove_location<-( ..object_t<-audit/regular, ..perm_t<-acl); glove_location/..acl<-  ( uid<-357, access<-denied ); glove_location/..audit<-mailto<-teletubbies@pbs.org; glove_location<-'we stole it quite some number of years ago, and put it in the very first loot pile (in the hole near the purple flower)')";
+
+
+ascii_command = "/home/teletubbies/(glove_location<-( ..object_t<-audit/regular, ..perm_t<-acl); glove_location / ( ..acl<-(uid<-357, access<-denied) ; ..audit<-mailto<-teletubbies@pbs.org); glove_location<-'we stole it quite some number of years ago, and put it in the very first loot pile (in the hole near the purple flower).')";
+
+DEMIDOV-FIXME-HANS: what is the meaning of the line below, and should it be ..new rather than new
+a/b/(new/(name<-"new_file_name"; type<-"regular file"; perm_t<-"acl"); new_file_name/acl<- ( uid<-"357", access<-"denied" ))
+
+DEMIDOV-FIXME-HANS: update this example
+ascii_command =
+   "/home/teletubbies/glove_location<-
+             ( (..object_t<-audit, ..perm_t<-acl) ;
+                ..acl<-  ( uid<-'357', access<-denied );
+                ..audit/(backing<-..anon<=(..object_t<-regular); // lookup<-/home/teletubbies/some-existing-file),
+                         log<-(mailto<-teletubbies@pbs.org));
+                ..body<-'we stole it quite some number of years ago, and put it in the very first loot pile (in the hole near the purple flower)';)";
+
+(a b)
+result<-/subject/[elves strike]
+(result /subject/[elves strike])
+/subject/[elves strike]->result
+
+
+
+
+DEMIDOV-FIXME-HANS: cleanup the explanation below
+The components of this example have the following meanings:
+/home/teletubbies/       - directory name
+/(..name                 - specifies that its argument is the name of the new file - parameter for ..new plugin
+/glove_location, - name of new file - parameter for name submethod of ..new method
+..object_t     -  name of submethod that assigns object type to new files - parameter for ..new plugin
+/audit         - plugin for file
+/regular,      - plugin for backing store for audit plugin
+..perm_t       - security plugin to be assigned
+)              - end of parameters for ..new plugin
+;              - next system call
+glove_location - file name
+/..acl         - plugin ..acl
+(              - begin parameters for ..new plugin of ..acl plugin
+uid            - plugin of ..acl plugin
+/357           - its value(parameter)
+,              -
+access         - ..
+/denied        -  value to assign
+)              - end of parameter list
+)              - ? unbalanced brakes
+;
+..audit        - plugin - file is unknown!
+/..new
+/mailto
+/"teletubbies@pbs.org"
+;
+glove_location_file - file name
+/
+
+"we stole it quite some number of years ago, and put it in the very first loot pile (in the hole near the purple flower)." - body of file
+
+reiser4(&ascii_command, ascii_command_length, stack_binary_parameters_referenced_in_ascii_command, stack_length);
+
+
+*/
+
+/*
+
+     w=\$v v=\$u u=5 z=\$w+$w
+               echo $z
+          eval echo $z
+     eval eval echo $z
+
+eval eval eval echo $z
+
+result is:
+
+$w+$v
+$v+$u
+$u+5
+5+5
+
+tw/transcrash_33[ /home/reiser/(a <- b, c <- d) ]
+
+        chgrp --      changes group ownership
+        chown --      changes ownership
+        chmod --      changes permissions
+        cp --	      copies
+        dd --	      copies and converts
+        df --	      shows filesystem disk usage.
+        dir --	      gives brief directory listing
+        du --	      shows disk usage
+        ln --	      creates links
+        ls --	      lists directory contents
+        mkdir --      creates directories
+        mkfifo --     creates FIFOs (named pipes)
+        mknod --      creates special files
+        mv --	      renames
+        rm --	      removes (deletes)
+        rmdir --      removes empty directories
+        shred --      deletes a file securely
+        sync --	      synchronizes memory and disk
+*/
+
+
+
+/*
+
+
+Assignment, and transaction, will be the commands supported in Reiser4(); more commands will appear in Reiser5. -> and <- will be the assignment operators.
+
+The amount transferred by an assignment is the minimum of the size of the left hand side and the size of the right hand side.  This amount is usually made one of the return values.
+
+    * lhs (assignment target) values:
+
+    /..process/..range/(first_byte<-(loff_t),last_byte<-(loff_t),bytes_written<-(ssize_t*) )
+              assigns (writes) to the buffer starting at address first_byte in the process address space, ending at last_byte, with the number of bytes actually written
+	      (The assignment source may be smaller or larger than the assignment target.) being written to address bytes_written.
+	      Representation of first_byte,last_byte, and bytes_written is left to the coder to determine.
+	      It is an issue that will be of much dispute and little importance.
+	      Notice / is used to indicate that the order of the operands matters; see www.namesys.com/future_vision.html for details of why this is appropriate syntax design.
+	      Note the lack of a file descriptor.
+
+    /filename
+              assigns to the file named filename, wholly obliterating its body with what is assigned.
+
+    /filename/..range/(first_byte<-(loff_t),last_byte<-(loff_t),bytes_written<-(ssize_t*) )
+              writes to the body, starting at first_byte, ending not past last_byte,
+	      recording number of bytes written in bytes_written
+
+    /filename/..range/(first_byte<-(loff_t),bytes_written<-(ssize_t*) )
+              writes to the body starting at offset, recording number of bytes written in bytes_written
+
+    * rhs (assignment source) values:
+
+    /..process/..range/(first_byte<-(loff_t),last_byte<-(loff_t),bytes_read<-(ssize_t*) )
+              reads from the buffer starting at address first_byte in the process address space, ending at last_byte.
+	      The number of bytes actually read (assignment source may be smaller or larger than assignment target) is written to address bytes_read.
+	      Representation of first_byte, last_byte, and bytes_read is left to the coder to determine, as it is an issue that will be of much dispute and little importance.
+
+    /filename
+              reads the entirety of the file named filename.
+
+    /filename/..range/(first_byte<-(loff_t),last_byte<-(loff_t),bytes_read<-(ssize_t*) )
+              reads from the body, starting at first_byte, ending not past last_byte,
+              recording number of bytes read in bytes_read
+
+    /filename/..range/(first_byte<-(loff_t),bytes_read<-(ssize_t*) )
+              reads from the body starting at offset until the end, recording number of bytes read in bytes_read
+
+    /filename/..stat/owner
+              reads from the ownership field of the stat data (stat data is that which is returned by the
+              stat() system call (owner, permissions, etc.) and stored on a per file basis by the FS.)
+
+
+
+
+
+*/
+
+
+
+
+/*
+
+example:
+
+
+
+
+       /path0/(path1/filename/..range/(offset<-100,bytes_written<-0xff001258,last_byte<-256)<-path2/filename/..range(first_byte<-0,bytes_readed<-0xff001250) )
+
+       /path0/(path1/filename/..range/(100,256)<-path2/filename/..range(0,256) )
+
+
+                                                                          ?
+       /path0/path1/filename/..range/(offset<-100,bytes_written<-0xff001258),last_byte<-256,/path0/path2/filename/..range(first_byte<-0,p_bytes_readed<-0xff001250)
+
+ssize_t bytes_readed;
+
+sprintf( string_pointer_bytes_read, "%8.8p", &bytes_readed );
+
+ */
+
+
+examples:
+
+
+.....b/(new/(name<-"new_file_name"; type<-regular_file; permition<-acl); new_file_name/acl/( uid<-"357", access<-denied );new_file_name<-/etc/passwd)
+
+where:
+  b is a directory
+(if it is ommited then we take the current directory PWD, and take the lnode from it)
+we have lnode for it.
+then we make:
+b_lnode->lookup(new)
+it that meen we find lnode for directory plugin "new"
+   and then we find new_lnode->lookup(name). this is lnode for name of new file and we assign to it string constant "new_file_name".
+
+   then we find new_lnode->lookup(type). this is lnode of type of new file
+   then we find new_lnode->lookup(regular_file) this is lnode of constants of types of plugin "new" for regular file
+   then we copy contens regular_file_lnode throuse tube to type_lnode.
+
+   then we find new_lnode->lookup(permition). this is lnode of type of permition of new file
+   then we find new_lnode->lookup(acl). this is lnode of constants of type of permition of "new" plugin, correcponding to acl
+   then we copy contens acl_lnode throuse tube to permition_lnode.
+
+then we find b_lnode->lookup(new_file_name). this is lnode for new file we jast created.
+then we find new_file_name_lnode->lookup(acl) . this is lnode of acl plugin .
+   then we find acl_lnode->lookup(uid)this is lnode for uid field of acl and assign to it string constant "357".
+   then we find acl_lnode->lookup(access).
+   then we find acl_lnode->lookup(denied).
+   then we copy contens denied_lnode throuse tube to access_lnode.
+
+then we find root_lnode->lookup(etc),
+then we find etc_lnode->lookup(passwd)
+then we read contens passwd_lnode throuse tube and write to new_file_name_lnode lnode.
+
+ok. command string is executed.
+
+
+
+
+Ok suppose we have the root system as ext2, and 2 reiser4 partition
+mounted in /path1 and /path2 and command string is:
+"/path1/file<-/path2/file1+file2" path begining with "/" is a non
+reiser4 but we need pars it, find dentry, check: is it a reiser4?  and
+while going throuth the path1 or path2 we mast do it for all element
+of path.
+
+The objects operate with lnodes.
+
+
+
+# Local variables:
+# mode-name: "proposal"
+# indent-tabs-mode: nil
+# tab-width: 4
+# eval: (if (fboundp 'flyspell-mode) (flyspell-mode))
+# End:
+
diff -puN /dev/null parser/parser.doc1
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/parser.doc1	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,174 @@
+
+SYS_REISER4 IMPLEMENTATION OVERVIEW
+
+
+A. Basics
+*****************************************************************
+
+sys_reiser4() system call executing a sequence of actions upon the
+file-system(s). Actions are specified by the user in a form of command
+string. For the purposes of present discussion, said command string can be
+thought of as a program in a special purpose programming language, which will
+be further referred to as rsccl (reiser4 system call command language,
+presumably pronounced as "rascal").
+
+Canonical example of rsccl program is
+
+/dir1/dir2/dir3/file1 <- /dir4/dir5/dir6/file2
+
+It semantics is following:
+
+1. resolve "/dir1/dir2/dir3/file1" into file-system object (lookup operation)
+2. resolve "/dir4/dir5/dir6/file2" into file-system object (lookup operation)
+3. assign latter to the former.
+
+This is "assignment" operator. Assignment involves two "file-system objects"
+and semantics of both lookup stage and assignment proper depends upon type of
+the file-system object.
+
+Following types of file-system objects are recognized:
+
+1. foreign objects: objects of different file-systems. [In the initial
+version,] foreign object cannot be target or source of an assignment. Rather,
+foreign objects can only appear during path name lookup, while traversing
+non-reiser4 part of the file-system name-space. Probably one should
+distinguish between objects belonging to different file-system types (etx2,
+NFS) and objects belonging to different reiser4 mounts.
+
+2. reiser4 objects.
+
+3. pseudo-objects: these are entities injected into reiser4 name-space to
+provide uniform access to various file-system meta-data. Pseudo-objects are
+(usually) attached to some particular "host" object. [In the initial version,]
+host objects are reiser4 objects. [Later it is possible to implement some
+pseudo-objects for foreign objects.] Convention (but not enforced rule) is
+that pseudo-objects are accessible through names starting with some well-known
+prefix (".." is current favorite). Examples: ..owner, ..acl, etc. See comment
+at the top of fs/reiser4/plugin/pseudo/pseudo.c for more details.
+
+B. lnodes
+*****************************************************************
+
+lnodes are handles for file-system objects described above. They serve dual
+purpose:
+
+1. uniform interface to the various types of objects. This allows rsccl
+implementation to treat various types of objects in the same manner. When new
+type of object has to be added, all changes will be grouped in one place,
+rather than scattered across various files. This uniformity also allows code
+sharing between rsccl and VFS access paths. For example, the same ->write
+method can be used by both.
+
+2. synchronization. rsccl doesn't use inodes and this poses a problem of
+synchronization with VFS. Each lnode serves as a lock. See lnode.c for more
+details.
+
+C. lookup
+*****************************************************************
+
+[In initial version,] we still support only two traditional UNIX kinds of
+pathnames: absolute and relative to the current working directory. In both
+cases, lookup starts from some file-system object represented by lnode. Then
+lookup proceeds component-by-component as follows:
+
+   lnode *parent;
+   lnode  child;
+
+   ret_code = lnode_get_dir_plugin( parent ) -> lnode_by_name( parent, 
+                                                               path_component,
+                                                               &child );
+
+1. Abovementioned locking issues require that parent lnode has to be kept
+until operation on child finishes. In effect we get lock-coupling much like in
+internal tree traversal.
+
+2. Mount points crossing. It is possible, because dentries and therefore
+inodes of all mount points are pinned in memory and lookup code can check at
+each step whether mount point is crossed. Details are not very nice, because
+for each inode in a path we have to scan list of all its dentries and check
+whether correct one (corresponding to our path) is mount point.
+
+D. assignment
+*****************************************************************
+
+Assignment A<-B basically means duplicating content of B into A. No
+copy-on-write optimizations are planned at this stage.
+
+Assignment implementation is based on the notion of flow (flow_t). Flow is a
+source from which data can be obtained. Flow can be "backed up" by one of the
+following:
+
+1. memory area in user space. (char *area, size_t length)
+2. memory area in kernel space. (caddr_t *area, size_t length)
+3. file-system object (lnode *obj, loff_t offset, size_t length)
+
+Main function to manipulate flows is:
+
+int flow_place( flow_t *flow, char *area, size_t length );
+
+it copies @length bytes of @flow into @area and updated @flow correspondingly.
+Behavior of flow_place() depends on the type of entity backing up @flow. If
+@flow is based on the kernel-space area, memmove() is used to copy data. If
+@flow is based on the user-space area, copy_from_user() is used. If @flow is
+based on file-system object, flow_place() loads object's data into page cache
+and copies them into @area.
+
+Thus, assignment code looks like following:
+
+int reiser4_assign( lnode *dst, lnode *src )
+{
+    flow_t flow;
+    int    ret_code;
+    int    offset;
+    
+    offset = 0;
+    ret_code = lnode_get_body_plugin( src ) -> build_flow( src, &flow, offset );
+    while( flow_not_empty( &flow ) ) {
+        char  *area;
+        size_t length;
+
+        /* 
+         * append some space to @dst. Reasonable implementation will allocate
+         * several pagesful here 
+         */
+        ret_code = lnode_get_body_plugin( dst ) -> prepare_append( dst, 
+                                                                   &area, 
+                                                                   &length );
+        /*
+         * put data from flow into newly alloted space. This also updates
+         * @flow.
+         */
+        flow_place( flow, area, length );
+        /*
+         * perform necessary post-write activity required by @dst plugin, like
+         * encryption, compression, etc.
+         */
+        ret_code = lnode_get_body_plugin( dst ) -> commit_append( dst, 
+                                                                  area, length );
+    }
+}
+
+
+E. parsing
+*****************************************************************
+
+It is not clear what parts of rsccl processing should go into kernel. In any
+case, providing direct system call as main (or, worse, the only) way to access
+rsccl functionality bounds as to maintain binary compatibility in a future. To
+avoid this, reiser4 should be shipped with user-level library, containing
+
+int reiser4( const char *cmd, size_t length );
+
+function. For now, this function will directly despatch @cmd to the
+sys_reiser4() in a future, it may do parsing itself and pass parse tree to the
+kernel interpreter.
+
+*****************************************************************
+
+# Local variables:
+# mode-name: "proposal"
+# indent-tabs-mode: nil
+# tab-width: 4
+# eval: (if (fboundp 'flyspell-mode) (flyspell-mode))
+# End:
+
diff -puN /dev/null parser/parser.h
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/parser.h	2005-06-30 21:17:38.169763408 +0400
@@ -0,0 +1,486 @@
+ /*
+ * Copyright, 2002 by Hans Reiser, licensing governed by reiser4/README
+ */
+
+/*
+ * definitions of common constants and data-types used by
+ * parser.y
+ */
+
+                                 /* level type defines */
+
+
+#include <linux/fs.h>		/* for struct super_block, address_space  */
+#include <linux/mm.h>		/* for struct page */
+#include <linux/buffer_head.h>	/* for struct buffer_head */
+#include <linux/dcache.h>	/* for struct dentry */
+#include <linux/types.h>
+
+#include <linux/namei.h>
+#include <linux/list.h>
+#include <linux/pagemap.h>
+#include <linux/slab.h>
+#include <linux/seq_file.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/writeback.h>
+#include <linux/backing-dev.h>
+#include <asm-generic/errno.h>
+
+#include "../forward.h"
+//#include "../debug.h"
+//#include "../dformat.h"
+#include "../znode.h"
+//#include "../vfs_ops.h"
+#include "../inode.h"
+#include "../super.h"
+#include "../reiser4.h"
+#include "../lnode.h"
+#include "../type_safe_list.h"
+#include "../kassign.h"
+#include "../coord.h"
+#include "../key.h"
+#include "../seal.h"
+#include "../plugin/item/item.h"
+#include "../plugin/security/perm.h"
+#include "../plugin/plugin.h"
+#include "../plugin/object.h"
+#include "../plugin/plugin_header.h"
+#include "../plugin/item/static_stat.h"
+#include "../plugin/item/internal.h"
+#include "../plugin/item/sde.h"
+#include "../plugin/item/cde.h"
+#include "../plugin/item/extent.h"
+#include "../plugin/item/tail.h"
+#include "../plugin/file/file.h"
+#include "../plugin/symlink.h"
+#include "../plugin/dir/hashed_dir.h"
+#include "../plugin/dir/dir.h"
+#include "../plugin/item/item.h"
+#include "../plugin/node/node.h"
+#include "../plugin/node/node40.h"
+#include "../plugin/security/perm.h"
+#include "../plugin/space/bitmap.h"
+#include "../plugin/space/space_allocator.h"
+#include "../plugin/disk_format/disk_format40.h"
+#include "../plugin/disk_format/disk_format.h"
+
+
+
+typedef enum {
+	TW_BEGIN,
+	ASYN_BEGIN,
+	CD_BEGIN,
+	OP_LEVEL,
+	NOT_HEAD,
+	IF_STATEMENT,
+	UNORDERED
+} def;
+
+//#define printf(p1,...) PTRACE(ws,p1,...)
+
+#define YYREISER4_DEF
+
+#define YYSTACKSIZE 500
+#define YYMAXDEPTH 500
+//#define yydebug ws->ws_yydebug 
+//#define yynerrs ws->ws_yynerrs
+#define yyerrflag ws->ws_yyerrflag
+//#define yychar ws->ws_yychar
+#define yyssp ws->ws_yyssp
+#define yyvsp ws->ws_yyvsp
+#define yyval ws->ws_yyval
+#define yylval ws->ws_yylval
+#define yyss ws->ws_yyss
+#define yyvs ws->ws_yyvs
+#define yyls ws->ws_yyls
+#define yylsp ws->ws_yylsp
+//#define yystacksize ws->ws_yystacksize
+
+
+
+
+
+
+#if defined(CONFIG_REISER4_FS_SYSCALL_BISON)
+
+#define YYPARSE_PARAM struct reiser4_syscall_w_space  * ws
+#define YYLEX_PARAM ws
+//#define YYPARSE_PARAM  ws
+#define YYINITDEPTH 200
+
+#ifdef YYSTACK_USE_ALLOCA
+#undef YYSTACK_USE_ALLOCA
+#define YYSTACK_USE_ALLOCA 0
+#endif
+
+#ifdef __GNUC__
+#undef __GNUC__
+#endif 
+
+//#define YYSTACK_ALLOC(i) kmalloc((i),GFP_KERNEL )
+#define free kfree
+#define  bizon
+#define YYFPRINTF
+#else
+#define register
+#define  yyacc
+#endif /*defined(CONFIG_REISER4_FS_SYSCALL_BISON)*/
+
+#define printf prink
+
+
+
+
+#define yylex(a,b,c)  reiser4_lex((a),(b),(c))
+
+
+#define  PARSER_DEBUG
+
+
+#if 1
+#define PTRACE(ws, format, ... )						\
+({										\
+	ON_TRACE(TRACE_PARSE, "parser:%s %p %s: " format "\n",	                \
+		 __FUNCTION__, ws, (ws)->ws_pline, __VA_ARGS__);		\
+})
+#else
+#define PTRACE(ws, format, ... )						\
+({										\
+	printk("parser:%s %p %s: " format "\n",	                \
+		 __FUNCTION__, ws, (ws)->ws_pline, __VA_ARGS__);		\
+})
+#endif
+
+#define PTRACE1( format, ... )				        		\
+({										\
+	ON_TRACE(TRACE_PARSE, "parser:%s  " format "\n",	                \
+		 __FUNCTION__,  __VA_ARGS__);					\
+})
+
+
+#define ASSIGN_RESULT "assign_result"
+#define ASSIGN_LENGTH "assign_length"
+
+#define SIZEFOR_ASSIGN_RESULT 16
+#define SIZEFOR_ASSIGN_LENGTH 16
+
+
+
+
+
+typedef struct pars_var pars_var_t;
+typedef union expr_v4  expr_v4_t;
+typedef struct wrd wrd_t;
+typedef struct tube tube_t;
+typedef struct sourece_stack sourece_stack_t;
+
+typedef enum {
+	ST_FILE,
+	ST_EXPR,
+	ST_DE,
+	ST_WD,
+	ST_DATA
+} stack_type;
+
+typedef enum {
+	noV4Space,
+	V4Space,
+	V4Plugin
+} SpaceType;
+
+typedef enum {
+	CONCAT,
+	COMPARE_EQ,
+	COMPARE_NE,
+	COMPARE_LE,
+	COMPARE_GE,
+	COMPARE_LT,
+	COMPARE_GT,
+	COMPARE_OR,
+	COMPARE_AND,
+	COMPARE_NOT
+} expr_code_type;
+
+
+                                 /* sizes defines      */
+#define FREESPACESIZE_DEF PAGE_SIZE*4
+#define FREESPACESIZE (FREESPACESIZE_DEF - sizeof(char*)*2 - sizeof(int) )
+
+#define _ROUND_UP_MASK(n) ((1UL<<(n))-1UL)
+
+#define _ROUND_UP(x,n) (((long)(x)+_ROUND_UP_MASK(n)) & ~_ROUND_UP_MASK(n))
+
+// to be ok for alpha and others we have to align structures to 8 byte  boundary.
+
+
+#define ROUND_UP(x) _ROUND_UP((x),3)
+
+
+
+struct tube {
+	int type_offset;
+	char * offset;       /* pointer to reading position */
+	size_t len;            /* lenth of current operation
+                               (min of (max_of_read_lenth and max_of_write_lenth) )*/
+	long used;
+	char * buf;          /* pointer to bufer */
+	loff_t readoff;      /* reading offset   */
+	loff_t writeoff;     /* writing offset   */
+	loff_t writesize;    /* writing max size   */
+
+ 	sourece_stack_t * last;        /* work. for special case to push list of expressions */
+	sourece_stack_t * next;        /* work. for special case to push list of expressions */
+	sourece_stack_t * st_current;  /* stack of source expressions */
+	expr_v4_t * target_rng;        /* reversed ranges for target */
+	pars_var_t * target;
+	struct file *dst;    /* target file  (only for target->val->lnode->l_inode)    */
+};
+
+struct wrd {
+	wrd_t * next ;                /* next word                   */
+	struct qstr u ;               /* u.name  is ptr to space     */
+};
+
+
+struct path_walk {
+	struct dentry *de;
+	struct vfsmount *mnt;
+};
+
+typedef struct expr_common {
+	__u8          type;
+	__u8          exp_code;
+} expr_common_t;
+
+
+/* types for vtype of struct pars_var */
+typedef enum {
+	VAR_EMPTY,
+	VAR_LNODE,
+	VAR_TMP
+} VAR_TYPE;
+
+typedef struct pars_var_value pars_var_value_t;
+
+struct pars_var {
+	pars_var_t * next ;         /* next                                */
+	pars_var_t * parent;        /* parent                              */
+	wrd_t * w ;                 /* name: pair (parent,w) is unique     */
+	pars_var_value_t * val;
+};
+
+
+
+typedef enum {
+	RANGE_CUT,
+	RANGE_ZERRO,
+	RANGE_TRANSPARENT,
+	RANGE_NR 
+}  range_type;
+
+typedef enum {
+	UNITS_BYTE,
+	UNITS_LINE,
+	UNITS_ITEM,
+	UNITS_DELIMITER,
+	UNITS_NR
+} units_type;
+
+typedef enum {
+	COMMAND_UNITS,
+	COMMAND_TYPE,
+	COMMAND_OFFSET,
+	COMMAND_LAST,
+	COMMAND_FIRST,
+	COMMAND_LEN,
+	COMMAND_NR
+} rng_command;
+
+typedef struct {
+	int comm;
+	ssize_t value;
+} rng_command_t;
+
+typedef struct val_range {
+	expr_common_t   h;
+	expr_v4_t *host;   // mast be not used - check and delete 17.06.05
+        size_t offset;      /* offset of read/write window for host object  */
+	size_t size;        /* size of read/write window for host object  */
+	int range_type;     /* type of window for lhs of assign operator:
+			     *
+			     * RANGE_CUT - on rhs the contens of window
+			     * replaced with the lhs expression.
+			     * Not depended for size of both side of assign operator.
+			     * the tail of target (outside of window), will be rewrite
+			     * to the end of new data.
+			     *
+			     * RANGE_ZERRO -if target size is smaller than source,
+			     * the rest bytes of source will be ignored
+			     *
+			     * RANGE_TRANSPARENT -if target size is smaller than source,
+			     * the rest bytes of source will  be ignored. Same as "zerro" */
+
+	int units_type;      /* 0 - byte
+			        1 - records
+				3 - delimiter (delimiter mast be specified)*/
+} val_range_t;
+
+struct reiser4_syscall_w_space;
+
+struct pars_var_value {
+	pars_var_value_t * prev;    /* previous value in stack for variable */
+	pars_var_value_t * next_level; /* next tmp value  in this level */
+	pars_var_t * host;          /* host variable structure for this value */
+	pars_var_t * associated;    /* var for associate the value */
+	int vtype;                  /* Type of value                       */
+	union {
+		lnode *ln;                  /* file/dir name lnode                 */
+		struct qstr *data;                 /*  ptr to data in mem (for result of assign) */
+	} u;
+	int count;                  /* ref counter                         */
+	int vSpace  ;               /* v4  space name or not ???           */
+	int vlevel  ;               /* level :     lives of the name       */
+	int (*destruct)(struct reiser4_syscall_w_space *, pars_var_value_t * );
+} ;
+
+typedef struct expr_lnode {
+	expr_common_t   h;
+	lnode  *lnode;
+} expr_lnode_t;
+
+typedef struct expr_flow {
+	expr_common_t    h;
+	flow_t     *   flw;
+} expr_flow_t;
+
+typedef struct expr_pars_var {
+	expr_common_t   h;
+	pars_var_t  *  v;
+} expr_pars_var_t;
+
+
+typedef struct expr_wrd {
+	expr_common_t   h;
+	wrd_t  *  s;
+} expr_wrd_t;
+
+#if 0
+typedef struct expr_op3 {
+	expr_common_t   h;
+	expr_v4_t  *  op;
+	expr_v4_t  *  op_l;
+	expr_v4_t  *  op_r;
+} expr_op3_t;
+#endif
+
+typedef struct expr_op2 {
+	expr_common_t   h;
+	expr_v4_t  *  op_l;
+	expr_v4_t  *  op_r;
+} expr_op2_t;
+
+typedef struct expr_op {
+	expr_common_t   h;
+	expr_v4_t  *  op;
+} expr_op_t;
+
+typedef struct expr_assign {
+	expr_common_t   h;
+	pars_var_t       *  target;
+	expr_v4_t       *  source;
+} expr_assign_t;
+
+typedef struct expr_list expr_list_t;
+struct expr_list {
+	expr_common_t   h;
+	expr_list_t     *  next;
+	expr_v4_t       *  source;
+} ;
+
+typedef enum {
+	EXPR_WRD,
+	EXPR_PARS_VAR,
+	EXPR_RANGE,
+	EXPR_LIST,
+	EXPR_ASSIGN,
+	EXPR_LNODE,
+	EXPR_FLOW,
+	//	EXPR_OP3,
+	EXPR_OP2,
+	EXPR_OP
+} expr_v4_type;
+
+union expr_v4 {
+	expr_common_t   h;
+	expr_wrd_t      wd;
+	val_range_t       rng;
+	expr_pars_var_t pars_var;
+	expr_list_t     list;
+        expr_assign_t   assgn;
+	expr_lnode_t    lnode;
+	expr_flow_t     flow;
+//	expr_op3_t      op3;
+	expr_op2_t      op2;
+	expr_op_t       op;
+};
+
+/* ok this is space for names, constants and tmp*/
+typedef struct free_space free_space_t;
+
+struct free_space {
+	free_space_t * free_space_next;                /* next buffer   */
+	char         * freeSpace;                      /* pointer to free space */
+	char         * freeSpaceMax;                   /* for overflow control */
+	char           freeSpaceBase[FREESPACESIZE];   /* current buffer */
+};
+
+struct sourece_stack {
+	sourece_stack_t * prev;
+	long type;                     /* type of current stack head */
+	union {
+		struct file   * file;
+		expr_v4_t     * expr;
+//		struct dentry * de;    /*  ??????? what for  */
+		wrd_t         * wd;
+		struct qstr   * qstr;
+		long          * pointer;
+	} u;
+};
+
+typedef struct streg  streg_t;
+
+struct streg {
+        streg_t * next;
+        streg_t * prev;
+	expr_v4_t * cur_exp;          /* current (pwd)  expression for this level */
+	expr_v4_t * wrk_exp;          /* current (work) expression for this level */
+	pars_var_value_t * val_level;
+	int stype;                  /* cur type of level        */
+	int level;                  /* cur level                */
+};
+
+
+static struct {
+	unsigned char numOfParam;
+	unsigned char typesOfParam[4]       ;
+} typesOfCommand[] = {
+	{0,{0,0,0,0}}
+};
+
+static struct {
+	void (*	call_function)(void) ;
+	unsigned char type;            /* describe parameters, and its types */
+} 	Code[] = {
+};
+
+
+/* Make Linus happy.
+   Local variables:
+   c-indentation-style: "K&R"
+   mode-name: "LC"
+   c-basic-offset: 8
+   tab-width: 8
+   fill-column: 120
+   End:
+*/
diff -puN /dev/null parser/parser_syntax.doc
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/parser_syntax.doc	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,389 @@
+SYS_REISER4 SYNTAX
+
+sys_reiser4() - system call executing a sequence of expressions upon
+the file-system(s).
+
+The expressions are specified by the user using a command string in a
+special language.
+
+The objects in the language are the FS objects,
+its metadata, plus temporary objects and "inline" data.
+
+The temporary objects are used for accessing and passing result
+without writing to the file system.
+
+"inline" data used in expressions as constant string for assign it to
+some object.
+
+The operation on these objects is:
+
+1 a plugins as lookup methods
+2 a concatenation operator "+"
+3 an assign operator.
+4 a condition (not yet working)
+
+The current implementation operator "+" is a scalar concatenation of
+the operands.
+
+Later it is possible to make the set operation between sets of objects:
+union, difference and multiple. condition operator, scalar and set patterns.
+
+for operate with foreign objects (objects of different file-systems )
+we can use only FS objects and tmp names.
+    
+for operate with reiser4 objects we have 3 case
+ file system object - directory and regular files
+ pseudo files - as element of reiser4 namespace for access to file-system metadata.
+               it can be founded by lookup plugin
+  tmp files -  for accessing and passing result in runtime .
+
+later it will be possible to store each pseudo name and its
+corresponding metadata in a reiser4 tree as an item with name and
+other attributes. Where default plugin is "..body" for access to the
+file body.
+
+While parsing the command string, the interpreter finds the lookup
+plugin and passes it the parameters.
+
+Another way to operate with objects is with the assign operator:
+
+object1 <- object2
+
+where object1 is lhv (target expression(name). )
+      object2 is rhv (source expression)
+
+All names in the expression are a sequence of names divided by "/" and
+called path as in the traditional path in UNIX systems.
+
+They can be a reference to the file system , or to metadata, or to a
+stream managed by an arbitrary method of the filesystem object, or to
+a tmp name.
+
+Assign as an expression has a value and can be used in rhv .  The it's
+value is a target name with it's all values.
+
+for example:
+A+(B<-C)+D
+where A, C and D is an expressions, B is a file.
+
+the value of this expression is value of expression A concatenated
+with value of file B after assign to it the expression C, and
+concatenated with expression D.
+this expression is equvalent to expressions:
+B<-C;A+B+D
+
+In current version the all expressions and target values is a scalar values.
+Later it is a possible use a set values on one (or both) part of assign.
+
+
+The Assign operator can have a name.
+
+For checking a result of assign (error code and length of written
+bytes) the assign operator can be have a name.  A name of an assign
+operator is a local name.(temporary name) It's lifetime is limited to
+surrounding brackets or the end of the command string.
+
+The local names.
+Any name has a runtime stack of values.
+
+1. If we use name from FS only, the stack of this name will have only
+   one value: lnode, corresponding to its name in the FS. (for foreign
+   objects this is a dentry lnode)
+   This name isn't a local name. It's lifetime is depended on the FS
+   and isn't limited to surrounding brackets or the end of the command
+   string.
+
+2. If we use a name not from the FS, the stack will have one local
+   (TMP) value. The user mast be care for its value. Because the
+   omitted value in rhv isn't an error. It's interpreting as an empty
+   value. The value for this type name can be assigned by assign
+   operator only.
+   It's lifetime is limited to surrounding brackets or the end of the
+   command string.
+
+3. If we use named assign, the current value, if it exist, pushed to
+  stack and new value created for this local name.
+  This name will have 2 special child names for length and error code
+  of assign:
+  assign_result and assign_length.
+  Lifetime of these 3 names is limited to surrounding brackets or the
+  end of the command string.
+
+
+The current implementation has 2 ways for performing named assign:
+
+1. the name declared in assign operation with <= operator.
+example:
+
+name<=A<-B
+
+It means we read expression B, if file A exist, we overwrite it with
+the contents of expression B.
+
+If object A does not exist in the FS, then we create local name "A" as
+a child of the current path, and then associate the contents of
+expression B with the created name ("A").  Then this name and its
+associated value (contents of expression B) can be used in any
+expression as a regular object of FS.
+
+Then created local "name" as a child of current path.  If the "name"
+exist as a child of current path or as a FS object, it's value will be
+pushed to the stack and create new one.  Then created local subnames
+"assign_result" and "assign_length" as a child of "name" for storing
+result of assign operator.
+
+
+For example:
+
+Suppose, we have 5 files in FS: a, b1, b2, c, d.
+
+"rez<=a<-b1+b2; c<-rez/assign_result; d<-rez/assign_length"
+
+file a will have concatenated contents of files b1 and b2;
+file c will have the error code of assign;
+file d will have the length of written bytes.
+
+If we have the "rez" file in FS. It contents will not be changed.
+local name "rez" will be free and its subnames and contents will free
+too.  
+
+
+2. The name for assign result used a target name.
+A<-B
+
+created local subnames "assign_result" and "assign_length" as a child
+of object A for storing result of assign operator.
+
+for example
+
+Suppose, we have 5 files in FS: a, b1, b2, c, d.
+
+"a<-b1+b2; c<-a/assign_result; d<-a/assign_length"
+
+file a will have concatenated contents of files b1 and b2;
+file c will have the error code of assign;
+file d will have the length of written bytes
+
+local names "assign_result" and "assign_length" will be free and its
+contents will be free too.  But name "a" will exist as object of the FS.
+
+
+
+creations objects.
+
+
+lets consider the following.
+
+We want create a regular file with name
+"new_file_name" in directory "b" with ACL for uid=357 - denied and
+copy to it the contents of /etc/passwd.
+ 
+command_string="b/(.../new/(name<-\"new_file_name\"; type<-regular_file; permition<-acl); new_file_name/.../acl/( uid<-\"357\", access<-denied );new_file_name<-/etc/passwd)";
+
+where:
+  b is a directory
+suppose we have lnode for it.
+(if it is ommited ("b") then we take the current directory PWD, and take the lnode for it)
+Then we make:
+b_lnode->lookup(new)
+it that meen we find lnode for directory plugin "new"
+    all parameters in new plugin will be filled by default.
+    and then we find new_lnode->lookup(name). this is lnode for name of new file and we assign to it string constant "new_file_name".
+
+    then we find new_lnode->lookup(type). this is lnode of type of new file
+    then we find new_lnode->lookup(regular_file) this is lnode of constants (plugin id) of types of plugin "new" for regular file
+    then we copy contens regular_file_lnode  to type_lnode. ()
+
+    then we find new_lnode->lookup(permition). this is lnode of type of permition of new file
+    then we find new_lnode->lookup(acl). this is lnode of constants of type of permition of "new" plugin, correcponding to acl
+    then we copy contens acl_lnode throuse tube to permition_lnode.
+
+the next symbol in command string is a ")". by default it mean "create" object with all parameters, what we are fielded.
+
+now we have the "b/new_name_file" object in FS. This is a regular file with acl permition type.
+Let's go ahead.
+
+then we find b_lnode->lookup(new_file_name). this is lnode for new file we jast created.
+then we find new_file_name_lnode->lookup(acl) . this is lnode of acl plugin .
+    then we find acl_lnode->lookup(uid) this is lnode for uid field of acl and assign (append) to it string constant "357".???????this is a list of uid
+    then we find acl_lnode->lookup(access).
+    then we find acl_lnode->lookup(denied).
+    then we copy contens denied_lnode (This is plugin id) to access_lnode.
+
+then we find root_lnode->lookup(etc),
+then we find etc_lnode->lookup(passwd)
+then we read contens passwd_lnode throuse tube and write to new_file_name_lnode lnode.
+
+ok. command string is executed.
+
+
+
+the range plugin, current directory, analog of cd(1)
+
+lets consider the following
+command_string="/path0/path1/filename/.../range/(offset<-\"100\",last_byte<-\"256\")<-/path0/path2/filename/.../range/(first_byte<-\"100\")";
+
+the both operand have eq part of path: "/path0". we can to put it as a
+multiplier outside the brackets:
+
+command_string="/path0/(path1/filename/.../range/(offset<-\"100\",last_byte<-\"256\")<-path2/filename/.../range/(first_byte<-\"100\"))";
+
+the first part of path: /path0 is looks like cd(1) operator. One
+exclusion: after finishing this command the current work directory
+will be same as before.
+The both operand in expression
+
+(path1/filename/.../range/(offset<-\"100\",last_byte<-\"256\")<-path2/filename/.../range/(first_byte<-\"100\")
+
+has as a current directory = /path0.
+
+All operand in expression
+(offset<-\"100\",last_byte<-\"256\")
+has  the 
+/path0/path1/filename/.../range
+as a current logical directory.
+the
+offset<-\"100\",last_byte<-\"256\"
+sets the parameters of range plugin for make a window of parent object.
+
+In this example we write to file
+/path0/path1/filename from offset 100 (in decimal) up to 256 (in decimal) no more.
+Variant 1:
+If source is smaller of this size, the last bytes of target window will be set to 0.
+If source is larger of this size, the rest bytes will be ignored.
+Variant 2:
+If source is smaller of this size, the last bytes of target window will not change.
+If source is larger of this size, the rest bytes will be ignored.
+Variant 3:
+If source is smaller of this size or larger, the tail of target will be shifted to end of assigned data.
+(The defined window in target will be overload by defined window of source.)
+(example:is source length is 0 the target will be cut the defined window, If target window size is 0, the source will inserted.)
+
+if last_byte or length is ommited, the source will be read up to end of file.
+(if it possible. for example: the /process will not ended by eof. in this case the 1 page size will be read)
+
+
+
+
+
+
+
+
+the user space access.
+The operand
+
+/.../process/range/(offset<-\"200\",last_byte<-\"256\")
+
+ make the access from/to the buffer starting at address offset in
+ the process address space, ending at last_byte. The number of bytes
+ actually read/write (assignment source may be smaller or larger than
+ assignment target) is written to assign_length and error code to an
+ assign_result with common negotiate of tmp names.
+
+
+
+
+list of pseudo plugins and its description
+
+new                     the parent's "dir" plugin.
+                        invoke is delayed: the "/( new_expression )" expression mast be followed.
+                        if it ommited the default values for all parameters will be used.
+                        if we need use something different from defaults, we need define it inside the brackets.
+                        the creation will be begin after the corresponding ")" will parsed.
+                        the result is a created file.
+                        can be used as rhs and lhs of assign operator.
+
+    name                "new" plugin name space. the name of created object, mast be target with assign operator.
+                        the default value will be generated as a special unique name for current directory.??? Is it possible.
+                        the result is a name.
+    type                "new" plugin name space. the type of created object, mast be target with assign operator.
+                        operator for created object. The default value is "regular_file".
+                        the result is a type.
+        regular_file    "type" plugin name space. the possible values for parent plugin "type"
+        directory       "type" plugin name space. the possible values for parent plugin "type"
+        
+    permition           new plugin name space. the permition type  of created object, mast be target with assign operator.
+        acl             permition plugin name space. the possible values for parent plugin permition
+        
+
+
+uid                     the parent's object plugin.
+                        the result is a pseudo file, body contain the uid of parent object.
+                        can be used as rhs and lhs of assign operator.
+
+qid                     the parent's object plugin.
+                        the result is a pseudo file, body contain the qid of parent object.
+                        can be used as rhs and lhs of assign operator.
+
+rwx                     the parent's object plugin.
+                        the result is a pseudo file, body contain the rwx of parent object.
+                        can be used as rhs and lhs of assign operator.
+
+oid                     the parent's object plugin.
+                        the result is a pseudo file, body contain the oid of parent object.
+                        can be used as rhs of assign operator.
+
+key                     the parent's object plugin.
+                        the result is a pseudo file, body contain the uid of parent object.
+                        can be used as  rhs of assign operator.
+
+size                    the parent's object plugin.
+                        the result is a pseudo file, body contain the size of parent object.
+                        can be used as  rhs of assign operator.
+
+name                    the parent's object plugin.
+                        the result is a pseudo file, body contain the name of parent object.
+                        can be used as  rhs and lhs of assign operator.
+
+                        when the "name" used on lhs its equal to rename(1).
+
+
+acl
+    gid
+    uid
+    access
+        denied
+
+rename                  the parent's "dir" plugin
+                        the result is a same object but with new name
+    name                the name of object to be renamed
+    newname             the new name of object
+
+unlink                  the parent's "dir" plugin
+    name                the name of object to be unliked
+
+link                    make a link
+    name                the name of object to be linked
+    linkname            the link name
+    linktype            the type of link
+        symlink
+        hardlink
+
+
+range                   the parent object plugin.
+                        This is a window to object starting from offset|first_byte ended to last_byte|(offset+length)
+                        can't be used without the parent object
+                        don't have the return value, but change the parent value.
+                        can used with any object, constants, strings etc.
+
+    offset              starting offset for window
+
+    first_byte          starting offset for window
+
+    length              size of window
+
+    last_byte           ending offset for window
+
+lookup                  the plugin for find the subnames and it's type
+                        parameters : lnode *parent,qstr *name
+                        return: lnode *founded_name 
+
+
+
+# Local variables:
+# mode-name: "proposal"
+# indent-tabs-mode: nil
+# tab-width: 4
+# eval: (if (fboundp 'flyspell-mode) (flyspell-mode))
+# End:
+
diff -puN /dev/null parser/parser.tab.c
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/parser.tab.c	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,1658 @@
+/* A Bison parser, made by GNU Bison 1.875.  */
+
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* Written by Richard Stallman by simplifying the original so called
+   ``semantic'' parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc_reiser4.c"
+
+/* Pure parsers.  */
+#define YYPURE 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 1
+
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     TRANSCRASH = 258,
+     SEMICOLON = 259,
+     COMMA = 260,
+     L_ASSIGN = 261,
+     L_APPEND = 262,
+     L_SYMLINK = 263,
+     PLUS = 264,
+     L_BRACKET = 265,
+     R_BRACKET = 266,
+     SLASH = 267,
+     PROCESS = 268,
+     INV_L = 269,
+     INV_R = 270,
+     EQ = 271,
+     NE = 272,
+     LE = 273,
+     GE = 274,
+     LT = 275,
+     GT = 276,
+     IS = 277,
+     AND = 278,
+     OR = 279,
+     P_RUNNER = 280,
+     NOT = 281,
+     IF = 282,
+     THEN = 283,
+     ELSE = 284,
+     EXIST = 285,
+     NAME = 286,
+     UNNAME = 287,
+     NAMED = 288,
+     WORD = 289,
+     STRING_CONSTANT = 290,
+     ROOT = 291,
+     RANGE = 292,
+     OFFSET = 293,
+     LASTBYTE = 294,
+     FIRSTBYTE = 295,
+     LENGTH = 296,
+     UNITS = 297,
+     BYTE = 298,
+     LINE = 299,
+     ITEM = 300,
+     CUT = 301,
+     ZERRO = 302,
+     TRANSPARENT = 303
+   };
+#endif
+#define TRANSCRASH 258
+#define SEMICOLON 259
+#define COMMA 260
+#define L_ASSIGN 261
+#define L_APPEND 262
+#define L_SYMLINK 263
+#define PLUS 264
+#define L_BRACKET 265
+#define R_BRACKET 266
+#define SLASH 267
+#define PROCESS 268
+#define INV_L 269
+#define INV_R 270
+#define EQ 271
+#define NE 272
+#define LE 273
+#define GE 274
+#define LT 275
+#define GT 276
+#define IS 277
+#define AND 278
+#define OR 279
+#define P_RUNNER 280
+#define NOT 281
+#define IF 282
+#define THEN 283
+#define ELSE 284
+#define EXIST 285
+#define NAME 286
+#define UNNAME 287
+#define NAMED 288
+#define WORD 289
+#define STRING_CONSTANT 290
+#define ROOT 291
+#define RANGE 292
+#define OFFSET 293
+#define LASTBYTE 294
+#define FIRSTBYTE 295
+#define LENGTH 296
+#define UNITS 297
+#define BYTE 298
+#define LINE 299
+#define ITEM 300
+#define CUT 301
+#define ZERRO 302
+#define TRANSPARENT 303
+
+
+
+
+/* Copy the first part of user declarations.  */
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+#line 15 "fs/reiser4/parser/parser.y"
+typedef union YYSTYPE {
+	long charType;
+	expr_v4_t * expr;
+	wrd_t * wrd;
+//	val_range_t * rng;
+	rng_command_t * rng_com;
+} YYSTYPE;
+/* Line 191 of yacc.c.  */
+#line 180 "fs/reiser4/parser/parser.tab.c"
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+#if ! defined (YYLTYPE) && ! defined (YYLTYPE_IS_DECLARED)
+typedef struct YYLTYPE
+{
+  int first_line;
+  int first_column;
+  int last_line;
+  int last_column;
+} YYLTYPE;
+# define yyltype YYLTYPE /* obsolescent; will be withdrawn */
+# define YYLTYPE_IS_DECLARED 1
+# define YYLTYPE_IS_TRIVIAL 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+#line 23 "fs/reiser4/parser/parser.y"
+
+//#include "lib.c"
+
+
+/* Line 214 of yacc.c.  */
+#line 207 "fs/reiser4/parser/parser.tab.c"
+
+#  define YYSTACK_ALLOC(size) kmalloc((size),GFP_KERNEL)
+
+#   define YYSIZE_T size_t
+
+#  define YYSTACK_FREE kfree
+
+
+
+#if (! defined (yyoverflow) \
+     && (! defined (__cplusplus) \
+	 || (YYLTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  short yyss_1;
+  YYSTYPE yyvs_1;
+    YYLTYPE yyls_1;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short) + sizeof (YYSTYPE) + sizeof (YYLTYPE))	\
+      + 2 * YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  register YYSIZE_T yyi;		\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (0)
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+void * YYSTACK_RELOCATE(void *Stack, int old_size, int new_size)
+{
+void * ptr;
+ptr = kmalloc(new_size, GFP_KERNEL);
+memcpy(ptr, Stack, old_size);
+kfree(Stack);
+Stack=ptr;
+return (ptr);
+}
+#endif
+
+#if defined (__STDC__) || defined (__cplusplus)
+   typedef signed char yysigned_char;
+#else
+   typedef short yysigned_char;
+#endif
+
+/* YYFINAL -- State number of the termination state. */
+#define YYFINAL  18
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   126
+
+/* YYNTOKENS -- Number of terminals. */
+#define YYNTOKENS  49
+/* YYNNTS -- Number of nonterminals. */
+#define YYNNTS  20
+/* YYNRULES -- Number of rules. */
+#define YYNRULES  57
+/* YYNRULES -- Number of states. */
+#define YYNSTATES  96
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   303
+
+#define YYTRANSLATE(YYX) 						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const unsigned char yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const unsigned char yyprhs[] =
+{
+       0,     0,     3,     5,     7,     9,    12,    15,    19,    23,
+      27,    29,    33,    37,    43,    47,    52,    55,    58,    60,
+      63,    66,    70,    74,    78,    82,    86,    90,    94,    98,
+     101,   103,   107,   109,   113,   118,   121,   125,   127,   128,
+     130,   134,   140,   142,   145,   148,   151,   153,   155,   157,
+     159,   161,   163,   165,   167,   169,   171,   173
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS. */
+static const yysigned_char yyrhs[] =
+{
+      50,     0,    -1,    51,    -1,    58,    -1,    35,    -1,    32,
+      51,    -1,    31,    51,    -1,    51,     9,    51,    -1,    51,
+       4,    51,    -1,    51,     5,    51,    -1,    52,    -1,    57,
+       6,    51,    -1,    57,     7,    51,    -1,    57,     6,    14,
+      51,    15,    -1,    57,     8,    51,    -1,    53,    56,    29,
+      51,    -1,    53,    56,    -1,    54,    55,    -1,    27,    -1,
+      26,    51,    -1,    30,    51,    -1,    51,    16,    51,    -1,
+      51,    17,    51,    -1,    51,    18,    51,    -1,    51,    19,
+      51,    -1,    51,    20,    51,    -1,    51,    21,    51,    -1,
+      51,    24,    51,    -1,    51,    23,    51,    -1,    28,    51,
+      -1,    58,    -1,    58,    33,    58,    -1,    59,    -1,    59,
+      12,    62,    -1,    12,    13,    12,    62,    -1,    60,    61,
+      -1,    59,    12,    61,    -1,    12,    -1,    -1,    34,    -1,
+      68,    51,    11,    -1,    37,    12,    68,    63,    11,    -1,
+      64,    -1,    63,    64,    -1,    65,    35,    -1,    42,    66,
+      -1,    67,    -1,    38,    -1,    39,    -1,    40,    -1,    41,
+      -1,    43,    -1,    44,    -1,    45,    -1,    46,    -1,    47,
+      -1,    48,    -1,    10,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const unsigned char yyrline[] =
+{
+       0,   104,   104,   108,   109,   110,   111,   113,   114,   115,
+     116,   118,   119,   120,   121,   130,   131,   135,   140,   144,
+     145,   146,   147,   148,   149,   150,   151,   152,   153,   157,
+     161,   162,   166,   167,   168,   172,   173,   177,   178,   182,
+     183,   187,   191,   192,   196,   197,   198,   202,   203,   204,
+     205,   208,   209,   210,   214,   215,   216,   220
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE
+/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "TRANSCRASH", "SEMICOLON", "COMMA", 
+  "L_ASSIGN", "L_APPEND", "L_SYMLINK", "PLUS", "L_BRACKET", "R_BRACKET", 
+  "SLASH", "PROCESS", "INV_L", "INV_R", "EQ", "NE", "LE", "GE", "LT", 
+  "GT", "IS", "AND", "OR", "P_RUNNER", "NOT", "IF", "THEN", "ELSE", 
+  "EXIST", "NAME", "UNNAME", "NAMED", "WORD", "STRING_CONSTANT", "ROOT", 
+  "RANGE", "OFFSET", "LASTBYTE", "FIRSTBYTE", "LENGTH", "UNITS", "BYTE", 
+  "LINE", "ITEM", "CUT", "ZERRO", "TRANSPARENT", "$accept", "reiser4", 
+  "Expression", "if_statement", "if_Begin", "if", "if_Expression", 
+  "then_operation", "target", "Object_Name", "o_name", "begin_from", 
+  "name", "range", "range_expression", "range_command", "rng_key", 
+  "rng_units", "rng_type", "level_up", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const unsigned short yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,   299,   300,   301,   302,   303
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const unsigned char yyr1[] =
+{
+       0,    49,    50,    51,    51,    51,    51,    51,    51,    51,
+      51,    51,    51,    51,    51,    52,    52,    53,    54,    55,
+      55,    55,    55,    55,    55,    55,    55,    55,    55,    56,
+      57,    57,    58,    58,    58,    59,    59,    60,    60,    61,
+      61,    62,    63,    63,    64,    64,    64,    65,    65,    65,
+      65,    66,    66,    66,    67,    67,    67,    68
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const unsigned char yyr2[] =
+{
+       0,     2,     1,     1,     1,     2,     2,     3,     3,     3,
+       1,     3,     3,     5,     3,     4,     2,     2,     1,     2,
+       2,     3,     3,     3,     3,     3,     3,     3,     3,     2,
+       1,     3,     1,     3,     4,     2,     3,     1,     0,     1,
+       3,     5,     1,     2,     2,     2,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const unsigned char yydefact[] =
+{
+      38,    37,    18,    38,    38,     4,     0,     2,    10,     0,
+      38,     0,     3,    32,     0,     0,     6,     5,     1,    38,
+      38,    38,    38,    16,    38,    38,     0,    17,    38,    38,
+      38,    38,     0,    57,    39,    35,    38,     0,     8,     9,
+       7,    29,    38,    19,    20,    38,    38,    38,    38,    38,
+      38,    38,    38,    38,    11,    12,    14,    31,     0,    36,
+      33,     0,    34,    15,    21,    22,    23,    24,    25,    26,
+      28,    27,     0,     0,    40,    13,     0,    47,    48,    49,
+      50,     0,    54,    55,    56,     0,    42,     0,    46,    51,
+      52,    53,    45,    41,    43,    44
+};
+
+/* YYDEFGOTO[NTERM-NUM]. */
+static const yysigned_char yydefgoto[] =
+{
+      -1,     6,     7,     8,     9,    10,    27,    23,    11,    12,
+      13,    14,    35,    60,    85,    86,    87,    92,    88,    36
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -23
+static const yysigned_char yypact[] =
+{
+      56,    -8,   -23,    56,    56,   -23,     6,    32,   -23,   -19,
+      44,     5,    -4,     2,     0,     3,   -23,   -23,   -23,    56,
+      56,    56,    56,    -9,    56,    56,    85,   -23,    50,    56,
+      56,    11,    -2,   -23,   -23,   -23,    56,    -7,    19,    19,
+     -23,   -23,    56,    32,    32,    56,    56,    56,    56,    56,
+      56,    56,    56,    56,    19,    19,    19,   -23,    26,   -23,
+     -23,    88,   -23,   -23,    32,    32,    32,    32,    32,    32,
+      32,    32,   106,    21,   -23,   -23,    78,   -23,   -23,   -23,
+     -23,    22,   -23,   -23,   -23,    13,   -23,    23,   -23,   -23,
+     -23,   -23,   -23,   -23,   -23,   -23
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yysigned_char yypgoto[] =
+{
+     -23,   -23,    -3,   -23,   -23,   -23,   -23,   -23,   -23,     9,
+     -23,   -23,    25,    35,   -23,   -22,   -23,   -23,   -23,     7
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -31
+static const yysigned_char yytable[] =
+{
+      16,    17,   -30,   -30,   -30,    15,    18,    26,    33,    22,
+      33,    28,    29,    30,    32,    37,    38,    39,    40,    41,
+      42,    43,    44,     1,    93,    54,    55,    56,    21,    31,
+      58,    33,    34,    61,    34,    58,    19,    20,    73,    63,
+      57,    21,    64,    65,    66,    67,    68,    69,    70,    71,
+      72,    77,    78,    79,    80,    81,     1,    59,    95,    82,
+      83,    84,     1,    94,    53,    89,    90,    91,     1,     0,
+      24,     2,    62,     0,    25,     3,     4,     2,     0,     5,
+      76,     3,     4,     2,     0,     5,     0,     3,     4,    19,
+      20,     5,    19,    20,    21,     0,     0,    21,     0,    74,
+       0,    45,    46,    47,    48,    49,    50,     0,    51,    52,
+      19,    20,     0,     0,     0,    21,    77,    78,    79,    80,
+      81,    75,     0,     0,    82,    83,    84
+};
+
+static const yysigned_char yycheck[] =
+{
+       3,     4,     6,     7,     8,    13,     0,    10,    10,    28,
+      10,     6,     7,     8,    12,    12,    19,    20,    21,    22,
+      29,    24,    25,    12,    11,    28,    29,    30,     9,    33,
+      37,    10,    34,    36,    34,    37,     4,     5,    12,    42,
+      31,     9,    45,    46,    47,    48,    49,    50,    51,    52,
+      53,    38,    39,    40,    41,    42,    12,    32,    35,    46,
+      47,    48,    12,    85,    14,    43,    44,    45,    12,    -1,
+      26,    27,    37,    -1,    30,    31,    32,    27,    -1,    35,
+      73,    31,    32,    27,    -1,    35,    -1,    31,    32,     4,
+       5,    35,     4,     5,     9,    -1,    -1,     9,    -1,    11,
+      -1,    16,    17,    18,    19,    20,    21,    -1,    23,    24,
+       4,     5,    -1,    -1,    -1,     9,    38,    39,    40,    41,
+      42,    15,    -1,    -1,    46,    47,    48
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const unsigned char yystos[] =
+{
+       0,    12,    27,    31,    32,    35,    50,    51,    52,    53,
+      54,    57,    58,    59,    60,    13,    51,    51,     0,     4,
+       5,     9,    28,    56,    26,    30,    51,    55,     6,     7,
+       8,    33,    12,    10,    34,    61,    68,    12,    51,    51,
+      51,    51,    29,    51,    51,    16,    17,    18,    19,    20,
+      21,    23,    24,    14,    51,    51,    51,    58,    37,    61,
+      62,    51,    62,    51,    51,    51,    51,    51,    51,    51,
+      51,    51,    51,    12,    11,    15,    68,    38,    39,    40,
+      41,    42,    46,    47,    48,    63,    64,    65,    67,    43,
+      44,    45,    66,    11,    64,    35
+};
+
+#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
+# define YYSIZE_T __SIZE_TYPE__
+#endif
+#if ! defined (YYSIZE_T) && defined (size_t)
+# define YYSIZE_T size_t
+#endif
+#if ! defined (YYSIZE_T)
+# if defined (__STDC__) || defined (__cplusplus)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# endif
+#endif
+#if ! defined (YYSIZE_T)
+# define YYSIZE_T unsigned int
+#endif
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrlab1
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK;						\
+      goto yybackup;						\
+    }								\
+  else								\
+    { 								\
+      yyerror ("syntax error: cannot back up");\
+      YYERROR;							\
+    }								\
+while (0)
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+/* YYLLOC_DEFAULT -- Compute the default location (before the actions
+   are run).  */
+
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)         \
+  Current.first_line   = Rhs[1].first_line;      \
+  Current.first_column = Rhs[1].first_column;    \
+  Current.last_line    = Rhs[N].last_line;       \
+  Current.last_column  = Rhs[N].last_column;
+#endif
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (&yylval, &yylloc, YYLEX_PARAM)
+#else
+# define YYLEX yylex (&yylval, &yylloc)
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+
+#ifndef fprintf
+#define fprintf printk
+#endif
+
+# ifndef YYFPRINTF
+//#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (0)
+
+# define YYDSYMPRINT(Args)			\
+do {						\
+  if (yydebug)					\
+    yysymprint Args;				\
+} while (0)
+
+# define YYDSYMPRINTF(Title, Token, Value, Location)		\
+do {								\
+  if (yydebug)							\
+    {								\
+      YYFPRINTF ( "%s ", Title);				\
+      yysymprint ( Token, Value, Location);	\
+      YYFPRINTF ( "\n");					\
+    }								\
+} while (0)
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (cinluded).                                                   |
+`------------------------------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yy_stack_print (short *bottom, short *top)
+#else
+static void
+yy_stack_print (bottom, top)
+    short *bottom;
+    short *top;
+#endif
+{
+  YYFPRINTF ( "Stack now");
+  for (/* Nothing. */; bottom <= top; ++bottom)
+    YYFPRINTF ( " %d", *bottom);
+  YYFPRINTF ( "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yy_reduce_print (int yyrule)
+#else
+static void
+yy_reduce_print (yyrule)
+    int yyrule;
+#endif
+{
+  int yyi;
+  unsigned int yylineno = yyrline[yyrule];
+  YYFPRINTF ( "Reducing stack by rule %d (line %u), ",
+             yyrule - 1, yylineno);
+  /* Print the symbols being reduced, and their result.  */
+  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
+    YYFPRINTF ( "%s ", yytname [yyrhs[yyi]]);
+  YYFPRINTF ( "-> %s\n", yytname [yyr1[yyrule]]);
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (Rule);		\
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YYDSYMPRINT(Args)
+# define YYDSYMPRINTF(Title, Token, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#if YYMAXDEPTH == 0
+# undef YYMAXDEPTH
+#endif
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined (__GLIBC__) && defined (_STRING_H)
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+#   if defined (__STDC__) || defined (__cplusplus)
+yystrlen (const char *yystr)
+#   else
+yystrlen (yystr)
+     const char *yystr;
+#   endif
+{
+  register const char *yys = yystr;
+
+  while (*yys++ != '\0')
+    continue;
+
+  return yys - yystr - 1;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+#   if defined (__STDC__) || defined (__cplusplus)
+yystpcpy (char *yydest, const char *yysrc)
+#   else
+yystpcpy (yydest, yysrc)
+     char *yydest;
+     const char *yysrc;
+#   endif
+{
+  register char *yyd = yydest;
+  register const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+#endif /* !YYERROR_VERBOSE */
+
+
+
+#if YYDEBUG
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yysymprint (int yytype, YYSTYPE *yyvaluep, YYLTYPE *yylocationp)
+#else
+static void
+yysymprint (yytype, yyvaluep, yylocationp)
+    int yytype;
+    YYSTYPE *yyvaluep;
+    YYLTYPE *yylocationp;
+#endif
+{
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvaluep;
+  (void) yylocationp;
+
+  if (yytype < YYNTOKENS)
+    {
+      YYFPRINTF ( "token %s (", yytname[yytype]);
+# ifdef YYPRINT
+      YYPRINT ( yytoknum[yytype], *yyvaluep);
+# endif
+    }
+  else
+    YYFPRINTF ( "nterm %s (", yytname[yytype]);
+
+  switch (yytype)
+    {
+      default:
+        break;
+    }
+  YYFPRINTF ( ")");
+}
+
+#endif /* ! YYDEBUG */
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yydestruct (int yytype, YYSTYPE *yyvaluep, YYLTYPE *yylocationp)
+#else
+static void
+yydestruct (yytype, yyvaluep, yylocationp)
+    int yytype;
+    YYSTYPE *yyvaluep;
+    YYLTYPE *yylocationp;
+#endif
+{
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvaluep;
+  (void) yylocationp;
+
+  switch (yytype)
+    {
+
+      default:
+        break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+
+int yyparse (YYPARSE_PARAM);
+
+
+
+
+
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+static
+int yyparse (YYPARSE_PARAM)
+{
+  /* The lookahead symbol.  */
+
+int yychar;
+
+
+/* The semantic value of the lookahead symbol.  */
+/*
+YYSTYPE yylval;
+*/
+
+/* Number of syntax errors so far.  */
+
+  int yynerrs;
+
+
+
+/* Location data for the lookahead symbol.  */
+YYLTYPE yylloc;
+
+  register int yystate;
+  register int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  short	yyssa[YYINITDEPTH];
+  yyss = yyssa;
+/*  
+  short *yyss = yyssa;
+  register short *yyssp;
+*/
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  yyvs = yyvsa;
+/*
+  YYSTYPE *yyvs = yyvsa;
+  register YYSTYPE *yyvsp;
+*/
+
+  /* The location stack.  */
+  YYLTYPE yylsa[YYINITDEPTH];
+  yyls = yylsa;
+/*  YYLTYPE *yyls = yylsa;
+    YYLTYPE *yylsp;*/
+  YYLTYPE *yylerrsp;
+
+#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+/*  YYSTYPE yyval;*/
+  YYLTYPE yyloc;
+
+  /* When reducing, the number of symbols on the RHS of the reduced
+     rule.  */
+  int yylen;
+
+  YYDPRINTF (("Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+  yylsp = yyls;
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed. so pushing a state here evens the stacks.
+     */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack. Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	short *yyss1 = yyss;
+	YYLTYPE *yyls1 = yyls;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow ("parser stack overflow",
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yyls1, yysize * sizeof (*yylsp),
+		    &yystacksize);
+	yyls = yyls1;
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyoverflowlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyoverflowlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	short *yyss1 = yyss;
+/*
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyoverflowlab;
+*/
+	YYSTACK_RELOCATE (yyss,YYSIZE,YYSTACKSIZE);
+	YYSTACK_RELOCATE (yyvs,YYSIZE,YYSTACKSIZE);
+	YYSTACK_RELOCATE (yyls,YYSIZE,YYSTACKSIZE);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+      yylsp = yyls + yysize - 1;
+
+      YYDPRINTF (( "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF (( "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+/* Do appropriate processing given the current state.  */
+/* Read a lookahead token if we need one and don't already have one.  */
+/* yyresume: */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF (( "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF (( "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Shift the lookahead token.  */
+  YYDPRINTF (( "Shifting token %s, ", yytname[yytoken]));
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  *++yyvsp = yylval;
+  *++yylsp = yylloc;
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+  /* Default location. */
+  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 2:
+#line 104 "fs/reiser4/parser/parser.y"
+    { yyval.charType = free_expr( ws, yyvsp[0].expr ); ;}
+    break;
+
+  case 3:
+#line 108 "fs/reiser4/parser/parser.y"
+    { yyval.expr = yyvsp[0].expr;;}
+    break;
+
+  case 4:
+#line 109 "fs/reiser4/parser/parser.y"
+    { yyval.expr = const_to_expr( ws, yyvsp[0].wrd ); ;}
+    break;
+
+  case 5:
+#line 110 "fs/reiser4/parser/parser.y"
+    { yyval.expr = unname( ws, yyvsp[0].expr ); ;}
+    break;
+
+  case 6:
+#line 111 "fs/reiser4/parser/parser.y"
+    { yyval.expr = name( ws, yyvsp[0].expr ); ;}
+    break;
+
+  case 7:
+#line 113 "fs/reiser4/parser/parser.y"
+    { yyval.expr = concat_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); ;}
+    break;
+
+  case 8:
+#line 114 "fs/reiser4/parser/parser.y"
+    { yyval.expr = list_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); ;}
+    break;
+
+  case 9:
+#line 115 "fs/reiser4/parser/parser.y"
+    { yyval.expr = list_async_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); ;}
+    break;
+
+  case 10:
+#line 116 "fs/reiser4/parser/parser.y"
+    { yyval.expr = yyvsp[0].expr; level_down( ws, IF_STATEMENT, IF_STATEMENT ); ;}
+    break;
+
+  case 11:
+#line 118 "fs/reiser4/parser/parser.y"
+    { yyval.expr = assign( ws, yyvsp[-2].expr, yyvsp[0].expr, O_TRUNC ); ;}
+    break;
+
+  case 12:
+#line 119 "fs/reiser4/parser/parser.y"
+    { yyval.expr = assign( ws, yyvsp[-2].expr, yyvsp[0].expr, O_APPEND ); ;}
+    break;
+
+  case 13:
+#line 120 "fs/reiser4/parser/parser.y"
+    { yyval.expr = assign_invert( ws, yyvsp[-4].expr, yyvsp[-1].expr ); ;}
+    break;
+
+  case 14:
+#line 121 "fs/reiser4/parser/parser.y"
+    { yyval.expr = symlink( ws, yyvsp[-2].expr, yyvsp[0].expr ); ;}
+    break;
+
+  case 15:
+#line 130 "fs/reiser4/parser/parser.y"
+    { yyval.expr = if_then_else( ws, yyvsp[-3].expr, yyvsp[-2].expr, yyvsp[0].expr ); ;}
+    break;
+
+  case 16:
+#line 131 "fs/reiser4/parser/parser.y"
+    { yyval.expr = if_then( ws, yyvsp[-1].expr, yyvsp[0].expr) ;         ;}
+    break;
+
+  case 17:
+#line 135 "fs/reiser4/parser/parser.y"
+    { yyval.expr = yyvsp[0].expr; ;}
+    break;
+
+  case 18:
+#line 140 "fs/reiser4/parser/parser.y"
+    { level_up( ws, IF_STATEMENT ); ;}
+    break;
+
+  case 19:
+#line 144 "fs/reiser4/parser/parser.y"
+    { yyval.expr = not_expression( ws, yyvsp[0].expr ); ;}
+    break;
+
+  case 20:
+#line 145 "fs/reiser4/parser/parser.y"
+    { yyval.expr = check_exist( ws, yyvsp[0].expr ); ;}
+    break;
+
+  case 21:
+#line 146 "fs/reiser4/parser/parser.y"
+    { yyval.expr = compare_EQ_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); ;}
+    break;
+
+  case 22:
+#line 147 "fs/reiser4/parser/parser.y"
+    { yyval.expr = compare_NE_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); ;}
+    break;
+
+  case 23:
+#line 148 "fs/reiser4/parser/parser.y"
+    { yyval.expr = compare_LE_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); ;}
+    break;
+
+  case 24:
+#line 149 "fs/reiser4/parser/parser.y"
+    { yyval.expr = compare_GE_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); ;}
+    break;
+
+  case 25:
+#line 150 "fs/reiser4/parser/parser.y"
+    { yyval.expr = compare_LT_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); ;}
+    break;
+
+  case 26:
+#line 151 "fs/reiser4/parser/parser.y"
+    { yyval.expr = compare_GT_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); ;}
+    break;
+
+  case 27:
+#line 152 "fs/reiser4/parser/parser.y"
+    { yyval.expr = compare_OR_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); ;}
+    break;
+
+  case 28:
+#line 153 "fs/reiser4/parser/parser.y"
+    { yyval.expr = compare_AND_expression( ws, yyvsp[-2].expr, yyvsp[0].expr ); ;}
+    break;
+
+  case 29:
+#line 157 "fs/reiser4/parser/parser.y"
+    { goto_end( ws );;}
+    break;
+
+  case 30:
+#line 161 "fs/reiser4/parser/parser.y"
+    { yyval.expr = yyvsp[0].expr;;}
+    break;
+
+  case 31:
+#line 162 "fs/reiser4/parser/parser.y"
+    { yyval.expr = target_name( yyvsp[-2].expr, yyvsp[0].expr );;}
+    break;
+
+  case 32:
+#line 166 "fs/reiser4/parser/parser.y"
+    { yyval.expr = yyvsp[0].expr; ;}
+    break;
+
+  case 33:
+#line 167 "fs/reiser4/parser/parser.y"
+    { yyval.expr = range2expr( ws, yyvsp[-2].expr, yyvsp[0].expr);;}
+    break;
+
+  case 34:
+#line 168 "fs/reiser4/parser/parser.y"
+    { yyval.expr = pars_lookup_process( ws, yyvsp[0].expr ) ; ;}
+    break;
+
+  case 35:
+#line 172 "fs/reiser4/parser/parser.y"
+    { yyval.expr = pars_expr( ws, yyvsp[-1].expr, yyvsp[0].expr ) ; ;}
+    break;
+
+  case 36:
+#line 173 "fs/reiser4/parser/parser.y"
+    { yyval.expr = pars_expr( ws, yyvsp[-2].expr, yyvsp[0].expr ) ; ;}
+    break;
+
+  case 37:
+#line 177 "fs/reiser4/parser/parser.y"
+    { yyval.expr = pars_lookup_root( ws ) ; ;}
+    break;
+
+  case 38:
+#line 178 "fs/reiser4/parser/parser.y"
+    { yyval.expr = pars_lookup_curr( ws ) ; ;}
+    break;
+
+  case 39:
+#line 182 "fs/reiser4/parser/parser.y"
+    { yyval.expr = lookup_word( ws, yyvsp[0].wrd ); ;}
+    break;
+
+  case 40:
+#line 183 "fs/reiser4/parser/parser.y"
+    { yyval.expr = yyvsp[-1].expr; level_down( ws, yyvsp[-2].charType, yyvsp[0].charType );;}
+    break;
+
+  case 41:
+#line 187 "fs/reiser4/parser/parser.y"
+    { yyval.expr = yyvsp[-1].expr; level_down( ws, yyvsp[-2].charType, yyvsp[0].charType );;}
+    break;
+
+  case 42:
+#line 191 "fs/reiser4/parser/parser.y"
+    { yyval.expr = new_range(ws, yyvsp[0].rng_com); ;}
+    break;
+
+  case 43:
+#line 192 "fs/reiser4/parser/parser.y"
+    { yyval.expr = add_range(ws, yyvsp[-1].expr, yyvsp[0].rng_com); ;}
+    break;
+
+  case 44:
+#line 196 "fs/reiser4/parser/parser.y"
+    { yyval.rng_com = range_expression2command(ws, yyvsp[-1].charType, yyvsp[0].wrd);;}
+    break;
+
+  case 45:
+#line 197 "fs/reiser4/parser/parser.y"
+    { yyval.rng_com = range_units_type(ws, COMMAND_UNITS, yyvsp[0].charType);;}
+    break;
+
+  case 46:
+#line 198 "fs/reiser4/parser/parser.y"
+    { yyval.rng_com =  range_units_type(ws, COMMAND_TYPE, yyvsp[0].charType);;}
+    break;
+
+  case 47:
+#line 202 "fs/reiser4/parser/parser.y"
+    { yyval.charType = COMMAND_OFFSET;;}
+    break;
+
+  case 48:
+#line 203 "fs/reiser4/parser/parser.y"
+    { yyval.charType = COMMAND_LAST;;}
+    break;
+
+  case 49:
+#line 204 "fs/reiser4/parser/parser.y"
+    { yyval.charType = COMMAND_FIRST;;}
+    break;
+
+  case 50:
+#line 205 "fs/reiser4/parser/parser.y"
+    { yyval.charType = COMMAND_LEN;;}
+    break;
+
+  case 51:
+#line 208 "fs/reiser4/parser/parser.y"
+    { yyval.charType = UNITS_BYTE;;}
+    break;
+
+  case 52:
+#line 209 "fs/reiser4/parser/parser.y"
+    { yyval.charType = UNITS_LINE;;}
+    break;
+
+  case 53:
+#line 210 "fs/reiser4/parser/parser.y"
+    { yyval.charType = UNITS_ITEM; ;}
+    break;
+
+  case 54:
+#line 214 "fs/reiser4/parser/parser.y"
+    { yyval.charType = RANGE_CUT;;}
+    break;
+
+  case 55:
+#line 215 "fs/reiser4/parser/parser.y"
+    { yyval.charType = RANGE_ZERRO;;}
+    break;
+
+  case 56:
+#line 216 "fs/reiser4/parser/parser.y"
+    { yyval.charType = RANGE_TRANSPARENT;;}
+    break;
+
+  case 57:
+#line 220 "fs/reiser4/parser/parser.y"
+    { yyval.charType = yyvsp[0].charType; level_up( ws, yyvsp[0].charType ); ;}
+    break;
+
+
+    }
+
+/* Line 970 of yacc.c.  */
+#line 1434 "fs/reiser4/parser/parser.tab.c"
+
+  yyvsp -= yylen;
+  yyssp -= yylen;
+  yylsp -= yylen;
+
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+  *++yylsp = yyloc;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (YYPACT_NINF < yyn && yyn < YYLAST)
+	{
+	  YYSIZE_T yysize = 0;
+	  int yytype = YYTRANSLATE (yychar);
+	  char *yymsg;
+	  int yyx, yycount;
+
+	  yycount = 0;
+	  /* Start YYX at -YYN if negative to avoid negative indexes in
+	     YYCHECK.  */
+	  for (yyx = yyn < 0 ? -yyn : 0;
+	       yyx < (int) (sizeof (yytname) / sizeof (char *)); yyx++)
+	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	      yysize += yystrlen (yytname[yyx]) + 15, yycount++;
+	  yysize += yystrlen ("syntax error, unexpected ") + 1;
+	  yysize += yystrlen (yytname[yytype]);
+	  yymsg = (char *) YYSTACK_ALLOC (yysize);
+	  if (yymsg != 0)
+	    {
+	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
+	      yyp = yystpcpy (yyp, yytname[yytype]);
+
+	      if (yycount < 5)
+		{
+		  yycount = 0;
+		  for (yyx = yyn < 0 ? -yyn : 0;
+		       yyx < (int) (sizeof (yytname) / sizeof (char *));
+		       yyx++)
+		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+		      {
+			const char *yyq = ! yycount ? ", expecting " : " or ";
+			yyp = yystpcpy (yyp, yyq);
+			yyp = yystpcpy (yyp, yytname[yyx]);
+			yycount++;
+		      }
+		}
+	      yyerror (yymsg);
+	      YYSTACK_FREE (yymsg);
+	    }
+	  else
+	    yyerror ("syntax error; also virtual memory exhausted");
+	}
+      else
+#endif /* YYERROR_VERBOSE */
+	yyerror ("syntax error");
+    }
+
+  yylerrsp = yylsp;
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      /* Return failure if at end of input.  */
+      if (yychar == YYEOF)
+        {
+	  /* Pop the error token.  */
+          YYPOPSTACK;
+	  /* Pop the rest of the stack.  */
+	  while (yyss < yyssp)
+	    {
+	      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
+	      yydestruct (yystos[*yyssp], yyvsp, yylsp);
+	      YYPOPSTACK;
+	    }
+	  YYABORT;
+        }
+
+      YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
+      yydestruct (yytoken, &yylval, &yylloc);
+      yychar = YYEMPTY;
+      *++yylerrsp = yylloc;
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab2;
+
+
+/*----------------------------------------------------.
+| yyerrlab1 -- error raised explicitly by an action.  |
+`----------------------------------------------------*/
+yyerrlab1:
+
+  /* Suppress GCC warning that yyerrlab1 is unused when no action
+     invokes YYERROR.  */
+#if defined (__GNUC_MINOR__) && 2093 <= (__GNUC__ * 1000 + __GNUC_MINOR__)
+  __attribute__ ((__unused__))
+#endif
+
+  yylerrsp = yylsp;
+  *++yylerrsp = yyloc;
+  goto yyerrlab2;
+
+
+/*---------------------------------------------------------------.
+| yyerrlab2 -- pop states until the error token can be shifted.  |
+`---------------------------------------------------------------*/
+yyerrlab2:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
+      yydestruct (yystos[yystate], yyvsp, yylsp);
+      yyvsp--;
+      yystate = *--yyssp;
+      yylsp--;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  YYDPRINTF (( "Shifting error token, "));
+
+  *++yyvsp = yylval;
+  YYLLOC_DEFAULT (yyloc, yylsp, (yylerrsp - yylsp));
+  *++yylsp = yyloc;
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*----------------------------------------------.
+| yyoverflowlab -- parser overflow comes here.  |
+`----------------------------------------------*/
+yyoverflowlab:
+  yyerror ("parser stack overflow");
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+  return yyresult;
+}
+
+
+#line 227 "fs/reiser4/parser/parser.y"
+
+
+
+
+/* Make Linus happy.
+   Local variables:
+   c-indentation-style: "K&R"
+   mode-name: "LC"
+   c-basic-offset: 8
+   tab-width: 8
+   End:
+*/
+
diff -puN /dev/null parser/parser.tab.h
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/parser.tab.h	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,163 @@
+/* A Bison parser, made by GNU Bison 1.875.  */
+
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     TRANSCRASH = 258,
+     SEMICOLON = 259,
+     COMMA = 260,
+     L_ASSIGN = 261,
+     L_APPEND = 262,
+     L_SYMLINK = 263,
+     PLUS = 264,
+     L_BRACKET = 265,
+     R_BRACKET = 266,
+     SLASH = 267,
+     PROCESS = 268,
+     INV_L = 269,
+     INV_R = 270,
+     EQ = 271,
+     NE = 272,
+     LE = 273,
+     GE = 274,
+     LT = 275,
+     GT = 276,
+     IS = 277,
+     AND = 278,
+     OR = 279,
+     P_RUNNER = 280,
+     NOT = 281,
+     IF = 282,
+     THEN = 283,
+     ELSE = 284,
+     EXIST = 285,
+     NAME = 286,
+     UNNAME = 287,
+     NAMED = 288,
+     WORD = 289,
+     STRING_CONSTANT = 290,
+     ROOT = 291,
+     RANGE = 292,
+     OFFSET = 293,
+     LASTBYTE = 294,
+     FIRSTBYTE = 295,
+     LENGTH = 296,
+     UNITS = 297,
+     BYTE = 298,
+     LINE = 299,
+     ITEM = 300,
+     CUT = 301,
+     ZERRO = 302,
+     TRANSPARENT = 303
+   };
+#endif
+#define TRANSCRASH 258
+#define SEMICOLON 259
+#define COMMA 260
+#define L_ASSIGN 261
+#define L_APPEND 262
+#define L_SYMLINK 263
+#define PLUS 264
+#define L_BRACKET 265
+#define R_BRACKET 266
+#define SLASH 267
+#define PROCESS 268
+#define INV_L 269
+#define INV_R 270
+#define EQ 271
+#define NE 272
+#define LE 273
+#define GE 274
+#define LT 275
+#define GT 276
+#define IS 277
+#define AND 278
+#define OR 279
+#define P_RUNNER 280
+#define NOT 281
+#define IF 282
+#define THEN 283
+#define ELSE 284
+#define EXIST 285
+#define NAME 286
+#define UNNAME 287
+#define NAMED 288
+#define WORD 289
+#define STRING_CONSTANT 290
+#define ROOT 291
+#define RANGE 292
+#define OFFSET 293
+#define LASTBYTE 294
+#define FIRSTBYTE 295
+#define LENGTH 296
+#define UNITS 297
+#define BYTE 298
+#define LINE 299
+#define ITEM 300
+#define CUT 301
+#define ZERRO 302
+#define TRANSPARENT 303
+
+
+
+
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+#line 15 "fs/reiser4/parser/parser.y"
+typedef union YYSTYPE {
+	long charType;
+	expr_v4_t * expr;
+	wrd_t * wrd;
+//	val_range_t * rng;
+	rng_command_t * rng_com;
+} YYSTYPE;
+/* Line 1227 of yacc.c.  */
+#line 140 "fs/reiser4/parser/parser.tab.h"
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+#if ! defined (YYLTYPE) && ! defined (YYLTYPE_IS_DECLARED)
+typedef struct YYLTYPE
+{
+  int first_line;
+  int first_column;
+  int last_line;
+  int last_column;
+} YYLTYPE;
+# define yyltype YYLTYPE /* obsolescent; will be withdrawn */
+# define YYLTYPE_IS_DECLARED 1
+# define YYLTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+
diff -puN /dev/null parser/parser.y
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/parser.y	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,245 @@
+/*
+ * Copyright 2001, 2002 by Hans Reiser, licensing governed by reiser4/README
+ */
+
+/* Parser for the reiser4() system call */
+
+
+%debug
+%defines
+%locations
+%pure-parser
+
+/* type definitions */
+%union 
+{
+	long charType;
+	expr_v4_t * expr;
+	wrd_t * wrd;
+//	val_range_t * rng;
+	rng_command_t * rng_com;
+}
+
+%{
+//#include "lib.c"
+%}
+
+
+%type <charType> L_BRACKET R_BRACKET level_up reiser4
+
+%type <wrd> WORD
+%type <wrd> P_RUNNER
+
+%type <wrd> STRING_CONSTANT
+
+%type <expr> Object_Name o_name name
+%type <expr> target
+
+%type <charType> rng_type rng_units rng_key
+
+%type <expr> range range_expression
+
+%type <rng_com> range_command
+
+%type <expr> begin_from
+%type <expr> Expression
+
+%type <expr> if_statement if_Expression if_Begin
+%type <expr> then_operation 
+
+%token TRANSCRASH
+%token SEMICOLON          /* ; */
+%token COMMA              /* , */
+%token L_ASSIGN L_APPEND  L_SYMLINK
+%token PLUS               /* + */
+%token L_BRACKET R_BRACKET
+%token SLASH PROCESS
+%token INV_L INV_R
+%token EQ NE  LE GE   LT  GT   
+%token IS
+%token AND
+%token OR
+%token P_RUNNER
+%token NOT
+%token IF
+%token THEN ELSE
+%token EXIST
+%token NAME UNNAME NAMED
+%token WORD STRING_CONSTANT
+%token ROOT
+
+%token RANGE OFFSET LASTBYTE FIRSTBYTE
+%token LENGTH UNITS
+%token BYTE LINE ITEM
+%token CUT ZERRO TRANSPARENT
+
+
+
+
+%left SEMICOLON COMMA
+%right L_SYMLINK L_APPEND L_ASSIGN
+
+%left PLUS               /* + */
+%left UNNAME NAME
+%left EQ NE  LE GE   LT  GT   
+%left NOT AND OR
+
+%right ELSE
+
+%left SLASH              /* / */
+
+/*
+For bison:
+%pure_parser
+*/
+
+/*
+  Starting production of our grammar.
+ */
+%start reiser4
+
+%%
+
+reiser4
+    : Expression                                      { $$ = free_expr( ws, $1 ); }
+;
+
+Expression
+    : Object_Name                                     { $$ = $1;}
+    | STRING_CONSTANT                                 { $$ = const_to_expr( ws, $1 ); }
+    | UNNAME Expression                               { $$ = unname( ws, $2 ); }
+    | NAME Expression                                 { $$ = name( ws, $2 ); }
+//    | TRANSCRASH Expression                           { $$ = transcrash( ws, $2 ); }
+    | Expression PLUS       Expression                { $$ = concat_expression( ws, $1, $3 ); }
+    | Expression SEMICOLON  Expression                { $$ = list_expression( ws, $1, $3 ); }
+    | Expression COMMA      Expression                { $$ = list_async_expression( ws, $1, $3 ); }
+    | if_statement                                    { $$ = $1; level_down( ws, IF_STATEMENT, IF_STATEMENT ); }
+                                                                            /* the ASSIGNMENT operator return a value: the expression of target */
+    |  target  assign          Expression             { $$ = assign( ws, $1, $3, $2 ); }            /*  <-  direct assign  */
+//    |  target  L_ASSIGN        Expression             { $$ = assign( ws, $1, $3, O_TRUNC ); }            /*  <-  direct assign  */
+//    |  target  L_APPEND        Expression             { $$ = assign( ws, $1, $3, O_APPEND ); }            /*  <-  direct assign  */
+//    |  target  L_ASSIGN  INV_L Expression INV_R       { $$ = assign_invert( ws, $1, $4 ); }     /*  <-  invert assign. destination must have ..invert method  */
+    |  target  assign    INV_L Expression INV_R       { $$ = assign_invert( ws, $1, $4, $2 ); }     /*  <-  invert assign. destination must have ..invert method  */
+    |  target  L_SYMLINK       Expression             { $$ = symlink( ws, $1, $3 ); }           /*   ->  symlink  the SYMLINK operator return a value: bytes ???? */
+
+//    | named_level_up Expression R_BRACKET             { $$ = named_level_down( ws, $1, $2, $3 ); }
+//    | level_up  Expression R_BRACKET                   { $$ = $2; level_down( ws, $1, $3 );}
+;
+//| Expression            Expression                { $$ = list_unordered_expression( ws, $1, $2 ); }
+
+
+assign
+    : L_ASSIGN                                             {$$ = O_TRUNC; }
+    | L_APPEND                                             {$$ = O_APPEND;}
+
+
+if_statement        
+    : if_Begin then_operation ELSE Expression %prec PLUS   { $$ = if_then_else( ws, $1, $2, $4 ); }
+    | if_Begin then_operation                 %prec PLUS   { $$ = if_then( ws, $1, $2) ;         }
+;
+
+if_Begin
+    : if if_Expression                                   { $$ = $2; }
+;
+
+
+
+if: IF                                            { level_up( ws, IF_STATEMENT ); }
+;
+
+if_Expression 
+    : NOT  Expression                                 { $$ = not_expression( ws, $2 ); } 
+    | EXIST  Expression                               { $$ = check_exist( ws, $2 ); }
+    | Expression EQ   Expression                      { $$ = compare_EQ_expression( ws, $1, $3 ); }
+    | Expression NE   Expression                      { $$ = compare_NE_expression( ws, $1, $3 ); }
+    | Expression LE   Expression                      { $$ = compare_LE_expression( ws, $1, $3 ); }
+    | Expression GE   Expression                      { $$ = compare_GE_expression( ws, $1, $3 ); }
+    | Expression LT   Expression                      { $$ = compare_LT_expression( ws, $1, $3 ); }
+    | Expression GT   Expression                      { $$ = compare_GT_expression( ws, $1, $3 ); }
+    | Expression OR   Expression                      { $$ = compare_OR_expression( ws, $1, $3 ); }
+    | Expression AND  Expression                      { $$ = compare_AND_expression( ws, $1, $3 ); }
+;
+
+then_operation
+    : THEN Expression                %prec PLUS       { goto_end( ws );}
+;
+
+target
+    : Object_Name                                     { $$ = $1;}
+    | o_name NAMED Object_Name                        { $$ = target_name( $1, $3 );}
+;
+
+Object_Name
+    : o_name                                          { $$ = $1; }
+    | o_name SLASH range                              { $$ = range2expr( ws, $1, $3);}
+    | SLASH PROCESS SLASH range                       { $$ = pars_lookup_process( ws, $4 ) ; }
+    ;
+
+o_name 
+    : begin_from name                 %prec ROOT       { $$ = pars_expr( ws, $1, $2 ) ; }
+    | o_name SLASH name                                { $$ = pars_expr( ws, $1, $3 ) ; }
+;
+
+begin_from
+    : SLASH                                            { $$ = pars_lookup_root( ws ) ; }
+    |                                                  { $$ = pars_lookup_curr( ws ) ; }
+;
+
+name
+    : WORD                                             { $$ = lookup_word( ws, $1 ); }
+    | level_up  Expression R_BRACKET                   { $$ = $2; level_down( ws, $1, $3 );}
+    ;
+
+range
+    : RANGE SLASH level_up range_expression R_BRACKET  { $$ = $4; level_down( ws, $3, $5 );}
+    ;
+
+range_expression
+    : range_command                                    { $$ = new_range(ws, $1); }
+    | range_expression range_command                   { $$ = add_range(ws, $1, $2); }
+    ;
+
+range_command
+    : rng_key STRING_CONSTANT                          { $$ = range_expression2command(ws, $1, $2);}
+    | UNITS rng_units                                  { $$ = range_units_type(ws, COMMAND_UNITS, $2);}
+    | rng_type                                         { $$ =  range_units_type(ws, COMMAND_TYPE, $1);}
+    ;
+
+rng_key
+    : OFFSET                                           { $$ = COMMAND_OFFSET;}
+    | LASTBYTE                                         { $$ = COMMAND_LAST;}
+    | FIRSTBYTE                                        { $$ = COMMAND_FIRST;}
+    | LENGTH                                           { $$ = COMMAND_LEN;}
+
+rng_units
+    : BYTE                                             { $$ = UNITS_BYTE;}
+    | LINE                                             { $$ = UNITS_LINE;}
+    | ITEM                                             { $$ = UNITS_ITEM; }
+    ;
+
+rng_type
+    : CUT                                              { $$ = RANGE_CUT;}
+    | ZERRO                                            { $$ = RANGE_ZERRO;}
+    | TRANSPARENT                                      { $$ = RANGE_TRANSPARENT;}
+    ;
+
+level_up
+    : L_BRACKET                                        { $$ = $1; level_up( ws, $1 ); } 
+;
+
+//named_level_up
+//    : Object_Name NAMED level_up                   { $$ = $1; level_up_named( ws, $1, $3 );} 
+//;
+
+%%
+
+
+
+/* Make Linus happy.
+   Local variables:
+   c-indentation-style: "K&R"
+   mode-name: "LC"
+   c-basic-offset: 8
+   tab-width: 8
+   End:
+*/
diff -puN /dev/null parser/pars.yacc.h
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/pars.yacc.h	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2001, 2002 by Hans Reiser, licensing governed by reiser4/README
+ */
+
+/*
+ * definitions of work space for yacc generated  from
+ * parser.y
+ */
+
+//typedef union YYSTYPE YYSTYPE;
+
+#define MAXLEVELCO 500
+#define BEGIN_FROM_ROOT 222
+#define BEGIN_FROM_CURRENT 333
+
+struct reiser4_syscall_w_space {
+	char * ws_inline;    /* this two field used for parsing string, one (inline) stay on begin */
+	char * ws_pline;     /*   of token, second (pline) walk to end to token                   */
+//#ifdef yacc
+#if 0
+	                     /* next field need for yacc                   */
+	                     /* accesing to this fields from rules: ws->... */
+	int ws_yystacksize; /*500*/
+	int ws_yymaxdepth ; /*500*/
+	int ws_yydebug;
+	int ws_yynerrs;
+	int ws_yyerrflag;
+	int ws_yychar;
+	int * ws_yyssp;
+	YYSTYPE * ws_yyvsp;
+	YYSTYPE ws_yyval;
+	YYSTYPE ws_yylval;
+	int     ws_yyss[YYSTACKSIZE];
+	YYSTYPE ws_yyvs[YYSTACKSIZE];
+#else
+	/* declare for bison */
+	                     /* next field need for bison                   */
+	                     /* accesing to this fields from rules: ws->... */
+//	int     ws_yystacksize; /*500*/
+//	int     ws_yymaxdepth ; /*500*/
+//	int     ws_yydebug;
+	int     ws_yynerrs;
+	//	int     ws_yyerrflag;
+
+	int     ws_yychar;
+	int     ws_yylen;
+
+	/* ???????? */
+	//	int     ws_yyssa[YYINITDEPTH];
+	int   * ws_yyss;
+	int   * ws_yyssp;
+
+	/* ???????? */
+	//	YYSTYPE ws_yyvsa[YYINITDEPTH];
+	YYSTYPE * ws_yyvs;
+	YYSTYPE * ws_yyvsp;
+
+	YYSTYPE ws_yyval;
+	YYSTYPE ws_yylval;
+
+	//	YYSTYPE ws_yylsa[YYINITDEPTH];
+	YYLTYPE * ws_yyls;
+	YYLTYPE * ws_yylsp;
+
+#endif
+
+	int	ws_yyerrco;
+	int	ws_level;              /* current level            */
+	int	ws_errco;              /* number of errors         */
+	                               /* working fields  */
+	char        * tmpWrdEnd;       /* pointer for parsing input string */
+	char        * yytext;          /* pointer for parsing input string */
+	                               /* space for   */
+	free_space_t * freeSpHead;      /* work spaces list Header */
+	free_space_t * freeSpCur;       /* current work space */
+	wrd_t       * wrdHead;         /* names list Header */
+	pars_var_t  * Head_pars_var;   /* parsed variables Header */
+	streg_t     * Head_level;      /* parsers level list Header */
+	streg_t     * cur_level;       /* current level */
+
+	expr_v4_t   * root_e;          /* root expression  for this task */
+	struct nameidata nd;           /* work field for pass to VFS mount points */
+	atomic_t * lock;
+};
+
+
+
+
+/*
+ * Make Linus happy.
+ * Local variables:
+ * c-indentation-style: "K&R"
+ * mode-name: "LC"
+ * c-basic-offset: 8
+ * tab-width: 8
+ * End:
+ */
diff -puN /dev/null parser/sys_reiser4.c
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/sys_reiser4.c	2005-06-29 20:00:24.000000000 +0400
@@ -0,0 +1,74 @@
+/* System call for accessing enhanced semantics of the Reiser Filesystem Version 4 (reiser4). */
+
+/* This system call feeds a string to parser.c, parser.c converts the
+   string into a set of commands which are executed, and then this
+   system call returns after the completion of those commands. */
+
+
+#define yyversion "4.0.0"
+
+#include "parser.h"
+
+#include "parser.tab.h"
+#include "lib.c"
+//#include "pars.cls.h"
+//#include "lib.c"
+//#include "parser.tab.c"
+
+#if defined(CONFIG_REISER4_FS_SYSCALL_BISON)
+#include "parser.tab.c"
+#else
+#if defined(CONFIG_REISER4_FS_SYSCALL_YACC)
+#include "parser.code.c"
+#endif
+#endif
+
+
+
+/* @p_string is a command string for parsing
+this function allocates work area for yacc,
+initializes fields, calls yacc, free space
+and call for execute the generated code */
+
+asmlinkage long
+sys_reiser4(char *p_string)
+{
+	long ret;
+	int *Gencode;
+	char * str;
+	struct reiser4_syscall_w_space * work_space ;
+	str=getname(p_string);
+	if (!IS_ERR(str)) {
+
+		print_pwd_count("\n--------------------\ninit");
+
+		/* allocate work space for parser
+		   working variables, attached to this call */
+		if ( (work_space = reiser4_pars_init() ) == NULL ) {
+			return -ENOMEM;
+		}
+		/* initialize fields */
+		/* this field used for parsing string, one (inline) stay on begin of string*/
+		work_space->ws_pline  = str;
+		work_space->ws_inline = work_space->ws_pline;
+		ret = yyparse(work_space);	/* parse command */
+		reiser4_pars_free(work_space);
+		putname(str);
+		print_pwd_count("end");
+
+	}
+	else {
+		ret = PTR_ERR(str);
+	}
+	return ret;
+}
+
+/* Make Linus happy.
+   Local variables:
+   c-indentation-style: "K&R"
+   mode-name: "LC"
+   c-basic-offset: 8
+   tab-width: 8
+   fill-column: 120
+   End:
+*/
diff -puN /dev/null parser/yacc_reiser4.patch
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/yacc_reiser4.patch	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,127 @@
+--- ../yacc/skeleton.c	1993-12-22 14:28:01.000000000 +0300
++++ skeleton.c	2004-01-29 23:05:26.000000000 +0300
+@@ -16,7 +16,7 @@
+ {
+     "#ifndef lint",
+     "/*static char yysccsid[] = \"from: @(#)yaccpar	1.9 (Berkeley) 02/21/93\";*/",
+-    "static char yyrcsid[] = \"$Id: skeleton.c,v 1.4 1993/12/21 18:45:32 jtc Exp $\";",
++    "static char yyrcsid[] = \"$Id: skeleton.c,v 1.4 1993/12/21 18:45:32 jtc Exp $\\n 2002/10/22 VD reiser4\";",
+     "#endif",
+     "#define YYBYACC 1",
+     "#define YYMAJOR 1",
+@@ -30,6 +30,9 @@
+ 
+ char *tables[] =
+ {
++    "#if defined(YYREISER4_DEF)",
++    "#define extern static",
++    "#endif",
+     "extern short yylhs[];",
+     "extern short yylen[];",
+     "extern short yydefred[];",
+@@ -49,28 +52,45 @@
+ 
+ char *header[] =
+ {
+-    "#ifdef YYSTACKSIZE",
+-    "#undef YYMAXDEPTH",
+-    "#define YYMAXDEPTH YYSTACKSIZE",
+-    "#else",
+-    "#ifdef YYMAXDEPTH",
+-    "#define YYSTACKSIZE YYMAXDEPTH",
++    "#if defined(YYREISER4_DEF)",
++      "#define YYSTACKSIZE 500",
++      "#define YYMAXDEPTH 500",
++      "#define yydebug ws->ws_yydebug ",
++      "#define yynerrs ws->ws_yynerrs",
++      "#define yyerrflag ws->ws_yyerrflag",
++      "#define yychar ws->ws_yychar",
++      "#define yyssp ws->ws_yyssp",
++      "#define yyvsp ws->ws_yyvsp",
++      "#define yyval ws->ws_yyval",
++      "#define yylval ws->ws_yylval",
++      "#define yyss ws->ws_yyss",
++      "#define yyvs ws->ws_yyvs",
++      "#define yystacksize ws->ws_yystacksize",
+     "#else",
+-    "#define YYSTACKSIZE 500",
+-    "#define YYMAXDEPTH 500",
++      "#ifdef YYSTACKSIZE",
++        "#undef YYMAXDEPTH",
++        "#define YYMAXDEPTH YYSTACKSIZE",
++      "#else",
++        "#ifdef YYMAXDEPTH",
++          "#define YYSTACKSIZE YYMAXDEPTH",
++        "#else",
++          "#define YYSTACKSIZE 500",
++          "#define YYMAXDEPTH 500",
++        "#endif",
++      "#endif",
++      "int yydebug;",
++      "int yynerrs;",
++      "int yyerrflag;",
++      "int yychar;",
++      "short *yyssp;",
++      "YYSTYPE *yyvsp;",
++      "YYSTYPE yyval;",
++      "YYSTYPE yylval;",
++      "short yyss[YYSTACKSIZE];",
++      "YYSTYPE yyvs[YYSTACKSIZE];",
++      "#define yystacksize YYSTACKSIZE",
+     "#endif",
+-    "#endif",
+-    "int yydebug;",
+-    "int yynerrs;",
+-    "int yyerrflag;",
+-    "int yychar;",
+-    "short *yyssp;",
+-    "YYSTYPE *yyvsp;",
+-    "YYSTYPE yyval;",
+-    "YYSTYPE yylval;",
+-    "short yyss[YYSTACKSIZE];",
+-    "YYSTYPE yyvs[YYSTACKSIZE];",
+-    "#define yystacksize YYSTACKSIZE",
++
+     0
+ };
+ 
+@@ -82,11 +102,15 @@
+     "#define YYACCEPT goto yyaccept",
+     "#define YYERROR goto yyerrlab",
+     "int",
++    "#if defined(YYREISER4_DEF)",
++    "yyparse(struct reiser4_syscall_w_space  * ws)",
++    "#else",
+     "#if defined(__STDC__)",
+     "yyparse(void)",
+     "#else",
+     "yyparse()",
+     "#endif",
++    "#endif",
+     "{",
+     "    register int yym, yyn, yystate;",
+     "#if YYDEBUG",
+@@ -150,7 +174,11 @@
+     "        goto yyreduce;",
+     "    }",
+     "    if (yyerrflag) goto yyinrecovery;",
++    "#if defined(YYREISER4_DEF)",
++    "    yyerror(ws,11111,yystate,yychar);",
++    "#else ",
+     "    yyerror(\"syntax error\");",
++    "#endif",
+     "#ifdef lint",
+     "    goto yyerrlab;",
+     "#endif",
+@@ -275,7 +303,11 @@
+     "    *++yyvsp = yyval;",
+     "    goto yyloop;",
+     "yyoverflow:",
++    "#if defined(YYREISER4_DEF)",
++    "    yyerror(ws,101); /*yacc stack overflow*/",
++    "#else ",
+     "    yyerror(\"yacc stack overflow\");",
++    "#endif",
+     "yyabort:",
+     "    return (1);",
+     "yyaccept:",
diff -puN /dev/null parser/bison-1.875/c.m4
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/bison-1.875/c.m4	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,411 @@
+m4_divert(-1)                                               -*- Autoconf -*-
+
+# C M4 Macros for Bison.
+# Copyright (C) 2002 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+# 02111-1307  USA
+
+
+## ---------------- ##
+## Identification.  ##
+## ---------------- ##
+
+# b4_copyright(TITLE, YEARS)
+# --------------------------
+m4_define([b4_copyright],
+[/* A Bison parser, made by GNU Bison b4_version.  */
+
+/* $1,
+   Copyright (C) $2 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */])
+
+
+# b4_identification
+# -----------------
+m4_define([b4_identification],
+[/* Identify Bison output.  */
+[#]define YYBISON 1
+
+/* Skeleton name.  */
+[#]define YYSKELETON_NAME b4_skeleton
+
+/* Pure parsers.  */
+[#]define YYPURE b4_pure
+
+/* Using locations.  */
+[#]define YYLSP_NEEDED b4_locations_flag
+])
+
+
+
+## ---------------- ##
+## Default values.  ##
+## ---------------- ##
+
+m4_define_default([b4_epilogue], [])
+
+
+
+## ------------------------ ##
+## Pure/impure interfaces.  ##
+## ------------------------ ##
+
+
+# b4_user_args
+# ------------
+m4_define([b4_user_args],
+[m4_ifset([b4_parse_param], [, b4_c_args(b4_parse_param)])])
+
+
+# b4_parse_param
+# --------------
+# If defined, b4_parse_param arrives double quoted, but below we prefer
+# it to be single quoted.
+m4_define_default([b4_parse_param])
+m4_define([b4_parse_param],
+b4_parse_param))
+
+
+
+## ------------ ##
+## Data Types.  ##
+## ------------ ##
+
+
+# b4_ints_in(INT1, INT2, LOW, HIGH)
+# ---------------------------------
+# Return 1 iff both INT1 and INT2 are in [LOW, HIGH], 0 otherwise.
+m4_define([b4_ints_in],
+[m4_eval([$3 <= $1 && $1 <= $4 && $3 <= $2 && $2 <= $4])])
+
+
+# b4_int_type(MIN, MAX)
+# ---------------------
+# Return the smallest int type able to handle numbers ranging from
+# MIN to MAX (included).
+m4_define([b4_int_type],
+[m4_if(b4_ints_in($@,      [0],   [255]), [1], [unsigned char],
+       b4_ints_in($@,   [-128],   [127]), [1], [signed char],
+
+       b4_ints_in($@,      [0], [65535]), [1], [unsigned short],
+       b4_ints_in($@, [-32768], [32767]), [1], [short],
+
+       m4_eval([0 <= $1]),                [1], [unsigned int],
+
+ 	                                       [int])])
+
+
+# b4_int_type_for(NAME)
+# ---------------------
+# Return the smallest int type able to handle numbers ranging from
+# `NAME_min' to `NAME_max' (included).
+m4_define([b4_int_type_for],
+[b4_int_type($1_min, $1_max)])
+
+
+## ------------------ ##
+## Decoding options.  ##
+## ------------------ ##
+
+
+# b4_location_if(IF-TRUE, IF-FALSE)
+# ---------------------------------
+# Expand IF-TRUE, if locations are used, IF-FALSE otherwise.
+m4_define([b4_location_if],
+[m4_if(b4_locations_flag, [1],
+       [$1],
+       [$2])])
+
+
+# b4_pure_if(IF-TRUE, IF-FALSE)
+# -----------------------------
+# Expand IF-TRUE, if %pure-parser, IF-FALSE otherwise.
+m4_define([b4_pure_if],
+[m4_if(b4_pure, [1],
+       [$1],
+       [$2])])
+
+
+
+## ------------------------- ##
+## Assigning token numbers.  ##
+## ------------------------- ##
+
+# b4_token_define(TOKEN-NAME, TOKEN-NUMBER)
+# -----------------------------------------
+# Output the definition of this token as #define.
+m4_define([b4_token_define],
+[#define $1 $2
+])
+
+
+# b4_token_enum(TOKEN-NAME, TOKEN-NUMBER)
+# ---------------------------------------
+# Output the definition of this token as an enum.
+m4_define([b4_token_enum],
+[$1 = $2])
+
+
+# b4_token_defines(LIST-OF-PAIRS-TOKEN-NAME-TOKEN-NUMBER)
+# -------------------------------------------------------
+# Output the definition of the tokens (if there are) as enums and #define.
+m4_define([b4_token_defines],
+[m4_if([$@], [[]], [],
+[/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+m4_map_sep([     b4_token_enum], [,
+],
+           [$@])
+   };
+#endif
+m4_map([b4_token_define], [$@])
+])
+])
+
+
+
+## --------------------------------------------- ##
+## Defining C functions in both K&R and ANSI-C.  ##
+## --------------------------------------------- ##
+
+
+# b4_c_function_def(NAME, RETURN-VALUE, [DECL1, NAME1], ...)
+# ----------------------------------------------------------
+# Declare the function NAME.
+m4_define([b4_c_function_def],
+[#if defined (__STDC__) || defined (__cplusplus)
+b4_c_ansi_function_def($@)
+#else
+$2
+$1 (b4_c_knr_formal_names(m4_shiftn(2, $@)))
+b4_c_knr_formal_decls(m4_shiftn(2, $@))
+#endif[]dnl
+])
+
+
+# b4_c_ansi_function_def(NAME, RETURN-VALUE, [DECL1, NAME1], ...)
+# ---------------------------------------------------------------
+# Declare the function NAME in ANSI.
+m4_define([b4_c_ansi_function_def],
+[$2
+$1 (b4_c_ansi_formals(m4_shiftn(2, $@)))[]dnl
+])
+
+
+# b4_c_ansi_formals([DECL1, NAME1], ...)
+# --------------------------------------
+# Output the arguments ANSI-C definition.
+m4_define([b4_c_ansi_formals],
+[m4_case([$@],
+         [],   [void],
+         [[]], [void],
+               [m4_map_sep([b4_c_ansi_formal], [, ], [$@])])])
+
+m4_define([b4_c_ansi_formal],
+[$1])
+
+
+# b4_c_knr_formal_names([DECL1, NAME1], ...)
+# ------------------------------------------
+# Output the argument names.
+m4_define([b4_c_knr_formal_names],
+[m4_map_sep([b4_c_knr_formal_name], [, ], [$@])])
+
+m4_define([b4_c_knr_formal_name],
+[$2])
+
+
+# b4_c_knr_formal_decls([DECL1, NAME1], ...)
+# ------------------------------------------
+# Output the K&R argument declarations.
+m4_define([b4_c_knr_formal_decls],
+[m4_map_sep([b4_c_knr_formal_decl],
+            [
+],
+            [$@])])
+
+m4_define([b4_c_knr_formal_decl],
+[    $1;])
+
+
+
+## ------------------------------------------------------------ ##
+## Declaring (prototyping) C functions in both K&R and ANSI-C.  ##
+## ------------------------------------------------------------ ##
+
+
+# b4_c_function_decl(NAME, RETURN-VALUE, [DECL1, NAME1], ...)
+# -----------------------------------------------------------
+# Declare the function NAME.
+m4_define([b4_c_function_decl],
+[#if defined (__STDC__) || defined (__cplusplus)
+b4_c_ansi_function_decl($@)
+#else
+$2 $1 ();
+#endif[]dnl
+])
+
+
+# b4_c_ansi_function_decl(NAME, RETURN-VALUE, [DECL1, NAME1], ...)
+# ----------------------------------------------------------------
+# Declare the function NAME.
+m4_define([b4_c_ansi_function_decl],
+[$2 $1 (b4_c_ansi_formals(m4_shiftn(2, $@)));[]dnl
+])
+
+
+
+
+## --------------------- ##
+## Calling C functions.  ##
+## --------------------- ##
+
+
+# b4_c_function_call(NAME, RETURN-VALUE, [DECL1, NAME1], ...)
+# -----------------------------------------------------------
+# Call the function NAME with arguments NAME1, NAME2 etc.
+m4_define([b4_c_function_call],
+[$1 (b4_c_args(m4_shiftn(2, $@)))[]dnl
+])
+
+
+# b4_c_args([DECL1, NAME1], ...)
+# ------------------------------
+# Output the arguments NAME1, NAME2...
+m4_define([b4_c_args],
+[m4_map_sep([b4_c_arg], [, ], [$@])])
+
+m4_define([b4_c_arg],
+[$2])
+
+
+## ----------- ##
+## Synclines.  ##
+## ----------- ##
+
+
+# b4_syncline(LINE, FILE)
+# -----------------------
+m4_define([b4_syncline],
+[m4_if(b4_synclines_flag, 1,
+       [[#]line $1 $2])])
+
+
+# b4_symbol_actions(FILENAME, LINENO,
+#                   SYMBOL-TAG, SYMBOL-NUM,
+#                   SYMBOL-ACTION, SYMBOL-TYPENAME)
+# -------------------------------------------------
+m4_define([b4_symbol_actions],
+[m4_pushdef([b4_dollar_dollar], [yyvaluep->$6])dnl
+m4_pushdef([b4_at_dollar], [(*yylocationp)])dnl
+      case $4: /* $3 */
+b4_syncline([$2], [$1])
+        $5;
+b4_syncline([@oline@], [@ofile@])
+        break;
+m4_popdef([b4_at_dollar])dnl
+m4_popdef([b4_dollar_dollar])dnl
+])
+
+
+# b4_yydestruct_generate(FUNCTION-DECLARATOR)
+# -------------------------------------------
+# Generate the "yydestruct" function, which declaration is issued using
+# FUNCTION-DECLARATOR, which may be "b4_c_ansi_function_def" for ISO C
+# or "b4_c_function_def" for K&R.
+m4_define([b4_yydestruct_generate],
+[[/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+]$1([yydestruct],
+    [static void],
+    [[int yytype],           [yytype]],
+    [[YYSTYPE *yyvaluep],    [yyvaluep]]b4_location_if([,
+    [[YYLTYPE *yylocationp], [yylocationp]]]))[
+{
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvaluep;
+]b4_location_if([  (void) yylocationp;
+])[
+  switch (yytype)
+    {
+]m4_map([b4_symbol_actions], m4_defn([b4_symbol_destructors]))[
+      default:
+        break;
+    }
+}]dnl
+])
+
+
+# b4_yysymprint_generate(FUNCTION-DECLARATOR)
+# -------------------------------------------
+# Generate the "yysymprint" function, which declaration is issued using
+# FUNCTION-DECLARATOR, which may be "b4_c_ansi_function_def" for ISO C
+# or "b4_c_function_def" for K&R.
+m4_define([b4_yysymprint_generate],
+[[/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+]$1([yysymprint],
+    [static void],
+    [[int yytype],           [yytype]],
+    [[YYSTYPE *yyvaluep],    [yyvaluep]]b4_location_if([,
+    [[YYLTYPE *yylocationp], [yylocationp]]]))
+{
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvaluep;
+b4_location_if([  (void) yylocationp;
+])dnl
+
+  if (yytype < YYNTOKENS)
+    {
+      YYFPRINTF ( "token %s (", yytname[[yytype]]);
+# ifdef YYPRINT
+      YYPRINT ( yytoknum[[yytype]], *yyvaluep);
+# endif
+    }
+  else
+    YYFPRINTF ( "nterm %s (", yytname[[yytype]]);
+
+  switch (yytype)
+    {
+m4_map([b4_symbol_actions], m4_defn([b4_symbol_printers]))dnl
+      default:
+        break;
+    }
+  YYFPRINTF ( ")");
+}
+])
diff -puN /dev/null parser/bison-1.875/glr.c
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/bison-1.875/glr.c	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,1985 @@
+m4_divert(-1)                                                       -*- C -*-
+
+# GLR skeleton for Bison
+# Copyright (C) 2002 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+# 02111-1307  USA
+
+
+## ---------------- ##
+## Default values.  ##
+## ---------------- ##
+
+# Stack parameters.
+m4_define_default([b4_stack_depth_max], [10000])
+m4_define_default([b4_stack_depth_init],  [200])
+
+
+
+## ------------------------ ##
+## Pure/impure interfaces.  ##
+## ------------------------ ##
+
+
+# b4_lex_param
+# ------------
+# Accumule in b4_lex_param all the yylex arguments.
+# Yes, this is quite ugly...
+m4_define([b4_lex_param],
+m4_dquote(b4_pure_if([[[[YYSTYPE *]], [[yylvalp]]][]dnl
+b4_location_if([, [[YYLTYPE *], [yyllocp]]])])dnl
+m4_ifdef([b4_lex_param], [, ]b4_lex_param)))
+
+
+# b4_user_formals
+# ---------------
+m4_define([b4_user_formals],
+[m4_ifset([b4_parse_param], [, b4_c_ansi_formals(b4_parse_param)])])
+
+
+# b4_yyerror_args
+# ---------------
+# Arguments passed to yyerror: user args plus yylloc.
+m4_define([b4_yyerror_args],
+[b4_pure_if([b4_location_if([yylocp, ])])dnl
+m4_ifset([b4_parse_param], [b4_c_args(b4_parse_param), ])])
+
+
+# b4_lyyerror_args
+# ----------------
+# Same as above, but on the lookahead, hence yyllocp instead of yylocp.
+m4_define([b4_lyyerror_args],
+[b4_pure_if([b4_location_if([yyllocp, ])])dnl
+m4_ifset([b4_parse_param], [b4_c_args(b4_parse_param), ])])
+
+
+# b4_pure_args
+# ------------
+# Arguments needed by yyerror: user args plus yylloc.
+m4_define([b4_pure_args],
+[b4_pure_if([b4_location_if([, yylocp])])[]b4_user_args])
+
+
+# b4_pure_formals
+# ---------------
+# Arguments passed to yyerror: user formals plus yyllocp.
+m4_define([b4_pure_formals],
+[b4_pure_if([b4_location_if([, YYLTYPE *yylocp])])[]b4_user_formals])
+
+
+# b4_lpure_args
+# -------------
+# Same as above, but on the lookahead, hence yyllocp instead of yylocp.
+m4_define([b4_lpure_args],
+[b4_pure_if([b4_location_if([, yyllocp])])[]b4_user_args])
+
+
+# b4_lpure_formals
+# ----------------
+# Same as above, but on the lookahead, hence yyllocp instead of yylocp.
+m4_define([b4_lpure_formals],
+[b4_pure_if([b4_location_if([YYLTYPE *yyllocp])])[]b4_user_formals])
+
+
+## ----------------- ##
+## Semantic Values.  ##
+## ----------------- ##
+
+
+# b4_lhs_value([TYPE])
+# --------------------
+# Expansion of $<TYPE>$.
+m4_define([b4_lhs_value],
+[(*yyvalp)[]m4_ifval([$1], [.$1])])
+
+
+# b4_rhs_value(RULE-LENGTH, NUM, [TYPE])
+# --------------------------------------
+# Expansion of $<TYPE>NUM, where the current rule has RULE-LENGTH
+# symbols on RHS.
+m4_define([b4_rhs_value],
+[yyvsp@{m4_eval([$2 - $1])@}.yystate.yysemantics.yysval[]m4_ifval([$3], [.$3])])
+
+
+
+## ----------- ##
+## Locations.  ##
+## ----------- ##
+
+# b4_lhs_location()
+# -----------------
+# Expansion of @$.
+m4_define([b4_lhs_location],
+[(*yylocp)])
+
+
+# b4_rhs_location(RULE-LENGTH, NUM)
+# ---------------------------------
+# Expansion of @NUM, where the current rule has RULE-LENGTH symbols
+# on RHS.
+m4_define([b4_rhs_location],
+[yyvsp@{m4_eval([$2 - $1])@}.yystate.yyloc])
+
+
+# We do want M4 expansion after # for CPP macros.
+m4_changecom()
+m4_divert(0)dnl
+@output @output_parser_name@
+b4_copyright([Skeleton parser for GLR parsing with Bison], [2002])
+[
+/* This is the parser code for GLR (Generalized LR) parser. */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <setjmp.h>
+
+]b4_identification
+m4_if(b4_prefix[], [yy], [],
+[/* If NAME_PREFIX is specified substitute the variables and functions
+   names.  */
+#define yyparse b4_prefix[]parse
+#define yylex   b4_prefix[]lex
+#define yyerror b4_prefix[]error
+#define yylval  b4_prefix[]lval
+#define yychar  b4_prefix[]char
+#define yydebug b4_prefix[]debug
+#define yynerrs b4_prefix[]nerrs
+b4_location_if([#define yylloc b4_prefix[]lloc])])
+
+b4_token_defines(b4_tokens)
+
+/* Copy the first part of user declarations.  */
+b4_pre_prologue[
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG ]b4_debug[
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE ]b4_error_verbose[
+#endif
+
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+]m4_ifdef([b4_stype],
+[b4_syncline([b4_stype_line], [b4_filename])
+typedef union m4_bregexp(b4_stype, [^{], [YYSTYPE ])b4_stype YYSTYPE;
+/* Line __line__ of glr.c.  */
+b4_syncline([@oline@], [@ofile@])],
+[typedef int YYSTYPE;])[
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+#if ! defined (YYLTYPE) && ! defined (YYLTYPE_IS_DECLARED)
+typedef struct YYLTYPE
+{
+  int first_line;
+  int first_column;
+  int last_line;
+  int last_column;
+} YYLTYPE;
+# define YYLTYPE_IS_DECLARED 1
+# define YYLTYPE_IS_TRIVIAL 1
+#endif
+
+/* Default (constant) values used for initialization for null
+   right-hand sides.  Unlike the standard yacc.c template,
+   here we set the default values of $$ and $@@ to zeroed-out
+   values.  Since the default value of these quantities is undefined,
+   this behavior is technically correct. */
+static YYSTYPE yyval_default;
+static YYLTYPE yyloc_default;
+
+/* Copy the second part of user declarations.  */
+]b4_post_prologue[
+
+]/* Line __line__ of glr.c.  */
+b4_syncline([@oline@], [@ofile@])
+[
+#if ! defined (__cplusplus)
+   typedef char bool;
+#  define yytrue 1
+#  define yyfalse 0
+#endif
+
+/*-----------------.
+| GCC extensions.  |
+`-----------------*/
+
+#ifndef __attribute__
+/* This feature is available in gcc versions 2.5 and later.  */
+# if !defined (__GNUC__) || __GNUC__ < 2 || \
+(__GNUC__ == 2 && __GNUC_MINOR__ < 5) || __STRICT_ANSI__
+#  define __attribute__(Spec) /* empty */
+# endif
+#endif
+
+#ifndef ATTRIBUTE_UNUSED
+# define ATTRIBUTE_UNUSED __attribute__ ((__unused__))
+#endif
+
+/* YYFINAL -- State number of the termination state. */
+#define YYFINAL  ]b4_final_state_number[
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   ]b4_last[
+
+/* YYNTOKENS -- Number of terminals. */
+#define YYNTOKENS  ]b4_tokens_number[
+/* YYNNTS -- Number of nonterminals. */
+#define YYNNTS  ]b4_nterms_number[
+/* YYNRULES -- Number of rules. */
+#define YYNRULES  ]b4_rules_number[
+/* YYNRULES -- Number of states. */
+#define YYNSTATES  ]b4_states_number[
+/* YYMAXRHS -- Maximum number of symbols on right-hand side of rule. */
+#define YYMAXRHS ]b4_r2_max[
+
+/* YYTRANSLATE(X) -- Bison symbol number corresponding to X.  */
+#define YYUNDEFTOK  ]b4_undef_token_number[
+#define YYMAXUTOK   ]b4_user_token_number_max[
+
+#define YYTRANSLATE(YYX) 						\
+  ((YYX <= 0) ? YYEOF :							\
+   (unsigned)(YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const ]b4_int_type_for([b4_translate])[ yytranslate[] =
+{
+  ]b4_translate[
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const ]b4_int_type_for([b4_prhs])[ yyprhs[] =
+{
+  ]b4_prhs[
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS. */
+static const ]b4_int_type_for([b4_rhs])[ yyrhs[] =
+{
+  ]b4_rhs[
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const ]b4_int_type_for([b4_rline])[ yyrline[] =
+{
+  ]b4_rline[
+};
+#endif
+
+#if (YYDEBUG) || YYERROR_VERBOSE
+/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+static const char *const yytname[] =
+{
+  ]b4_tname[
+};
+
+#define yytname_size ((int) (sizeof (yytname) / sizeof (yytname[0])))
+#endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const ]b4_int_type_for([b4_r1])[ yyr1[] =
+{
+  ]b4_r1[
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const ]b4_int_type_for([b4_r2])[ yyr2[] =
+{
+  ]b4_r2[
+};
+
+/* YYDPREC[RULE-NUM] -- Dynamic precedence of rule #RULE-NUM (0 if none). */
+static const ]b4_int_type_for([b4_dprec])[ yydprec[] =
+{
+  ]b4_dprec[
+};
+
+/* YYMERGER[RULE-NUM] -- Index of merging function for rule #RULE-NUM. */
+static const ]b4_int_type_for([b4_merger])[ yymerger[] =
+{
+  ]b4_merger[
+};
+
+/* YYDEFACT[S] -- default rule to reduce with in state S when YYTABLE
+   doesn't specify something else to do.  Zero means the default is an
+   error.  */
+static const ]b4_int_type_for([b4_defact])[ yydefact[] =
+{
+  ]b4_defact[
+};
+
+/* YYPDEFGOTO[NTERM-NUM]. */
+static const ]b4_int_type_for([b4_defgoto])[ yydefgoto[] =
+{
+  ]b4_defgoto[
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF ]b4_pact_ninf[
+static const ]b4_int_type_for([b4_pact])[ yypact[] =
+{
+  ]b4_pact[
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const ]b4_int_type_for([b4_pgoto])[ yypgoto[] =
+{
+  ]b4_pgoto[
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF ]b4_table_ninf[
+static const ]b4_int_type_for([b4_table])[ yytable[] =
+{
+  ]b4_table[
+};
+
+/* YYCONFLP[YYPACT[STATE-NUM]] -- Pointer into YYCONFL of start of
+   list of conflicting reductions corresponding to action entry for
+   state STATE-NUM in yytable.  0 means no conflicts.  The list in
+   yyconfl is terminated by a rule number of 0.  */
+static const ]b4_int_type_for([b4_conflict_list_heads])[ yyconflp[] =
+{
+  ]b4_conflict_list_heads[
+};
+
+/* YYCONFL[I] -- lists of conflicting rule numbers, each terminated by
+   0, pointed into by YYCONFLP.  */
+]dnl Do not use b4_int_type_for here, since there are places where
+dnl pointers onto yyconfl are taken, which type is "short *".
+dnl We probably ought to introduce a type for confl.
+[static const short yyconfl[] =
+{
+  ]b4_conflicting_rules[
+};
+
+static const ]b4_int_type_for([b4_check])[ yycheck[] =
+{
+  ]b4_check[
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const ]b4_int_type_for([b4_stos])[ yystos[] =
+{
+  ]b4_stos[
+};
+
+
+/* Prevent warning if -Wmissing-prototypes.  */
+]b4_c_ansi_function_decl([yyparse], [int], b4_parse_param)[
+
+/* Error token number */
+#define YYTERROR 1
+
+/* YYLLOC_DEFAULT -- Compute the default location (before the actions
+   are run).  */
+
+#define YYRHSLOC(yyRhs,YYK) (yyRhs[YYK].yystate.yyloc)
+
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(yyCurrent, yyRhs, YYN)			\
+  yyCurrent.first_line   = YYRHSLOC(yyRhs,1).first_line;	\
+  yyCurrent.first_column = YYRHSLOC(yyRhs,1).first_column;	\
+  yyCurrent.last_line    = YYRHSLOC(yyRhs,YYN).last_line;	\
+  yyCurrent.last_column  = YYRHSLOC(yyRhs,YYN).last_column;
+#endif
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+#define YYLEX ]b4_c_function_call([yylex], [int], b4_lex_param)[
+
+]b4_pure_if(
+[
+#undef yynerrs
+#define yynerrs (yystack->yyerrcnt)
+#undef yychar
+#define yychar (yystack->yyrawchar)],
+[YYSTYPE yylval;
+
+YYLTYPE yylloc;
+
+int yynerrs;
+int yychar;])[
+
+static const int YYEOF = 0;
+static const int YYEMPTY = -2;
+
+typedef enum { yyok, yyaccept, yyabort, yyerr } YYRESULTTAG;
+
+#define YYCHK(YYE)							     \
+   do { YYRESULTTAG yyflag = YYE; if (yyflag != yyok) return yyflag; } 	     \
+   while (0)
+
+#if YYDEBUG
+
+#if ! defined (YYFPRINTF)
+#  define YYFPRINTF fprintf
+#endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (0)
+
+]b4_yysymprint_generate([b4_c_ansi_function_def])[
+
+# define YYDSYMPRINT(Args)			\
+do {						\
+  if (yydebug)					\
+    yysymprint Args;				\
+} while (0)
+
+# define YYDSYMPRINTF(Title, Token, Value, Location)		\
+do {								\
+  if (yydebug)							\
+    {								\
+      YYFPRINTF (stderr, "%s ", Title);				\
+      yysymprint (stderr, 					\
+                  Token, Value]b4_location_if([, Location])[);	\
+      YYFPRINTF (stderr, "\n");					\
+    }								\
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+
+#else /* !YYDEBUG */
+
+  /* Avoid empty `if' bodies.  */
+# define YYDPRINTF(Args)
+# define YYDSYMPRINT(Args)
+# define YYDSYMPRINTF(Title, Token, Value, Location)
+
+#endif /* !YYDEBUG */
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH ]b4_stack_depth_init[
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   SIZE_MAX < YYMAXDEPTH * sizeof (GLRStackItem)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#if YYMAXDEPTH == 0
+# undef YYMAXDEPTH
+#endif
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH ]b4_stack_depth_max[
+#endif
+
+/* Minimum number of free items on the stack allowed after an
+   allocation.  This is to allow allocation and initialization
+   to be completed by functions that call expandGLRStack before the
+   stack is expanded, thus insuring that all necessary pointers get
+   properly redirected to new data. */
+#define YYHEADROOM 2
+
+#if (! defined (YYSTACKEXPANDABLE) \
+     && (! defined (__cplusplus) \
+	 || (]b4_location_if([YYLTYPE_IS_TRIVIAL && ])[YYSTYPE_IS_TRIVIAL)))
+#define YYSTACKEXPANDABLE 1
+#else
+#define YYSTACKEXPANDABLE 0
+#endif
+
+/** State numbers, as in LALR(1) machine */
+typedef int yyStateNum;
+
+/** Rule numbers, as in LALR(1) machine */
+typedef int yyRuleNum;
+
+/** Grammar symbol */
+typedef short yySymbol;
+
+/** Item references, as in LALR(1) machine */
+typedef short yyItemNum;
+
+typedef struct yyGLRState yyGLRState;
+typedef struct yySemanticOption yySemanticOption;
+typedef union yyGLRStackItem yyGLRStackItem;
+typedef struct yyGLRStack yyGLRStack;
+typedef struct yyGLRStateSet yyGLRStateSet;
+
+struct yyGLRState {
+  bool yyisState;
+  bool yyresolved;
+  yyStateNum yylrState;
+  yyGLRState* yypred;
+  size_t yyposn;
+  union {
+    yySemanticOption* yyfirstVal;
+    YYSTYPE yysval;
+  } yysemantics;
+  YYLTYPE yyloc;
+};
+
+struct yyGLRStateSet {
+  yyGLRState** yystates;
+  size_t yysize, yycapacity;
+};
+
+struct yySemanticOption {
+  bool yyisState;
+  yyRuleNum yyrule;
+  yyGLRState* yystate;
+  yySemanticOption* yynext;
+};
+
+union yyGLRStackItem {
+  yyGLRState yystate;
+  yySemanticOption yyoption;
+};
+
+struct yyGLRStack {
+  int yyerrflag;
+  int yyerrState;
+]b4_pure_if(
+[
+  int yyerrcnt;
+  int yyrawchar;
+])[
+  yySymbol* yytokenp;
+  jmp_buf yyexception_buffer;
+  yyGLRStackItem* yyitems;
+  yyGLRStackItem* yynextFree;
+  int yyspaceLeft;
+  yyGLRState* yysplitPoint;
+  yyGLRState* yylastDeleted;
+  yyGLRStateSet yytops;
+};
+
+static void yyinitGLRStack (yyGLRStack* yystack, size_t yysize);
+static void yyexpandGLRStack (yyGLRStack* yystack]b4_pure_formals[);
+static void yyfreeGLRStack (yyGLRStack* yystack);
+
+static void
+yyFail (yyGLRStack* yystack]b4_pure_formals[, const char* yyformat, ...)
+{
+  yystack->yyerrflag = 1;
+  if (yyformat != NULL)
+    {
+      char yymsg[256];
+      va_list yyap;
+      va_start (yyap, yyformat);
+      vsprintf (yymsg, yyformat, yyap);
+      yyerror (]b4_yyerror_args[yymsg);
+    }
+  longjmp (yystack->yyexception_buffer, 1);
+}
+
+#if YYDEBUG || YYERROR_VERBOSE
+/** A printable representation of TOKEN.  Valid until next call to
+ *  tokenName. */
+static inline const char*
+yytokenName (yySymbol yytoken)
+{
+  return yytname[yytoken];
+}
+#endif
+
+/** Perform user action for rule number YYN, with RHS length YYRHSLEN,
+ *  and top stack item YYVSP.  YYLVALP points to place to put semantic
+ *  value ($$), and yylocp points to place for location information
+ *  (@@$). Returns yyok for normal return, yyaccept for YYACCEPT,
+ *  yyerr for YYERROR, yyabort for YYABORT. */
+static YYRESULTTAG
+yyuserAction (yyRuleNum yyn, int yyrhslen, yyGLRStackItem* yyvsp,
+	      YYSTYPE* yyvalp, YYLTYPE* yylocp, yyGLRStack* yystack
+              ]b4_user_formals[)
+{
+  /* Avoid `unused' warnings in there are no $n. */
+  (void) yystack;
+
+  if (yyrhslen == 0)
+    {
+      *yyvalp = yyval_default;
+      *yylocp = yyloc_default;
+    }
+  else
+    {
+      *yyvalp = yyvsp[1-yyrhslen].yystate.yysemantics.yysval;
+      *yylocp = yyvsp[1-yyrhslen].yystate.yyloc;
+    }
+# undef yyerrok
+# define yyerrok (yystack->yyerrState = 0)
+# undef YYACCEPT
+# define YYACCEPT return yyaccept
+# undef YYABORT
+# define YYABORT return yyabort
+# undef YYERROR
+# define YYERROR return yyerr
+# undef YYRECOVERING
+# define YYRECOVERING (yystack->yyerrState != 0)
+# undef yyclearin
+# define yyclearin (yychar = *(yystack->yytokenp) = YYEMPTY)
+# undef YYBACKUP
+# define YYBACKUP(Token, Value)						     \
+  do {									     \
+    yyerror (]b4_yyerror_args["syntax error: cannot back up");		     \
+    YYERROR;								     \
+  } while (0)
+
+]
+   switch (yyn)
+     {
+       b4_actions
+     }
+
+   return yyok;
+# undef yyerrok
+# undef YYABORT
+# undef YYACCEPT
+# undef YYERROR
+# undef YYBACKUP
+# undef yyclearin
+# undef YYRECOVERING
+/* Line __line__ of glr.c.  */
+b4_syncline([@oline@], [@ofile@])
+}
+
+
+static YYSTYPE
+yyuserMerge (int yyn, YYSTYPE* yy0, YYSTYPE* yy1)
+{
+  YYSTYPE yyval = *yy0;
+  /* `Use' the arguments.  */
+  (void) yy0;
+  (void) yy1;
+
+  switch (yyn)
+    {
+      b4_mergers
+    }
+  return yyval;
+}
+[
+			      /* Bison grammar-table manipulation.  */
+
+]b4_yydestruct_generate([b4_c_ansi_function_def])[
+
+/** Number of symbols composing the right hand side of rule #RULE. */
+static inline int
+yyrhsLength (yyRuleNum yyrule)
+{
+  return yyr2[yyrule];
+}
+
+/** Left-hand-side symbol for rule #RULE. */
+static inline yySymbol
+yylhsNonterm (yyRuleNum yyrule)
+{
+  return yyr1[yyrule];
+}
+
+#define yyis_pact_ninf(yystate) \
+  ]m4_if(m4_eval(b4_pact_ninf < b4_pact_min), 1,
+	 0,
+	 ((yystate) == YYPACT_NINF))[
+
+/** True iff LR state STATE has only a default reduction (regardless
+ *  of token). */
+static inline bool
+yyisDefaultedState (yyStateNum yystate)
+{
+  return yyis_pact_ninf (yypact[yystate]);
+}
+
+/** The default reduction for STATE, assuming it has one. */
+static inline yyRuleNum
+yydefaultAction (yyStateNum yystate)
+{
+  return yydefact[yystate];
+}
+
+#define yyis_table_ninf(yytable_value) \
+  ]m4_if(m4_eval(b4_table_ninf < b4_table_min), 1,
+	 0,
+	 ((yytable_value) == YYTABLE_NINF))[
+
+/** Set *YYACTION to the action to take in YYSTATE on seeing YYTOKEN.
+ *  Result R means
+ *    R < 0:  Reduce on rule -R.
+ *    R = 0:  Error.
+ *    R > 0:  Shift to state R.
+ *  Set *CONFLICTS to a pointer into yyconfl to 0-terminated list of
+ *  conflicting reductions.
+ */
+static inline void
+yygetLRActions (yyStateNum yystate, int yytoken,
+	        int* yyaction, const short** yyconflicts)
+{
+  int yyindex = yypact[yystate] + yytoken;
+  if (yyindex < 0 || YYLAST < yyindex || yycheck[yyindex] != yytoken)
+    {
+      *yyaction = -yydefact[yystate];
+      *yyconflicts = yyconfl;
+    }
+  else if (! yyis_table_ninf (yytable[yyindex]))
+    {
+      *yyaction = yytable[yyindex];
+      *yyconflicts = yyconfl + yyconflp[yyindex];
+    }
+  else
+    {
+      *yyaction = 0;
+      *yyconflicts = yyconfl + yyconflp[yyindex];
+    }
+}
+
+static inline yyStateNum
+yyLRgotoState (yyStateNum yystate, yySymbol yylhs)
+{
+  int yyr;
+  yyr = yypgoto[yylhs - YYNTOKENS] + yystate;
+  if (0 <= yyr && yyr <= YYLAST && yycheck[yyr] == yystate)
+    return yytable[yyr];
+  else
+    return yydefgoto[yylhs - YYNTOKENS];
+}
+
+static inline bool
+yyisShiftAction (int yyaction)
+{
+  return 0 < yyaction;
+}
+
+static inline bool
+yyisErrorAction (int yyaction)
+{
+  return yyaction == 0;
+}
+
+				/* GLRStates */
+
+static void
+yyaddDeferredAction (yyGLRStack* yystack, yyGLRState* yystate,
+		     yyGLRState* rhs, yyRuleNum yyrule]b4_pure_formals[)
+{
+  yySemanticOption* yynewItem;
+  yynewItem = &yystack->yynextFree->yyoption;
+  yystack->yyspaceLeft -= 1;
+  yystack->yynextFree += 1;
+  yynewItem->yyisState = yyfalse;
+  yynewItem->yystate = rhs;
+  yynewItem->yyrule = yyrule;
+  yynewItem->yynext = yystate->yysemantics.yyfirstVal;
+  yystate->yysemantics.yyfirstVal = yynewItem;
+  if (yystack->yyspaceLeft < YYHEADROOM)
+    yyexpandGLRStack (yystack]b4_pure_args[);
+}
+
+				/* GLRStacks */
+
+/** Initialize SET to a singleton set containing an empty stack. */
+static void
+yyinitStateSet (yyGLRStateSet* yyset)
+{
+  yyset->yysize = 1;
+  yyset->yycapacity = 16;
+  yyset->yystates = (yyGLRState**) malloc (16 * sizeof (yyset->yystates[0]));
+  yyset->yystates[0] = NULL;
+}
+
+static void yyfreeStateSet (yyGLRStateSet* yyset)
+{
+  free (yyset->yystates);
+}
+
+/** Initialize STACK to a single empty stack, with total maximum
+ *  capacity for all stacks of SIZE. */
+static void
+yyinitGLRStack (yyGLRStack* yystack, size_t yysize)
+{
+  yystack->yyerrflag = 0;
+  yystack->yyerrState = 0;
+  yynerrs = 0;
+  yystack->yyspaceLeft = yysize;
+  yystack->yynextFree = yystack->yyitems =
+    (yyGLRStackItem*) malloc (yysize * sizeof (yystack->yynextFree[0]));
+  yystack->yysplitPoint = NULL;
+  yystack->yylastDeleted = NULL;
+  yyinitStateSet (&yystack->yytops);
+}
+
+#define YYRELOC(YYFROMITEMS,YYTOITEMS,YYX,YYTYPE) \
+  &((YYTOITEMS) - ((YYFROMITEMS) - (yyGLRStackItem*) (YYX)))->YYTYPE
+
+/** If STACK is expandable, extend it.  WARNING: Pointers into the
+    stack from outside should be considered invalid after this call.
+    We always expand when there are 1 or fewer items left AFTER an
+    allocation, so that we can avoid having external pointers exist
+    across an allocation. */
+static void
+yyexpandGLRStack (yyGLRStack* yystack]b4_pure_formals[)
+{
+#if YYSTACKEXPANDABLE
+  yyGLRStack yynewStack;
+  yyGLRStackItem* yyp0, *yyp1;
+  size_t yysize, yynewSize;
+  size_t yyn;
+  yysize = yystack->yynextFree - yystack->yyitems;
+  if (YYMAXDEPTH <= yysize)
+    yyFail (yystack][]b4_pure_args[, "parser stack overflow");
+  yynewSize = 2*yysize;
+  if (YYMAXDEPTH < yynewSize)
+    yynewSize = YYMAXDEPTH;
+  yyinitGLRStack (&yynewStack, yynewSize);
+  for (yyp0 = yystack->yyitems, yyp1 = yynewStack.yyitems, yyn = yysize;
+       0 < yyn;
+       yyn -= 1, yyp0 += 1, yyp1 += 1)
+    {
+      *yyp1 = *yyp0;
+      if (*(bool*) yyp0)
+	{
+	  yyGLRState* yys0 = &yyp0->yystate;
+	  yyGLRState* yys1 = &yyp1->yystate;
+	  if (yys0->yypred != NULL)
+	    yys1->yypred =
+	      YYRELOC (yyp0, yyp1, yys0->yypred, yystate);
+	  if (! yys0->yyresolved && yys0->yysemantics.yyfirstVal != NULL)
+	    yys1->yysemantics.yyfirstVal =
+	      YYRELOC(yyp0, yyp1, yys0->yysemantics.yyfirstVal, yyoption);
+	}
+      else
+	{
+	  yySemanticOption* yyv0 = &yyp0->yyoption;
+	  yySemanticOption* yyv1 = &yyp1->yyoption;
+	  if (yyv0->yystate != NULL)
+	    yyv1->yystate = YYRELOC (yyp0, yyp1, yyv0->yystate, yystate);
+	  if (yyv0->yynext != NULL)
+	    yyv1->yynext = YYRELOC (yyp0, yyp1, yyv0->yynext, yyoption);
+	}
+    }
+  if (yystack->yysplitPoint != NULL)
+    yystack->yysplitPoint = YYRELOC (yystack->yyitems, yynewStack.yyitems,
+				 yystack->yysplitPoint, yystate);
+
+  for (yyn = 0; yyn < yystack->yytops.yysize; yyn += 1)
+    if (yystack->yytops.yystates[yyn] != NULL)
+      yystack->yytops.yystates[yyn] =
+	YYRELOC (yystack->yyitems, yynewStack.yyitems,
+		 yystack->yytops.yystates[yyn], yystate);
+  free (yystack->yyitems);
+  yystack->yyitems = yynewStack.yyitems;
+  yystack->yynextFree = yynewStack.yynextFree + yysize;
+  yystack->yyspaceLeft = yynewStack.yyspaceLeft - yysize;
+
+#else
+
+  yyFail (yystack][]b4_lpure_args[, "parser stack overflow");
+#endif
+}
+
+static void
+yyfreeGLRStack (yyGLRStack* yystack)
+{
+  free (yystack->yyitems);
+  yyfreeStateSet (&yystack->yytops);
+}
+
+/** Assuming that S is a GLRState somewhere on STACK, update the
+ *  splitpoint of STACK, if needed, so that it is at least as deep as
+ *  S. */
+static inline void
+yyupdateSplit (yyGLRStack* yystack, yyGLRState* yys)
+{
+  if (yystack->yysplitPoint != NULL && yystack->yysplitPoint > yys)
+    yystack->yysplitPoint = yys;
+}
+
+/** Invalidate stack #K in STACK. */
+static inline void
+yymarkStackDeleted (yyGLRStack* yystack, int yyk)
+{
+  if (yystack->yytops.yystates[yyk] != NULL)
+    yystack->yylastDeleted = yystack->yytops.yystates[yyk];
+  yystack->yytops.yystates[yyk] = NULL;
+}
+
+/** Undelete the last stack that was marked as deleted.  Can only be
+    done once after a deletion, and only when all other stacks have
+    been deleted. */
+static void
+yyundeleteLastStack (yyGLRStack* yystack)
+{
+  if (yystack->yylastDeleted == NULL || yystack->yytops.yysize != 0)
+    return;
+  yystack->yytops.yystates[0] = yystack->yylastDeleted;
+  yystack->yytops.yysize = 1;
+  YYDPRINTF ((stderr, "Restoring last deleted stack as stack #0.\n"));
+  yystack->yylastDeleted = NULL;
+}
+
+static inline void
+yyremoveDeletes (yyGLRStack* yystack)
+{
+  size_t yyi, yyj;
+  yyi = yyj = 0;
+  while (yyj < yystack->yytops.yysize)
+    {
+      if (yystack->yytops.yystates[yyi] == NULL)
+	{
+	  if (yyi == yyj)
+	    {
+	      YYDPRINTF ((stderr, "Removing dead stacks.\n"));
+	    }
+	  yystack->yytops.yysize -= 1;
+	}
+      else
+	{
+	  yystack->yytops.yystates[yyj] = yystack->yytops.yystates[yyi];
+	  if (yyj != yyi)
+	    {
+	      YYDPRINTF ((stderr, "Rename stack %d -> %d.\n", yyi, yyj));
+	    }
+	  yyj += 1;
+	}
+      yyi += 1;
+    }
+}
+
+/** Shift to a new state on stack #K of STACK, corresponding to LR state
+ * LRSTATE, at input position POSN, with (resolved) semantic value SVAL. */
+static inline void
+yyglrShift (yyGLRStack* yystack, int yyk, yyStateNum yylrState, size_t yyposn,
+	    YYSTYPE yysval, YYLTYPE* yylocp]b4_user_formals[)
+{
+  yyGLRStackItem* yynewItem;
+
+  yynewItem = yystack->yynextFree;
+  yystack->yynextFree += 1;
+  yystack->yyspaceLeft -= 1;
+  yynewItem->yystate.yyisState = yytrue;
+  yynewItem->yystate.yylrState = yylrState;
+  yynewItem->yystate.yyposn = yyposn;
+  yynewItem->yystate.yyresolved = yytrue;
+  yynewItem->yystate.yypred = yystack->yytops.yystates[yyk];
+  yystack->yytops.yystates[yyk] = &yynewItem->yystate;
+  yynewItem->yystate.yysemantics.yysval = yysval;
+  yynewItem->yystate.yyloc = *yylocp;
+  if (yystack->yyspaceLeft < YYHEADROOM)
+    yyexpandGLRStack (yystack]b4_pure_args[);
+}
+
+/** Shift to a new state on stack #K of STACK, to a new state
+ *  corresponding to LR state LRSTATE, at input position POSN, with
+ * the (unresolved) semantic value of RHS under the action for RULE. */
+static inline void
+yyglrShiftDefer (yyGLRStack* yystack, int yyk, yyStateNum yylrState,
+		 size_t yyposn, yyGLRState* rhs, yyRuleNum yyrule]b4_pure_formals[)
+{
+  yyGLRStackItem* yynewItem;
+
+  yynewItem = yystack->yynextFree;
+  yynewItem->yystate.yyisState = yytrue;
+  yynewItem->yystate.yylrState = yylrState;
+  yynewItem->yystate.yyposn = yyposn;
+  yynewItem->yystate.yyresolved = yyfalse;
+  yynewItem->yystate.yypred = yystack->yytops.yystates[yyk];
+  yynewItem->yystate.yysemantics.yyfirstVal = NULL;
+  yystack->yytops.yystates[yyk] = &yynewItem->yystate;
+  yystack->yynextFree += 1;
+  yystack->yyspaceLeft -= 1;
+  yyaddDeferredAction (yystack, &yynewItem->yystate, rhs, yyrule]b4_pure_args[);
+}
+
+/** Pop the symbols consumed by reduction #RULE from the top of stack
+ *  #K of STACK, and perform the appropriate semantic action on their
+ *  semantic values.  Assumes that all ambiguities in semantic values
+ *  have been previously resolved. Set *VALP to the resulting value,
+ *  and *LOCP to the computed location (if any).  Return value is as
+ *  for userAction. */
+static inline YYRESULTTAG
+yydoAction (yyGLRStack* yystack, int yyk, yyRuleNum yyrule,
+ 	    YYSTYPE* yyvalp, YYLTYPE* yylocp]b4_user_formals[)
+{
+  int yynrhs = yyrhsLength (yyrule);
+
+  if (yystack->yysplitPoint == NULL)
+    {
+      /* Standard special case: single stack. */
+      yyGLRStackItem* rhs = (yyGLRStackItem*) yystack->yytops.yystates[yyk];
+      if (yyk != 0)
+	abort ();
+      yystack->yynextFree -= yynrhs;
+      yystack->yyspaceLeft += yynrhs;
+      yystack->yytops.yystates[0] = & yystack->yynextFree[-1].yystate;
+      if (yynrhs == 0)
+	{
+	  *yyvalp = yyval_default;
+	  *yylocp = yyloc_default;
+	}
+      else
+	{
+	  *yyvalp = rhs[1-yynrhs].yystate.yysemantics.yysval;
+	  *yylocp = rhs[1-yynrhs].yystate.yyloc;
+	}
+      return yyuserAction (yyrule, yynrhs, rhs,
+			   yyvalp, yylocp, yystack]b4_user_args[);
+    }
+  else
+    {
+      int yyi;
+      yyGLRState* yys;
+      yyGLRStackItem yyrhsVals[YYMAXRHS];
+      for (yyi = yynrhs-1, yys = yystack->yytops.yystates[yyk]; 0 <= yyi;
+	   yyi -= 1, yys = yys->yypred)
+	{
+	  if (! yys->yypred)
+	    abort ();
+	  yyrhsVals[yyi].yystate.yyresolved = yytrue;
+	  yyrhsVals[yyi].yystate.yysemantics.yysval = yys->yysemantics.yysval;
+	  yyrhsVals[yyi].yystate.yyloc = yys->yyloc;
+	}
+      yyupdateSplit (yystack, yys);
+      yystack->yytops.yystates[yyk] = yys;
+      if (yynrhs == 0)
+	{
+	  *yyvalp = yyval_default;
+	  *yylocp = yyloc_default;
+	}
+      else
+	{
+	  *yyvalp = yyrhsVals[0].yystate.yysemantics.yysval;
+	  *yylocp = yyrhsVals[0].yystate.yyloc;
+	}
+      return yyuserAction (yyrule, yynrhs, yyrhsVals + (yynrhs-1),
+			   yyvalp, yylocp, yystack]b4_user_args[);
+    }
+}
+
+#if !YYDEBUG
+# define YY_REDUCE_PRINT(K, Rule)
+#else
+# define YY_REDUCE_PRINT(K, Rule)	\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (K, Rule);		\
+} while (0)
+
+/*----------------------------------------------------------.
+| Report that the RULE is going to be reduced on stack #K.  |
+`----------------------------------------------------------*/
+
+static inline void
+yy_reduce_print (size_t yyk, yyRuleNum yyrule)
+{
+  int yyi;
+  unsigned int yylineno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack %d by rule %d (line %u), ",
+	     yyk, yyrule - 1, yylineno);
+  /* Print the symbols being reduced, and their result.  */
+  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
+    YYFPRINTF (stderr, "%s ", yytokenName (yyrhs[yyi]));
+  YYFPRINTF (stderr, "-> %s\n", yytokenName (yyr1[yyrule]));
+}
+#endif
+
+/** Pop items off stack #K of STACK according to grammar rule RULE,
+ *  and push back on the resulting nonterminal symbol.  Perform the
+ *  semantic action associated with RULE and store its value with the
+ *  newly pushed state, if FORCEEVAL or if STACK is currently
+ *  unambiguous.  Otherwise, store the deferred semantic action with
+ *  the new state.  If the new state would have an identical input
+ *  position, LR state, and predecessor to an existing state on the stack,
+ *  it is identified with that existing state, eliminating stack #K from
+ *  the STACK. In this case, the (necessarily deferred) semantic value is
+ *  added to the options for the existing state's semantic value.
+ */
+static inline YYRESULTTAG
+yyglrReduce (yyGLRStack* yystack, size_t yyk, yyRuleNum yyrule,
+             bool yyforceEval]b4_pure_formals[)
+{
+  size_t yyposn = yystack->yytops.yystates[yyk]->yyposn;
+
+  if (yyforceEval || yystack->yysplitPoint == NULL)
+    {
+      YYSTYPE yysval;
+      YYLTYPE yyloc;
+
+      YY_REDUCE_PRINT (yyk, yyrule);
+      YYCHK (yydoAction (yystack, yyk, yyrule, &yysval, &yyloc]b4_user_args[));
+      yyglrShift (yystack, yyk,
+		  yyLRgotoState (yystack->yytops.yystates[yyk]->yylrState,
+				 yylhsNonterm (yyrule)),
+		  yyposn, yysval, &yyloc]b4_user_args[);
+    }
+  else
+    {
+      size_t yyi;
+      int yyn;
+      yyGLRState* yys, *yys0 = yystack->yytops.yystates[yyk];
+      yyStateNum yynewLRState;
+
+      for (yys = yystack->yytops.yystates[yyk], yyn = yyrhsLength (yyrule);
+	   0 < yyn; yyn -= 1)
+	{
+	  yys = yys->yypred;
+	  if (! yys)
+	    abort ();
+	}
+      yyupdateSplit (yystack, yys);
+      yynewLRState = yyLRgotoState (yys->yylrState, yylhsNonterm (yyrule));
+      YYDPRINTF ((stderr,
+		  "Reduced stack %d by rule #%d; action deferred. "
+		  "Now in state %d.\n",
+		  yyk, yyrule-1, yynewLRState));
+      for (yyi = 0; yyi < yystack->yytops.yysize; yyi += 1)
+	if (yyi != yyk && yystack->yytops.yystates[yyi] != NULL)
+	  {
+	    yyGLRState* yyp, *yysplit = yystack->yysplitPoint;
+	    yyp = yystack->yytops.yystates[yyi];
+	    while (yyp != yys && yyp != yysplit && yyp->yyposn >= yyposn)
+	      {
+		if (yyp->yylrState == yynewLRState && yyp->yypred == yys)
+		  {
+		    yyaddDeferredAction (yystack, yyp, yys0, yyrule]b4_pure_args[);
+		    yymarkStackDeleted (yystack, yyk);
+		    YYDPRINTF ((stderr, "Merging stack %d into stack %d.\n",
+				yyk, yyi));
+		    return yyok;
+		  }
+		yyp = yyp->yypred;
+	      }
+	  }
+      yystack->yytops.yystates[yyk] = yys;
+      yyglrShiftDefer (yystack, yyk, yynewLRState, yyposn, yys0, yyrule]b4_pure_args[);
+    }
+  return yyok;
+}
+
+static int
+yysplitStack (yyGLRStack* yystack, int yyk)
+{
+  if (yystack->yysplitPoint == NULL)
+    {
+      if (yyk != 0)
+	abort ();
+      yystack->yysplitPoint = yystack->yytops.yystates[yyk];
+    }
+  if (yystack->yytops.yysize >= yystack->yytops.yycapacity)
+    {
+      yystack->yytops.yycapacity *= 2;
+      yystack->yytops.yystates =
+	(yyGLRState**) realloc (yystack->yytops.yystates,
+				yystack->yytops.yycapacity
+				* sizeof (yyGLRState*));
+    }
+  yystack->yytops.yystates[yystack->yytops.yysize]
+    = yystack->yytops.yystates[yyk];
+  yystack->yytops.yysize += 1;
+  return yystack->yytops.yysize-1;
+}
+
+/** True iff Y0 and Y1 represent identical options at the top level.
+ *  That is, they represent the same rule applied to RHS symbols
+ *  that produce the same terminal symbols. */
+static bool
+yyidenticalOptions (yySemanticOption* yyy0, yySemanticOption* yyy1)
+{
+  if (yyy0->yyrule == yyy1->yyrule)
+    {
+      yyGLRState *yys0, *yys1;
+      int yyn;
+      for (yys0 = yyy0->yystate, yys1 = yyy1->yystate,
+	   yyn = yyrhsLength (yyy0->yyrule);
+	   yyn > 0;
+	   yys0 = yys0->yypred, yys1 = yys1->yypred, yyn -= 1)
+	if (yys0->yyposn != yys1->yyposn)
+	  return yyfalse;
+      return yytrue;
+    }
+  else
+    return yyfalse;
+}
+
+/** Assuming identicalOptions (Y0,Y1), (destructively) merge the
+ *  alternative semantic values for the RHS-symbols of Y1 into the
+ *  corresponding semantic value sets of the symbols of Y0. */
+static void
+yymergeOptionSets (yySemanticOption* yyy0, yySemanticOption* yyy1)
+{
+  yyGLRState *yys0, *yys1;
+  int yyn;
+  for (yys0 = yyy0->yystate, yys1 = yyy1->yystate,
+       yyn = yyrhsLength (yyy0->yyrule);
+       yyn > 0;
+       yys0 = yys0->yypred, yys1 = yys1->yypred, yyn -= 1)
+    if (yys0 == yys1)
+      break;
+    else if (! yys0->yyresolved && ! yys1->yyresolved)
+      {
+	yySemanticOption* yyz;
+	for (yyz = yys0->yysemantics.yyfirstVal; yyz->yynext != NULL;
+	     yyz = yyz->yynext)
+	  continue;
+	yyz->yynext = yys1->yysemantics.yyfirstVal;
+      }
+}
+
+/** Y0 and Y1 represent two possible actions to take in a given
+ *  parsing state; return 0 if no combination is possible,
+ *  1 if user-mergeable, 2 if Y0 is preferred, 3 if Y1 is preferred. */
+static int
+yypreference (yySemanticOption* y0, yySemanticOption* y1)
+{
+  yyRuleNum r0 = y0->yyrule, r1 = y1->yyrule;
+  int p0 = yydprec[r0], p1 = yydprec[r1];
+
+  if (p0 == p1)
+    {
+      if (yymerger[r0] == 0 || yymerger[r0] != yymerger[r1])
+	return 0;
+      else
+	return 1;
+    }
+  if (p0 == 0 || p1 == 0)
+    return 0;
+  if (p0 < p1)
+    return 3;
+  if (p1 < p0)
+    return 2;
+  return 0;
+}
+
+static YYRESULTTAG yyresolveValue (yySemanticOption* yyoptionList,
+				   yyGLRStack* yystack, YYSTYPE* yyvalp,
+				   YYLTYPE* yylocp]b4_user_formals[);
+
+static YYRESULTTAG
+yyresolveStates (yyGLRState* yys, int yyn, yyGLRStack* yystack]b4_user_formals[)
+{
+  YYRESULTTAG yyflag;
+  if (0 < yyn)
+    {
+      if (! yys->yypred)
+	abort ();
+      yyflag = yyresolveStates (yys->yypred, yyn-1, yystack]b4_user_args[);
+      if (yyflag != yyok)
+	return yyflag;
+      if (! yys->yyresolved)
+	{
+	  yyflag = yyresolveValue (yys->yysemantics.yyfirstVal, yystack,
+				   &yys->yysemantics.yysval, &yys->yyloc
+				  ]b4_user_args[);
+	  if (yyflag != yyok)
+	    return yyflag;
+	  yys->yyresolved = yytrue;
+	}
+    }
+  return yyok;
+}
+
+static YYRESULTTAG
+yyresolveAction (yySemanticOption* yyopt, yyGLRStack* yystack,
+	         YYSTYPE* yyvalp, YYLTYPE* yylocp]b4_user_formals[)
+{
+  yyGLRStackItem yyrhsVals[YYMAXRHS];
+  int yynrhs, yyi;
+  yyGLRState* yys;
+
+  yynrhs = yyrhsLength (yyopt->yyrule);
+  YYCHK (yyresolveStates (yyopt->yystate, yynrhs, yystack]b4_user_args[));
+  for (yyi = yynrhs-1, yys = yyopt->yystate; 0 <= yyi;
+       yyi -= 1, yys = yys->yypred)
+    {
+      if (! yys->yypred)
+	abort ();
+      yyrhsVals[yyi].yystate.yyresolved = yytrue;
+      yyrhsVals[yyi].yystate.yysemantics.yysval = yys->yysemantics.yysval;
+      yyrhsVals[yyi].yystate.yyloc = yys->yyloc;
+    }
+  return yyuserAction (yyopt->yyrule, yynrhs, yyrhsVals + (yynrhs-1),
+		       yyvalp, yylocp, yystack]b4_user_args[);
+}
+
+#if YYDEBUG
+static void
+yyreportTree (yySemanticOption* yyx, int yyindent)
+{
+  int yynrhs = yyrhsLength (yyx->yyrule);
+  int yyi;
+  yyGLRState* yys;
+  yyGLRState* yystates[YYMAXRHS];
+  yyGLRState yyleftmost_state;
+
+  for (yyi = yynrhs, yys = yyx->yystate; 0 < yyi; yyi -= 1, yys = yys->yypred)
+    yystates[yyi] = yys;
+  if (yys == NULL)
+    {
+      yyleftmost_state.yyposn = 0;
+      yystates[0] = &yyleftmost_state;
+    }
+  else
+    yystates[0] = yys;
+
+  if (yyx->yystate->yyposn < yys->yyposn + 1)
+    YYFPRINTF (stderr, "%*s%s -> <Rule %d, empty>\n",
+	       yyindent, "", yytokenName (yylhsNonterm (yyx->yyrule)),
+	       yyx->yyrule);
+  else
+    YYFPRINTF (stderr, "%*s%s -> <Rule %d, tokens %d .. %d>\n",
+	       yyindent, "", yytokenName (yylhsNonterm (yyx->yyrule)),
+	       yyx->yyrule, yys->yyposn+1, yyx->yystate->yyposn);
+  for (yyi = 1; yyi <= yynrhs; yyi += 1)
+    {
+      if (yystates[yyi]->yyresolved)
+	{
+	  if (yystates[yyi-1]->yyposn+1 > yystates[yyi]->yyposn)
+	    YYFPRINTF (stderr, "%*s%s <empty>\n", yyindent+2, "",
+		       yytokenName (yyrhs[yyprhs[yyx->yyrule]+yyi-1]));
+	  else
+	    YYFPRINTF (stderr, "%*s%s <tokens %d .. %d>\n", yyindent+2, "",
+		       yytokenName (yyrhs[yyprhs[yyx->yyrule]+yyi-1]),
+		       yystates[yyi-1]->yyposn+1, yystates[yyi]->yyposn);
+	}
+      else
+	yyreportTree (yystates[yyi]->yysemantics.yyfirstVal, yyindent+2);
+    }
+}
+#endif
+
+static void
+yyreportAmbiguity (yySemanticOption* yyx0, yySemanticOption* yyx1,
+		   yyGLRStack* yystack]b4_pure_formals[)
+{
+  /* `Unused' warnings.  */
+  (void) yyx0;
+  (void) yyx1;
+
+#if YYDEBUG
+  YYFPRINTF (stderr, "Ambiguity detected.\n");
+  YYFPRINTF (stderr, "Option 1,\n");
+  yyreportTree (yyx0, 2);
+  YYFPRINTF (stderr, "\nOption 2,\n");
+  yyreportTree (yyx1, 2);
+  YYFPRINTF (stderr, "\n");
+#endif
+  yyFail (yystack][]b4_pure_args[, "ambiguity detected");
+}
+
+
+/** Resolve the ambiguity represented by OPTIONLIST, perform the indicated
+ *  actions, and return the result. */
+static YYRESULTTAG
+yyresolveValue (yySemanticOption* yyoptionList, yyGLRStack* yystack,
+		YYSTYPE* yyvalp, YYLTYPE* yylocp]b4_user_formals[)
+{
+  yySemanticOption* yybest;
+  yySemanticOption* yyp;
+  int yymerge;
+
+  yybest = yyoptionList;
+  yymerge = 0;
+  for (yyp = yyoptionList->yynext; yyp != NULL; yyp = yyp->yynext)
+    {
+      if (yyidenticalOptions (yybest, yyp))
+	yymergeOptionSets (yybest, yyp);
+      else
+	switch (yypreference (yybest, yyp))
+	  {
+	  case 0:
+	    yyreportAmbiguity (yybest, yyp, yystack]b4_pure_args[);
+	    break;
+	  case 1:
+	    yymerge = 1;
+	    break;
+	  case 2:
+	    break;
+	  case 3:
+	    yybest = yyp;
+	    yymerge = 0;
+	    break;
+	  }
+    }
+
+  if (yymerge)
+    {
+      int yyprec = yydprec[yybest->yyrule];
+      YYCHK (yyresolveAction (yybest, yystack, yyvalp, yylocp]b4_user_args[));
+      for (yyp = yybest->yynext; yyp != NULL; yyp = yyp->yynext)
+	{
+	  if (yyprec == yydprec[yyp->yyrule])
+	    {
+	      YYSTYPE yyval1;
+	      YYLTYPE yydummy;
+	      YYCHK (yyresolveAction (yyp, yystack, &yyval1, &yydummy]b4_user_args[));
+	      *yyvalp = yyuserMerge (yymerger[yyp->yyrule], yyvalp, &yyval1);
+	    }
+	}
+      return yyok;
+    }
+  else
+    return yyresolveAction (yybest, yystack, yyvalp, yylocp]b4_user_args[);
+}
+
+static YYRESULTTAG
+yyresolveStack (yyGLRStack* yystack]b4_user_formals[)
+{
+  if (yystack->yysplitPoint != NULL)
+    {
+      yyGLRState* yys;
+      int yyn;
+
+      for (yyn = 0, yys = yystack->yytops.yystates[0];
+	   yys != yystack->yysplitPoint;
+	   yys = yys->yypred, yyn += 1)
+	continue;
+      YYCHK (yyresolveStates (yystack->yytops.yystates[0], yyn, yystack
+			     ]b4_user_args[));
+    }
+  return yyok;
+}
+
+static void
+yycompressStack (yyGLRStack* yystack)
+{
+  yyGLRState* yyp, *yyq, *yyr;
+
+  if (yystack->yytops.yysize != 1 || yystack->yysplitPoint == NULL)
+    return;
+
+  for (yyp = yystack->yytops.yystates[0], yyq = yyp->yypred, yyr = NULL;
+       yyp != yystack->yysplitPoint;
+       yyr = yyp, yyp = yyq, yyq = yyp->yypred)
+    yyp->yypred = yyr;
+
+  yystack->yyspaceLeft += yystack->yynextFree - yystack->yyitems;
+  yystack->yynextFree = ((yyGLRStackItem*) yystack->yysplitPoint) + 1;
+  yystack->yyspaceLeft -= yystack->yynextFree - yystack->yyitems;
+  yystack->yysplitPoint = NULL;
+  yystack->yylastDeleted = NULL;
+
+  while (yyr != NULL)
+    {
+      yystack->yynextFree->yystate = *yyr;
+      yyr = yyr->yypred;
+      yystack->yynextFree->yystate.yypred = & yystack->yynextFree[-1].yystate;
+      yystack->yytops.yystates[0] = &yystack->yynextFree->yystate;
+      yystack->yynextFree += 1;
+      yystack->yyspaceLeft -= 1;
+    }
+}
+
+static YYRESULTTAG
+yyprocessOneStack (yyGLRStack* yystack, int yyk,
+	           size_t yyposn, YYSTYPE* yylvalp, YYLTYPE* yyllocp
+		  ]b4_user_formals[)
+{
+  int yyaction;
+  const short* yyconflicts;
+  yyRuleNum yyrule;
+  yySymbol* const yytokenp = yystack->yytokenp;
+
+  while (yystack->yytops.yystates[yyk] != NULL)
+    {
+      yyStateNum yystate = yystack->yytops.yystates[yyk]->yylrState;
+      YYDPRINTF ((stderr, "Stack %d Entering state %d\n", yyk, yystate));
+
+      if (yystate == YYFINAL)
+	abort ();
+      if (yyisDefaultedState (yystate))
+	{
+	  yyrule = yydefaultAction (yystate);
+	  if (yyrule == 0)
+	    {
+	      YYDPRINTF ((stderr, "Stack %d dies.\n", yyk));
+	      yymarkStackDeleted (yystack, yyk);
+	      return yyok;
+	    }
+	  YYCHK (yyglrReduce (yystack, yyk, yyrule, yyfalse]b4_lpure_args[));
+	}
+      else
+	{
+	  if (*yytokenp == YYEMPTY)
+	    {
+	      YYDPRINTF ((stderr, "Reading a token: "));
+	      yychar = YYLEX;
+	      *yytokenp = YYTRANSLATE (yychar);
+	      YYDSYMPRINTF ("Next token is", *yytokenp, yylvalp, yyllocp);
+	    }
+	  yygetLRActions (yystate, *yytokenp, &yyaction, &yyconflicts);
+
+	  while (*yyconflicts != 0)
+	    {
+	      int yynewStack = yysplitStack (yystack, yyk);
+	      YYDPRINTF ((stderr, "Splitting off stack %d from %d.\n",
+			  yynewStack, yyk));
+	      YYCHK (yyglrReduce (yystack, yynewStack,
+				  *yyconflicts, yyfalse]b4_lpure_args[));
+	      YYCHK (yyprocessOneStack (yystack, yynewStack, yyposn,
+					yylvalp, yyllocp]b4_user_args[));
+	      yyconflicts += 1;
+	    }
+
+	  if (yyisShiftAction (yyaction))
+	    {
+	      YYDPRINTF ((stderr, "Shifting token %s on stack %d, ",
+			  yytokenName (*yytokenp), yyk));
+	      yyglrShift (yystack, yyk, yyaction, yyposn+1,
+			  *yylvalp, yyllocp]b4_user_args[);
+	      YYDPRINTF ((stderr, "which is now in state #%d\n",
+			  yystack->yytops.yystates[yyk]->yylrState));
+	      break;
+	    }
+	  else if (yyisErrorAction (yyaction))
+	    {
+	      YYDPRINTF ((stderr, "Stack %d dies.\n", yyk));
+	      yymarkStackDeleted (yystack, yyk);
+	      break;
+	    }
+	  else
+	    YYCHK (yyglrReduce (yystack, yyk, -yyaction, yyfalse]b4_lpure_args[));
+	}
+    }
+  return yyok;
+}
+
+static void
+yyreportSyntaxError (yyGLRStack* yystack,
+		     YYSTYPE* yylvalp, YYLTYPE* yyllocp]b4_user_formals[)
+{
+  /* `Unused' warnings. */
+  (void) yylvalp;
+  (void) yyllocp;
+
+  if (yystack->yyerrState == 0)
+    {
+#if YYERROR_VERBOSE
+      yySymbol* const yytokenp = yystack->yytokenp;
+      int yyn, yyx, yycount;
+      size_t yysize;
+      const char* yyprefix;
+      char* yyp;
+      char* yymsg;
+      yyn = yypact[yystack->yytops.yystates[0]->yylrState];
+      if (YYPACT_NINF < yyn && yyn < YYLAST)
+	{
+	  yycount = 0;
+	  /* Start YYX at -YYN if negative to avoid negative indexes in
+	     YYCHECK.  */
+	  yysize = sizeof ("syntax error, unexpected ")
+	    + strlen (yytokenName (*yytokenp));
+	  yyprefix = ", expecting ";
+	  for (yyx = yyn < 0 ? -yyn : 0; yyx < yytname_size && yycount <= 5;
+	       yyx += 1)
+	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	      yysize += strlen (yytokenName (yyx)) + strlen (yyprefix),
+		yycount += 1, yyprefix = " or ";
+	  yymsg = yyp = (char*) malloc (yysize);
+	  sprintf (yyp, "syntax error, unexpected %s",
+		   yytokenName (*yytokenp));
+	  yyp += strlen (yyp);
+	  if (yycount < 5)
+	    {
+	      yyprefix = ", expecting ";
+	      for (yyx = yyn < 0 ? -yyn : 0; yyx < yytname_size; yyx += 1)
+		if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+		  {
+		    sprintf (yyp, "%s%s", yyprefix, yytokenName (yyx));
+		    yyp += strlen (yyp);
+		    yyprefix = " or ";
+		  }
+	    }
+	  yyerror (]b4_lyyerror_args[yymsg);
+	  free (yymsg);
+	}
+      else
+#endif
+	yyerror (]b4_lyyerror_args["syntax error");
+      yynerrs += 1;
+    }
+}
+
+/* Recover from a syntax error on YYSTACK, assuming that YYTOKENP,
+   YYLVALP, and YYLLOCP point to the syntactic category, semantic
+   value, and location of the lookahead.  */
+static void
+yyrecoverSyntaxError (yyGLRStack* yystack,
+		      YYSTYPE* yylvalp, YYLTYPE* yyllocp]b4_user_formals[)
+{
+  yySymbol* const yytokenp = yystack->yytokenp;
+  size_t yyk;
+  int yyj;
+
+  if (yystack->yyerrState == 0)
+    yystack->yyerrState = 3;
+  else if (yystack->yyerrState == 3)
+    /* We just shifted the error token and (perhaps) took some
+       reductions.  Skip tokens until we can proceed.  */
+    while (yytrue)
+      {
+	if (*yytokenp == YYEOF)
+	  {
+	    /* Now pop stack until we find a state that shifts the
+	       error token.  */
+	    while (yystack->yytops.yystates[0] != NULL)
+	      {
+		yyGLRState *yys = yystack->yytops.yystates[0];
+		YYDSYMPRINTF ("Error: popping",
+			      yystos[yys->yylrState],
+			      &yys->yysemantics.yysval, &yys->yyloc);
+		yydestruct (yystos[yys->yylrState],
+			    &yys->yysemantics.yysval]b4_location_if([, &yys->yyloc])[);
+		yystack->yytops.yystates[0] = yys->yypred;
+		yystack->yynextFree -= 1;
+		yystack->yyspaceLeft += 1;
+	      }
+	    yyFail (yystack][]b4_lpure_args[, NULL);
+	  }
+	if (*yytokenp != YYEMPTY)
+	  {
+	    YYDSYMPRINTF ("Error: discarding", *yytokenp, yylvalp, yyllocp);
+	    yydestruct (*yytokenp, yylvalp]b4_location_if([, yyllocp])[);
+	  }
+	YYDPRINTF ((stderr, "Reading a token: "));
+	yychar = YYLEX;
+	*yytokenp = YYTRANSLATE (yychar);
+	YYDSYMPRINTF ("Next token is", *yytokenp, yylvalp, yyllocp);
+	yyj = yypact[yystack->yytops.yystates[0]->yylrState];
+	if (yyis_pact_ninf (yyj))
+	  /* Something's not right; we shouldn't be here.  */
+	  yyFail (yystack][]b4_lpure_args[, NULL);
+	yyj += *yytokenp;
+	if (yyj < 0 || YYLAST < yyj || yycheck[yyj] != *yytokenp)
+	  {
+	    if (yydefact[yystack->yytops.yystates[0]->yylrState] != 0)
+	      return;
+	  }
+	else if (yytable[yyj] != 0 && ! yyis_table_ninf (yytable[yyj]))
+	  return;
+      }
+
+  /* Reduce to one stack.  */
+  for (yyk = 0; yyk < yystack->yytops.yysize; yyk += 1)
+    if (yystack->yytops.yystates[yyk] != NULL)
+      break;
+  if (yyk >= yystack->yytops.yysize)
+    yyFail (yystack][]b4_lpure_args[, NULL);
+  for (yyk += 1; yyk < yystack->yytops.yysize; yyk += 1)
+    yymarkStackDeleted (yystack, yyk);
+  yyremoveDeletes (yystack);
+  yycompressStack (yystack);
+
+  /* Now pop stack until we find a state that shifts the error token. */
+  while (yystack->yytops.yystates[0] != NULL)
+    {
+      yyGLRState *yys = yystack->yytops.yystates[0];
+      yyj = yypact[yys->yylrState];
+      if (! yyis_pact_ninf (yyj))
+	{
+	  yyj += YYTERROR;
+	  if (0 <= yyj && yyj <= YYLAST && yycheck[yyj] == YYTERROR
+	      && yyisShiftAction (yytable[yyj]))
+	    {
+	      YYDPRINTF ((stderr, "Shifting error token, "));
+	      yyglrShift (yystack, 0, yytable[yyj],
+			  yys->yyposn, *yylvalp, yyllocp]b4_user_args[);
+	      break;
+	    }
+	}
+      YYDSYMPRINTF ("Error: popping",
+ 		    yystos[yys->yylrState],
+ 		    &yys->yysemantics.yysval, &yys->yyloc);
+      yydestruct (yystos[yys->yylrState],
+ 	          &yys->yysemantics.yysval]b4_location_if([, &yys->yyloc])[);
+      yystack->yytops.yystates[0] = yys->yypred;
+      yystack->yynextFree -= 1;
+      yystack->yyspaceLeft += 1;
+    }
+  if (yystack->yytops.yystates[0] == NULL)
+    yyFail (yystack][]b4_lpure_args[, NULL);
+}
+
+#define YYCHK1(YYE)							     \
+  do {									     \
+    switch (YYE) {							     \
+    default:								     \
+      break;								     \
+    case yyabort:							     \
+      yystack.yyerrflag = 1;						     \
+      goto yyDone;							     \
+    case yyaccept:							     \
+      yystack.yyerrflag = 0;						     \
+      goto yyDone;							     \
+    case yyerr:								     \
+      goto yyuser_error;						     \
+    }									     \
+  } while (0)
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+]b4_c_ansi_function_def([yyparse], [int], b4_parse_param)[
+{
+  yySymbol yytoken;
+  yyGLRStack yystack;
+  size_t yyposn;
+]b4_pure_if(
+[
+  YYSTYPE yylval;
+  YYLTYPE yylloc;
+  #undef yychar
+  #define yychar (yystack.yyrawchar)
+])[
+
+  YYSTYPE* const yylvalp = &yylval;
+  YYLTYPE* const yyllocp = &yylloc;
+
+  yyinitGLRStack (&yystack, YYINITDEPTH);
+  yystack.yytokenp = &yytoken;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  if (setjmp (yystack.yyexception_buffer) != 0)
+    goto yyDone;
+
+  yyglrShift (&yystack, 0, 0, 0, yyval_default, &yyloc_default]b4_user_args[);
+  yytoken = YYEMPTY;
+  yyposn = 0;
+
+  while (yytrue)
+    {
+      /* For efficiency, we have two loops, the first of which is
+	 specialized to deterministic operation (single stack, no
+	 potential ambiguity).  */
+      /* Standard mode */
+      while (yytrue)
+	{
+	  yyRuleNum yyrule;
+	  int yyaction;
+	  const short* yyconflicts;
+
+	  yyStateNum yystate = yystack.yytops.yystates[0]->yylrState;
+          YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+	  if (yystate == YYFINAL)
+	    goto yyDone;
+	  if (yyisDefaultedState (yystate))
+	    {
+	      yyrule = yydefaultAction (yystate);
+	      if (yyrule == 0)
+		{
+		  yyreportSyntaxError (&yystack, yylvalp, yyllocp]b4_user_args[);
+		  goto yyuser_error;
+		}
+	      YYCHK1 (yyglrReduce (&yystack, 0, yyrule, yytrue]b4_lpure_args[));
+	    }
+	  else
+	    {
+	      if (yytoken == YYEMPTY)
+		{
+		  YYDPRINTF ((stderr, "Reading a token: "));
+		  yychar = YYLEX;
+		  yytoken = YYTRANSLATE (yychar);
+                  YYDSYMPRINTF ("Next token is", yytoken, yylvalp, yyllocp);
+		}
+	      yygetLRActions (yystate, yytoken, &yyaction, &yyconflicts);
+	      if (*yyconflicts != 0)
+		break;
+	      if (yyisShiftAction (yyaction))
+		{
+		  YYDPRINTF ((stderr, "Shifting token %s, ",
+			      yytokenName (yytoken)));
+		  if (yytoken != YYEOF)
+		    yytoken = YYEMPTY;
+		  yyposn += 1;
+		  yyglrShift (&yystack, 0, yyaction, yyposn,
+		              yylval, yyllocp]b4_user_args[);
+		  if (0 < yystack.yyerrState)
+		    yystack.yyerrState -= 1;
+		}
+	      else if (yyisErrorAction (yyaction))
+		{
+		  yyreportSyntaxError (&yystack, yylvalp, yyllocp]b4_user_args[);
+		  goto yyuser_error;
+		}
+	      else
+		YYCHK1 (yyglrReduce (&yystack, 0, -yyaction, yytrue]b4_lpure_args[));
+	    }
+	}
+
+      while (yytrue)
+	{
+	  int yys;
+	  int yyn = yystack.yytops.yysize;
+	  for (yys = 0; yys < yyn; yys += 1)
+	    YYCHK1 (yyprocessOneStack (&yystack, yys, yyposn,
+				       yylvalp, yyllocp]b4_user_args[));
+	  yytoken = YYEMPTY;
+	  yyposn += 1;
+	  yyremoveDeletes (&yystack);
+	  if (yystack.yytops.yysize == 0)
+	    {
+	      yyundeleteLastStack (&yystack);
+	      if (yystack.yytops.yysize == 0)
+		yyFail (&yystack][]b4_lpure_args[, "syntax error");
+	      YYCHK1 (yyresolveStack (&yystack]b4_user_args[));
+	      YYDPRINTF ((stderr, "Returning to deterministic operation.\n"));
+	      yyreportSyntaxError (&yystack, yylvalp, yyllocp]b4_user_args[);
+	      goto yyuser_error;
+	    }
+	  else if (yystack.yytops.yysize == 1)
+	    {
+	      YYCHK1 (yyresolveStack (&yystack]b4_user_args[));
+	      YYDPRINTF ((stderr, "Returning to deterministic operation.\n"));
+	      yycompressStack (&yystack);
+	      break;
+	    }
+	}
+      continue;
+    yyuser_error:
+      yyrecoverSyntaxError (&yystack, yylvalp, yyllocp]b4_user_args[);
+      yyposn = yystack.yytops.yystates[0]->yyposn;
+    }
+ yyDone:
+  ;
+
+  yyfreeGLRStack (&yystack);
+  return yystack.yyerrflag;
+}
+
+/* DEBUGGING ONLY */
+static void yypstack (yyGLRStack* yystack, int yyk) ATTRIBUTE_UNUSED;
+static void yypdumpstack (yyGLRStack* yystack) ATTRIBUTE_UNUSED;
+
+static void
+yy_yypstack (yyGLRState* yys)
+{
+  if (yys->yypred)
+    {
+      yy_yypstack (yys->yypred);
+      fprintf (stderr, " -> ");
+    }
+  fprintf (stderr, "%d@@%lu", yys->yylrState, (unsigned long) yys->yyposn);
+}
+
+static void
+yypstates (yyGLRState* yyst)
+{
+  if (yyst == NULL)
+    fprintf (stderr, "<null>");
+  else
+    yy_yypstack (yyst);
+  fprintf (stderr, "\n");
+}
+
+static void
+yypstack (yyGLRStack* yystack, int yyk)
+{
+  yypstates (yystack->yytops.yystates[yyk]);
+}
+
+#define YYINDEX(YYX) 							     \
+    ((YYX) == NULL ? -1 : (yyGLRStackItem*) (YYX) - yystack->yyitems)
+
+
+static void
+yypdumpstack (yyGLRStack* yystack)
+{
+  yyGLRStackItem* yyp;
+  size_t yyi;
+  for (yyp = yystack->yyitems; yyp < yystack->yynextFree; yyp += 1)
+    {
+      fprintf (stderr, "%3lu. ", (unsigned long) (yyp - yystack->yyitems));
+      if (*(bool*) yyp)
+	{
+	  fprintf (stderr, "Res: %d, LR State: %d, posn: %lu, pred: %ld",
+		   yyp->yystate.yyresolved, yyp->yystate.yylrState,
+		   (unsigned long) yyp->yystate.yyposn,
+		   (long) YYINDEX (yyp->yystate.yypred));
+	  if (! yyp->yystate.yyresolved)
+	    fprintf (stderr, ", firstVal: %ld",
+		     (long) YYINDEX (yyp->yystate.yysemantics.yyfirstVal));
+	}
+      else
+	{
+	  fprintf (stderr, "Option. rule: %d, state: %ld, next: %ld",
+		   yyp->yyoption.yyrule,
+		   (long) YYINDEX (yyp->yyoption.yystate),
+		   (long) YYINDEX (yyp->yyoption.yynext));
+	}
+      fprintf (stderr, "\n");
+    }
+  fprintf (stderr, "Tops:");
+  for (yyi = 0; yyi < yystack->yytops.yysize; yyi += 1)
+    fprintf (stderr, "%lu: %ld; ", (unsigned long) yyi,
+	     (long) YYINDEX (yystack->yytops.yystates[yyi]));
+  fprintf (stderr, "\n");
+}
+]
+
+b4_epilogue
+m4_if(b4_defines_flag, 0, [],
+[@output @output_header_name@
+b4_copyright([Skeleton parser for GLR parsing with Bison], [2002])
+
+b4_token_defines(b4_tokens)
+
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+m4_ifdef([b4_stype],
+[b4_syncline([b4_stype_line], [b4_filename])
+typedef union m4_bregexp(b4_stype, [^{], [YYSTYPE ])b4_stype YYSTYPE;
+/* Line __line__ of glr.c.  */
+b4_syncline([@oline@], [@ofile@])],
+[typedef int YYSTYPE;])
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+b4_pure_if([],
+[extern YYSTYPE b4_prefix[]lval;])
+
+b4_location_if(
+[#if ! defined (YYLTYPE) && ! defined (YYLTYPE_IS_DECLARED)
+typedef struct YYLTYPE
+{
+  int first_line;
+  int first_column;
+  int last_line;
+  int last_column;
+} YYLTYPE;
+# define YYLTYPE_IS_DECLARED 1
+# define YYLTYPE_IS_TRIVIAL 1
+#endif
+
+m4_if(b4_pure, [0],
+[extern YYLTYPE b4_prefix[]lloc;])
+])
+])
diff -puN /dev/null parser/bison-1.875/lalr1.cc
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/bison-1.875/lalr1.cc	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,883 @@
+m4_divert(-1)
+# C++ skeleton for Bison
+# Copyright (C) 2002 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+# 02111-1307  USA
+
+## ---------------- ##
+## Default values.  ##
+## ---------------- ##
+
+# Stack parameters.
+m4_define_default([b4_stack_depth_init],  [200])
+
+# Default Parser class name.
+m4_define_default([b4_parser_class_name], [Parser])
+
+
+
+## ----------------- ##
+## Semantic Values.  ##
+## ----------------- ##
+
+
+# b4_lhs_value([TYPE])
+# --------------------
+# Expansion of $<TYPE>$.
+m4_define([b4_lhs_value],
+[yyval[]m4_ifval([$1], [.$1])])
+
+
+# b4_rhs_value(RULE-LENGTH, NUM, [TYPE])
+# --------------------------------------
+# Expansion of $<TYPE>NUM, where the current rule has RULE-LENGTH
+# symbols on RHS.
+m4_define([b4_rhs_value],
+[semantic_stack_@{m4_eval([$1 - $2])@}m4_ifval([$3], [.$3])])
+
+m4_define_default([b4_location_type], [Location])
+
+# b4_lhs_location()
+# -----------------
+# Expansion of @$.
+m4_define([b4_lhs_location],
+[yyloc])
+
+
+# b4_rhs_location(RULE-LENGTH, NUM)
+# ---------------------------------
+# Expansion of @NUM, where the current rule has RULE-LENGTH symbols
+# on RHS.
+m4_define([b4_rhs_location],
+[location_stack_@{m4_eval([$1 - $2])@}])
+
+
+m4_define([b4_inherit],
+          [m4_ifdef([b4_root],
+		    [: public b4_root
+],
+		    [])])
+
+m4_define([b4_param],
+	  [m4_ifdef([b4_root],
+	            [,
+            const Param& param],
+		    [])])
+
+m4_define([b4_constructor],
+	  [m4_ifdef([b4_root],
+		    [b4_root (param),
+      ],
+		    [])])
+
+
+# We do want M4 expansion after # for CPP macros.
+m4_changecom()
+m4_divert(0)dnl
+@output @output_header_name@
+b4_copyright([C++ Skeleton parser for LALR(1) parsing with Bison],
+             [2002])[
+/* FIXME: This is wrong, we want computed header guards.
+   I don't know why the macros are missing now. :( */
+#ifndef PARSER_HEADER_H
+# define PARSER_HEADER_H
+
+#include "stack.hh"
+#include "location.hh"
+
+#include <string>
+#include <iostream>
+
+/* Using locations.  */
+#define YYLSP_NEEDED ]b4_locations_flag[
+
+]b4_token_defines(b4_tokens)[
+
+/* Copy the first part of user declarations.  */
+]b4_pre_prologue[
+
+]/* Line __line__ of lalr1.cc.  */
+b4_syncline([@oline@], [@ofile@])[
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG ]b4_debug[
+#endif
+
+/* Enabling verbose error message.  */
+#ifndef YYERROR_VERBOSE
+# define YYERROR_VERBOSE ]b4_error_verbose[
+#endif
+
+#ifndef YYSTYPE
+]m4_ifdef([b4_stype],
+[b4_syncline([b4_stype_line], [b4_filename])
+typedef union b4_stype yystype;
+/* Line __line__ of lalr1.cc.  */
+b4_syncline([@oline@], [@ofile@])],
+[typedef int yystype;])[
+# define YYSTYPE yystype
+#endif
+
+/* Copy the second part of user declarations.  */
+]b4_post_prologue[
+
+]/* Line __line__ of lalr1.cc.  */
+b4_syncline([@oline@], [@ofile@])[
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N) \
+   Current.last_line = Rhs[N].last_line; \
+   Current.last_column = Rhs[N].last_column;
+#endif
+
+namespace yy
+{
+  class ]b4_parser_class_name[;
+
+  template < typename P >
+  struct Traits
+  {
+  };
+
+  template < >
+  struct Traits< ]b4_parser_class_name[ >
+  {
+    typedef ]b4_int_type_for([b4_translate])[ TokenNumberType;
+    typedef ]b4_int_type_for([b4_rhs])[       RhsNumberType;
+    typedef int      StateType;
+    typedef yystype  SemanticType;
+    typedef ]b4_location_type[ LocationType;
+  };
+}
+
+namespace yy
+{
+  class ]b4_parser_class_name b4_inherit[
+  {
+  public:
+
+    typedef Traits< ]b4_parser_class_name[ >::TokenNumberType TokenNumberType;
+    typedef Traits< ]b4_parser_class_name[ >::RhsNumberType   RhsNumberType;
+    typedef Traits< ]b4_parser_class_name[ >::StateType       StateType;
+    typedef Traits< ]b4_parser_class_name[ >::SemanticType    SemanticType;
+    typedef Traits< ]b4_parser_class_name[ >::LocationType    LocationType;
+
+    typedef Stack< StateType >    StateStack;
+    typedef Stack< SemanticType > SemanticStack;
+    typedef Stack< LocationType > LocationStack;
+
+#if YYLSP_NEEDED
+    ]b4_parser_class_name[ (bool debug,
+	    LocationType initlocation][]b4_param[) :
+      ]b4_constructor[][debug_ (debug),
+      cdebug_ (std::cerr),
+      initlocation_ (initlocation)
+#else
+    ]b4_parser_class_name[ (bool debug][]b4_param[) :
+      ]b4_constructor[][debug_ (debug),
+      cdebug_ (std::cerr)
+#endif
+    {
+    }
+
+    virtual ~]b4_parser_class_name[ ()
+    {
+    }
+
+    virtual int parse ();
+
+  private:
+
+    virtual void lex_ ();
+    virtual void error_ ();
+    virtual void print_ ();
+
+    /* Stacks.  */
+    StateStack    state_stack_;
+    SemanticStack semantic_stack_;
+    LocationStack location_stack_;
+
+    /* Tables.  */
+    static const ]b4_int_type_for([b4_pact])[ pact_[];
+    static const ]b4_int_type_for([b4_pact])[ pact_ninf_;
+    static const ]b4_int_type_for([b4_defact])[ defact_[];
+    static const ]b4_int_type_for([b4_pgoto])[ pgoto_[];
+    static const ]b4_int_type_for([b4_defgoto])[ defgoto_[];
+    static const ]b4_int_type_for([b4_table])[ table_[];
+    static const ]b4_int_type_for([b4_table])[ table_ninf_;
+    static const ]b4_int_type_for([b4_check])[ check_[];
+    static const ]b4_int_type_for([b4_r1])[ r1_[];
+    static const ]b4_int_type_for([b4_r2])[ r2_[];
+
+#if YYDEBUG || YYERROR_VERBOSE
+    static const char* const name_[];
+#endif
+
+    /* More tables, for debugging.  */
+#if YYDEBUG
+    static const RhsNumberType rhs_[];
+    static const ]b4_int_type_for([b4_prhs])[ prhs_[];
+    static const ]b4_int_type_for([b4_rline])[ rline_[];
+    static const ]b4_int_type_for([b4_stos])[ stos_[];
+    static const ]b4_int_type_for([b4_toknum])[ token_number_[];
+#endif
+
+    /* Even more tables.  */
+    static inline TokenNumberType translate_ (int token);
+
+    /* Constants.  */
+    static const int eof_;
+    /* LAST_ -- Last index in TABLE_.  */
+    static const int last_;
+    static const int nnts_;
+    static const int empty_;
+    static const int final_;
+    static const int terror_;
+    static const int errcode_;
+    static const int ntokens_;
+    static const int initdepth_;
+    static const unsigned user_token_number_max_;
+    static const TokenNumberType undef_token_;
+
+    /* State.  */
+    int n_;
+    int len_;
+    int state_;
+
+    /* Debugging.  */
+    int debug_;
+    std::ostream &cdebug_;
+
+    /* Lookahead and lookahead in internal form.  */
+    int looka_;
+    int ilooka_;
+
+    /* Message.  */
+    std::string message;
+
+    /* Semantic value and location of lookahead token.  */
+    SemanticType value;
+    LocationType location;
+
+    /* @@$ and $$.  */
+    SemanticType yyval;
+    LocationType yyloc;
+
+    /* Initial location.  */
+    LocationType initlocation_;
+  };
+}
+
+#endif /* ! defined PARSER_HEADER_H */]
+dnl
+@output @output_parser_name@
+b4_copyright([C++ Skeleton parser for LALR(1) parsing with Bison],
+             [2002])[
+
+#include @output_header_name@
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+# define YYCDEBUG    if (debug_) cdebug_
+#else /* !YYDEBUG */
+# define YYCDEBUG    if (0) cdebug_
+#endif /* !YYDEBUG */
+
+int
+yy::]b4_parser_class_name[::parse ()
+{
+  int nerrs = 0;
+  int errstatus = 0;
+
+  /* Initialize stack.  */
+  state_stack_ = StateStack (0);
+  semantic_stack_ = SemanticStack (1);
+  location_stack_ = LocationStack (1);
+
+  /* Start.  */
+  state_ = 0;
+  looka_ = empty_;
+#if YYLSP_NEEDED
+  location = initlocation_;
+#endif
+  YYCDEBUG << "Starting parse" << std::endl;
+
+  /* New state.  */
+ yynewstate:
+  state_stack_.push (state_);
+  YYCDEBUG << "Entering state " << state_ << std::endl;
+  goto yybackup;
+
+  /* Backup.  */
+ yybackup:
+
+  /* Try to take a decision without lookahead.  */
+  n_ = pact_[state_];
+  if (n_ == pact_ninf_)
+    goto yydefault;
+
+  /* Read a lookahead token.  */
+  if (looka_ == empty_)
+    {
+      YYCDEBUG << "Reading a token: ";
+      lex_ ();
+    }
+
+  /* Convert token to internal form.  */
+  if (looka_ <= 0)
+    {
+      looka_ = eof_;
+      ilooka_ = 0;
+      YYCDEBUG << "Now at end of input." << std::endl;
+    }
+  else
+    {
+      ilooka_ = translate_ (looka_);
+#if YYDEBUG
+      if (debug_)
+	{
+	  YYCDEBUG << "Next token is " << looka_
+		 << " (" << name_[ilooka_];
+	  print_ ();
+	  YYCDEBUG << ')' << std::endl;
+	}
+#endif
+    }
+
+  n_ += ilooka_;
+  if (n_ < 0 || last_ < n_ || check_[n_] != ilooka_)
+    goto yydefault;
+
+  /* Reduce or error.  */
+  n_ = table_[n_];
+  if (n_ < 0)
+    {
+      if (n_ == table_ninf_)
+	goto yyerrlab;
+      else
+	{
+	  n_ = -n_;
+	  goto yyreduce;
+	}
+    }
+  else if (n_ == 0)
+    goto yyerrlab;
+
+  /* Accept?  */
+  if (n_ == final_)
+    goto yyacceptlab;
+
+  /* Shift the lookahead token.  */
+  YYCDEBUG << "Shifting token " << looka_
+	 << " (" << name_[ilooka_] << "), ";
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (looka_ != eof_)
+    looka_ = empty_;
+
+  semantic_stack_.push (value);
+  location_stack_.push (location);
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (errstatus)
+    --errstatus;
+
+  state_ = n_;
+  goto yynewstate;
+
+  /* Default action.  */
+ yydefault:
+  n_ = defact_[state_];
+  if (n_ == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+  /* Reduce.  */
+ yyreduce:
+  len_ = r2_[n_];
+  if (len_)
+    {
+      yyval = semantic_stack_[len_ - 1];
+      yyloc = location_stack_[len_ - 1];
+    }
+  else
+    {
+      yyval = semantic_stack_[0];
+      yyloc = location_stack_[0];
+    }
+
+#if YYDEBUG
+  if (debug_)
+    {
+      YYCDEBUG << "Reducing via rule " << n_ - 1
+	     << " (line " << rline_[n_] << "), ";
+      for (]b4_int_type_for([b4_prhs])[ i = prhs_[n_];
+	   0 <= rhs_[i]; ++i)
+	YYCDEBUG << name_[rhs_[i]] << ' ';
+      YYCDEBUG << "-> " << name_[r1_[n_]] << std::endl;
+    }
+#endif
+
+  if (len_)
+    {
+      Slice< LocationType, LocationStack > slice (location_stack_, len_);
+      YYLLOC_DEFAULT (yyloc, slice, len_);
+    }
+
+  switch (n_)
+    {
+      ]b4_actions[
+    }
+
+]/* Line __line__ of lalr1.cc.  */
+b4_syncline([@oline@], [@ofile@])[
+
+  state_stack_.pop (len_);
+  semantic_stack_.pop (len_);
+  location_stack_.pop (len_);
+
+#if YYDEBUG
+  if (debug_)
+    {
+      YYCDEBUG << "state stack now";
+      for (StateStack::ConstIterator i = state_stack_.begin ();
+	   i != state_stack_.end (); ++i)
+	YYCDEBUG << ' ' << *i;
+      YYCDEBUG << std::endl;
+    }
+#endif
+
+  semantic_stack_.push (yyval);
+  location_stack_.push (yyloc);
+
+  /* Shift the result of the reduction.  */
+  n_ = r1_[n_];
+  state_ = pgoto_[n_ - ntokens_] + state_stack_[0];
+  if (0 <= state_ && state_ <= last_ && check_[state_] == state_stack_[0])
+    state_ = table_[state_];
+  else
+    state_ = defgoto_[n_ - ntokens_];
+  goto yynewstate;
+
+  /* Report and recover from errors.  This is very incomplete.  */
+ yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!errstatus)
+    {
+      ++nerrs;
+
+#if YYERROR_VERBOSE
+      n_ = pact_[state_];
+      if (pact_ninf_ < n_ && n_ < last_)
+	{
+	  message = "syntax error, unexpected ";
+	  message += name_[ilooka_];
+	  {
+	    int count = 0;
+	    for (int x = (n_ < 0 ? -n_ : 0); x < ntokens_ + nnts_; ++x)
+	      if (check_[x + n_] == x && x != terror_)
+		++count;
+	    if (count < 5)
+	      {
+		count = 0;
+		for (int x = (n_ < 0 ? -n_ : 0); x < ntokens_ + nnts_; ++x)
+		  if (check_[x + n_] == x && x != terror_)
+		    {
+		      message += (!count++) ? ", expecting " : " or ";
+		      message += name_[x];
+		    }
+	      }
+	  }
+	}
+      else
+#endif
+	message = "syntax error";
+      error_ ();
+    }
+  goto yyerrlab1;
+
+  /* Error raised explicitly by an action.  */
+ yyerrlab1:
+  if (errstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      /* Return failure if at end of input.  */
+      if (looka_ == eof_)
+	goto yyabortlab;
+      YYCDEBUG << "Discarding token " << looka_
+	     << " (" << name_[ilooka_] << ")." << std::endl;
+      looka_ = empty_;
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+
+  errstatus = 3;
+
+  for (;;)
+    {
+      n_ = pact_[state_];
+      if (n_ != pact_ninf_)
+	{
+	  n_ += terror_;
+	  if (0 <= n_ && n_ <= last_ && check_[n_] == terror_)
+	    {
+	      n_ = table_[n_];
+	      if (0 < n_)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (!state_stack_.height ())
+	goto yyabortlab;
+
+#if YYDEBUG
+      if (debug_)
+	{
+	  if (stos_[state_] < ntokens_)
+	    {
+	      YYCDEBUG << "Error: popping token "
+		     << token_number_[stos_[state_]]
+		     << " (" << name_[stos_[state_]];
+# ifdef YYPRINT
+	      YYPRINT (stderr, token_number_[stos_[state_]],
+		       semantic_stack_.top ());
+# endif
+	      YYCDEBUG << ')' << std::endl;
+	    }
+	  else
+	    {
+	      YYCDEBUG << "Error: popping nonterminal ("
+		     << name_[stos_[state_]] << ')' << std::endl;
+	    }
+	}
+#endif
+
+      state_ = (state_stack_.pop (), state_stack_[0]);
+      semantic_stack_.pop ();
+      location_stack_.pop ();;
+
+#if YYDEBUG
+      if (debug_)
+	{
+	  YYCDEBUG << "Error: state stack now";
+	  for (StateStack::ConstIterator i = state_stack_.begin ();
+	       i != state_stack_.end (); ++i)
+	    YYCDEBUG << ' ' << *i;
+	  YYCDEBUG << std::endl;
+	}
+#endif
+    }
+
+  if (n_ == final_)
+    goto yyacceptlab;
+
+  YYCDEBUG << "Shifting error token, ";
+
+  semantic_stack_.push (value);
+  location_stack_.push (location);
+
+  state_ = n_;
+  goto yynewstate;
+
+  /* Accept.  */
+ yyacceptlab:
+  return 0;
+
+  /* Abort.  */
+ yyabortlab:
+  return 1;
+}
+
+void
+yy::]b4_parser_class_name[::lex_ ()
+{
+#if YYLSP_NEEDED
+  looka_ = yylex (&value, &location);
+#else
+  looka_ = yylex (&value);
+#endif
+}
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+const ]b4_int_type_for([b4_pact]) yy::b4_parser_class_name::pact_ninf_ = b4_pact_ninf[;
+const ]b4_int_type_for([b4_pact])[
+yy::]b4_parser_class_name[::pact_[] =
+{
+  ]b4_pact[
+};
+
+/* YYDEFACT[S] -- default rule to reduce with in state S when YYTABLE
+   doesn't specify something else to do.  Zero means the default is an
+   error.  */
+const ]b4_int_type_for([b4_defact])[
+yy::]b4_parser_class_name[::defact_[] =
+{
+  ]b4_defact[
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+const ]b4_int_type_for([b4_pgoto])[
+yy::]b4_parser_class_name[::pgoto_[] =
+{
+  ]b4_pgoto[
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+const ]b4_int_type_for([b4_defgoto])[
+yy::]b4_parser_class_name[::defgoto_[] =
+{
+  ]b4_defgoto[
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.  */
+const ]b4_int_type_for([b4_table]) yy::b4_parser_class_name::table_ninf_ = b4_table_ninf[;
+const ]b4_int_type_for([b4_table])[
+yy::]b4_parser_class_name[::table_[] =
+{
+  ]b4_table[
+};
+
+/* YYCHECK.  */
+const ]b4_int_type_for([b4_check])[
+yy::]b4_parser_class_name[::check_[] =
+{
+  ]b4_check[
+};
+
+#if YYDEBUG
+/* STOS_[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+const ]b4_int_type_for([b4_stos])[
+yy::]b4_parser_class_name[::stos_[] =
+{
+  ]b4_stos[
+};
+
+/* TOKEN_NUMBER_[YYLEX-NUM] -- Internal token number corresponding
+   to YYLEX-NUM.  */
+const ]b4_int_type_for([b4_toknum])[
+yy::]b4_parser_class_name[::token_number_[] =
+{
+  ]b4_toknum[
+};
+#endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+const ]b4_int_type_for([b4_r1])[
+yy::]b4_parser_class_name[::r1_[] =
+{
+  ]b4_r1[
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+const ]b4_int_type_for([b4_r2])[
+yy::]b4_parser_class_name[::r2_[] =
+{
+  ]b4_r2[
+};
+
+#if YYDEBUG || YYERROR_VERBOSE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+const char*
+const yy::]b4_parser_class_name[::name_[] =
+{
+  ]b4_tname[
+};
+#endif
+
+#if YYDEBUG
+/* YYRHS -- A `-1'-separated list of the rules' RHS. */
+const yy::]b4_parser_class_name[::RhsNumberType
+yy::]b4_parser_class_name[::rhs_[] =
+{
+  ]b4_rhs[
+};
+
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+const ]b4_int_type_for([b4_prhs])[
+yy::]b4_parser_class_name[::prhs_[] =
+{
+  ]b4_prhs[
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+const ]b4_int_type_for([b4_rline])[
+yy::]b4_parser_class_name[::rline_[] =
+{
+  ]b4_rline[
+};
+#endif
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+yy::]b4_parser_class_name[::TokenNumberType
+yy::]b4_parser_class_name[::translate_ (int token)
+{
+  static
+  const TokenNumberType
+  translate_[] =
+  {
+    ]b4_translate[
+  };
+  if ((unsigned) token <= user_token_number_max_)
+    return translate_[token];
+  else
+    return undef_token_;
+}
+
+const int yy::]b4_parser_class_name[::eof_ = 0;
+const int yy::]b4_parser_class_name[::last_ = ]b4_last[;
+const int yy::]b4_parser_class_name[::nnts_ = ]b4_nterms_number[;
+const int yy::]b4_parser_class_name[::empty_ = -2;
+const int yy::]b4_parser_class_name[::final_ = ]b4_final_state_number[;
+const int yy::]b4_parser_class_name[::terror_ = 1;
+const int yy::]b4_parser_class_name[::errcode_ = 256;
+const int yy::]b4_parser_class_name[::ntokens_ = ]b4_tokens_number[;
+const int yy::]b4_parser_class_name[::initdepth_ = ]b4_stack_depth_init[;
+
+const unsigned yy::]b4_parser_class_name[::user_token_number_max_ = ]b4_user_token_number_max[;
+const yy::]b4_parser_class_name[::TokenNumberType yy::]b4_parser_class_name[::undef_token_ = ]b4_undef_token_number[;
+
+]b4_epilogue
+dnl
+@output stack.hh
+b4_copyright([2002])[
+
+#ifndef BISON_STACK_HH
+# define BISON_STACK_HH
+
+#include <deque>
+
+namespace yy
+{
+  template < class T, class S = std::deque< T > >
+  class Stack
+  {
+  public:
+
+    typedef typename S::iterator Iterator;
+    typedef typename S::const_iterator ConstIterator;
+
+    Stack () : seq_ ()
+    {
+    }
+
+    Stack (unsigned n) : seq_ (n)
+    {
+    }
+
+    inline
+    T&
+    operator [] (unsigned index)
+    {
+      return seq_[index];
+    }
+
+    inline
+    const T&
+    operator [] (unsigned index) const
+    {
+      return seq_[index];
+    }
+
+    inline
+    void
+    push (const T& t)
+    {
+      seq_.push_front (t);
+    }
+
+    inline
+    void
+    pop (unsigned n = 1)
+    {
+      for (; n; --n)
+	seq_.pop_front ();
+    }
+
+    inline
+    unsigned
+    height () const
+    {
+      return seq_.size ();
+    }
+
+    inline ConstIterator begin () const { return seq_.begin (); }
+    inline ConstIterator end () const { return seq_.end (); }
+
+  private:
+
+    S seq_;
+  };
+
+  template < class T, class S = Stack< T > >
+  class Slice
+  {
+  public:
+
+    Slice (const S& stack,
+	   unsigned range) : stack_ (stack),
+			     range_ (range)
+    {
+    }
+
+    inline
+    const T&
+    operator [] (unsigned index) const
+    {
+      return stack_[range_ - index];
+    }
+
+  private:
+
+    const S& stack_;
+    unsigned range_;
+  };
+}
+
+#endif // not BISON_STACK_HH]
+dnl
+@output location.hh
+b4_copyright([2002])[
+
+#ifndef BISON_LOCATION_HH
+# define BISON_LOCATION_HH
+
+namespace yy
+{
+  struct Position
+  {
+    int line;
+    int column;
+  };
+
+  struct Location
+  {
+    Position first;
+    Position last;
+  };
+}
+
+#endif // not BISON_LOCATION_HH]
diff -puN /dev/null parser/bison-1.875/yacc_reiser4.c
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/bison-1.875/yacc_reiser4.c	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,1227 @@
+m4_divert(-1)                                                       -*- C -*-
+
+# Yacc compatible skeleton for Bison
+# Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002
+# Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+# 02111-1307  USA
+
+
+
+## ---------------- ##
+## Default values.  ##
+## ---------------- ##
+
+# Stack parameters.
+m4_define_default([b4_stack_depth_max], [10000])
+m4_define_default([b4_stack_depth_init],  [200])
+
+
+## ------------------------ ##
+## Pure/impure interfaces.  ##
+## ------------------------ ##
+
+
+# b4_pure_if(IF-TRUE, IF-FALSE)
+# -----------------------------
+# Expand IF-TRUE, if %pure-parser and %parse-param, IF-FALSE otherwise.
+m4_define([b4_Pure_if],
+[b4_pure_if([m4_ifset([b4_parse_param],
+                      [$1], [$2])],
+            [$2])])
+
+
+# b4_yyerror_args
+# ---------------
+# Arguments passed to yyerror: user args plus yylloc.
+m4_define([b4_yyerror_args],
+[b4_Pure_if([b4_location_if([&yylloc, ])])dnl
+m4_ifset([b4_parse_param], [b4_c_args(b4_parse_param), ])])
+
+
+# b4_lex_param
+# ------------
+# Accumulate in b4_lex_param all the yylex arguments.
+# b4_lex_param arrives quoted twice, but we want to keep only one level.
+m4_define([b4_lex_param],
+m4_dquote(b4_pure_if([[[[YYSTYPE *]], [[&yylval]]][]dnl
+b4_location_if([, [[YYLTYPE *], [&yylloc]]])])dnl
+m4_ifdef([b4_lex_param], [, ]b4_lex_param)))
+
+
+
+## ------------ ##
+## Data Types.  ##
+## ------------ ##
+
+# b4_int_type(MIN, MAX)
+# ---------------------
+# Return the smallest int type able to handle numbers ranging from
+# MIN to MAX (included).  We overwrite the version from c.m4 which relies
+# on "signed char" which is not portable to old K&R compilers.
+m4_define([b4_int_type],
+[m4_if(b4_ints_in($@,      [0],   [255]), [1], [unsigned char],
+       b4_ints_in($@,   [-128],   [127]), [1], [yysigned_char],
+
+       b4_ints_in($@,      [0], [65535]), [1], [unsigned short],
+       b4_ints_in($@, [-32768], [32767]), [1], [short],
+
+       m4_eval([0 <= $1]),                [1], [unsigned int],
+
+ 	                                       [int])])
+
+
+## ----------------- ##
+## Semantic Values.  ##
+## ----------------- ##
+
+
+# b4_lhs_value([TYPE])
+# --------------------
+# Expansion of $<TYPE>$.
+m4_define([b4_lhs_value],
+[yyval[]m4_ifval([$1], [.$1])])
+
+
+# b4_rhs_value(RULE-LENGTH, NUM, [TYPE])
+# --------------------------------------
+# Expansion of $<TYPE>NUM, where the current rule has RULE-LENGTH
+# symbols on RHS.
+m4_define([b4_rhs_value],
+[yyvsp@{m4_eval([$2 - $1])@}m4_ifval([$3], [.$3])])
+
+
+
+## ----------- ##
+## Locations.  ##
+## ----------- ##
+
+# b4_lhs_location()
+# -----------------
+# Expansion of @$.
+m4_define([b4_lhs_location],
+[yyloc])
+
+
+# b4_rhs_location(RULE-LENGTH, NUM)
+# ---------------------------------
+# Expansion of @NUM, where the current rule has RULE-LENGTH symbols
+# on RHS.
+m4_define([b4_rhs_location],
+[yylsp@{m4_eval([$2 - $1])@}])
+
+
+
+## --------------------------------------------------------- ##
+## Defining symbol actions, e.g., printers and destructors.  ##
+## --------------------------------------------------------- ##
+
+# We do want M4 expansion after # for CPP macros.
+m4_changecom()
+m4_divert(0)dnl
+@output @output_parser_name@
+b4_copyright([Skeleton parser for Yacc-like parsing with Bison],
+             [1984, 1989, 1990, 2000, 2001, 2002])[
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* Written by Richard Stallman by simplifying the original so called
+   ``semantic'' parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+]b4_identification
+m4_if(b4_prefix[], [yy], [],
+[/* If NAME_PREFIX is specified substitute the variables and functions
+   names.  */
+#define yyparse b4_prefix[]parse
+#define yylex   b4_prefix[]lex
+#define yyerror b4_prefix[]error
+#define yylval  b4_prefix[]lval
+#define yychar  b4_prefix[]char
+#define yydebug b4_prefix[]debug
+#define yynerrs b4_prefix[]nerrs
+b4_location_if([#define yylloc b4_prefix[]lloc])])[
+
+]b4_token_defines(b4_tokens)[
+
+/* Copy the first part of user declarations.  */
+]b4_pre_prologue[
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG ]b4_debug[
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE ]b4_error_verbose[
+#endif
+
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+]m4_ifdef([b4_stype],
+[b4_syncline([b4_stype_line], [b4_filename])
+typedef union m4_bregexp(b4_stype, [^{], [YYSTYPE ])b4_stype YYSTYPE;
+/* Line __line__ of yacc.c.  */
+b4_syncline([@oline@], [@ofile@])],
+[typedef int YYSTYPE;])[
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+]b4_location_if([#if ! defined (YYLTYPE) && ! defined (YYLTYPE_IS_DECLARED)
+typedef struct YYLTYPE
+{
+  int first_line;
+  int first_column;
+  int last_line;
+  int last_column;
+} YYLTYPE;
+# define yyltype YYLTYPE /* obsolescent; will be withdrawn */
+# define YYLTYPE_IS_DECLARED 1
+# define YYLTYPE_IS_TRIVIAL 1
+#endif
+])[
+
+/* Copy the second part of user declarations.  */
+]b4_post_prologue
+
+/* Line __line__ of yacc.c.  */
+b4_syncline([@oline@], [@ofile@])[
+
+#  define YYSTACK_ALLOC(size) kmalloc((size),GFP_KERNEL)
+
+#   define YYSIZE_T size_t
+
+#  define YYSTACK_FREE kfree
+
+
+
+#if (! defined (yyoverflow) \
+     && (! defined (__cplusplus) \
+	 || (]b4_location_if([YYLTYPE_IS_TRIVIAL && ])[YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  short yyss_1;
+  YYSTYPE yyvs_1;
+  ]b4_location_if([  YYLTYPE yyls_1;
+])dnl
+[};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+]b4_location_if(
+[# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short) + sizeof (YYSTYPE) + sizeof (YYLTYPE))	\
+      + 2 * YYSTACK_GAP_MAXIMUM)],
+[# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+      + YYSTACK_GAP_MAXIMUM)])[
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  register YYSIZE_T yyi;		\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (0)
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+void * YYSTACK_RELOCATE(void *Stack, int old_size, int new_size)
+{
+void * ptr;
+ptr = kmalloc(new_size, GFP_KERNEL);
+memcpy(ptr, Stack, old_size);
+kfree(Stack);
+Stack=ptr;
+return (ptr);
+}
+#endif
+
+#if defined (__STDC__) || defined (__cplusplus)
+   typedef signed char yysigned_char;
+#else
+   typedef short yysigned_char;
+#endif
+
+/* YYFINAL -- State number of the termination state. */
+#define YYFINAL  ]b4_final_state_number[
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   ]b4_last[
+
+/* YYNTOKENS -- Number of terminals. */
+#define YYNTOKENS  ]b4_tokens_number[
+/* YYNNTS -- Number of nonterminals. */
+#define YYNNTS  ]b4_nterms_number[
+/* YYNRULES -- Number of rules. */
+#define YYNRULES  ]b4_rules_number[
+/* YYNRULES -- Number of states. */
+#define YYNSTATES  ]b4_states_number[
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  ]b4_undef_token_number[
+#define YYMAXUTOK   ]b4_user_token_number_max[
+
+#define YYTRANSLATE(YYX) 						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const ]b4_int_type_for([b4_translate])[ yytranslate[] =
+{
+  ]b4_translate[
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const ]b4_int_type_for([b4_prhs])[ yyprhs[] =
+{
+  ]b4_prhs[
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS. */
+static const ]b4_int_type_for([b4_rhs])[ yyrhs[] =
+{
+  ]b4_rhs[
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const ]b4_int_type_for([b4_rline])[ yyrline[] =
+{
+  ]b4_rline[
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE
+/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+static const char *const yytname[] =
+{
+  ]b4_tname[
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const ]b4_int_type_for([b4_toknum])[ yytoknum[] =
+{
+  ]b4_toknum[
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const ]b4_int_type_for([b4_r1])[ yyr1[] =
+{
+  ]b4_r1[
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const ]b4_int_type_for([b4_r2])[ yyr2[] =
+{
+  ]b4_r2[
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const ]b4_int_type_for([b4_defact])[ yydefact[] =
+{
+  ]b4_defact[
+};
+
+/* YYDEFGOTO[NTERM-NUM]. */
+static const ]b4_int_type_for([b4_defgoto])[ yydefgoto[] =
+{
+  ]b4_defgoto[
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF ]b4_pact_ninf[
+static const ]b4_int_type_for([b4_pact])[ yypact[] =
+{
+  ]b4_pact[
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const ]b4_int_type_for([b4_pgoto])[ yypgoto[] =
+{
+  ]b4_pgoto[
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF ]b4_table_ninf[
+static const ]b4_int_type_for([b4_table])[ yytable[] =
+{
+  ]b4_table[
+};
+
+static const ]b4_int_type_for([b4_check])[ yycheck[] =
+{
+  ]b4_check[
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const ]b4_int_type_for([b4_stos])[ yystos[] =
+{
+  ]b4_stos[
+};
+
+#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
+# define YYSIZE_T __SIZE_TYPE__
+#endif
+#if ! defined (YYSIZE_T) && defined (size_t)
+# define YYSIZE_T size_t
+#endif
+#if ! defined (YYSIZE_T)
+# if defined (__STDC__) || defined (__cplusplus)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# endif
+#endif
+#if ! defined (YYSIZE_T)
+# define YYSIZE_T unsigned int
+#endif
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrlab1
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK;						\
+      goto yybackup;						\
+    }								\
+  else								\
+    { 								\
+      yyerror (]b4_yyerror_args["syntax error: cannot back up");\
+      YYERROR;							\
+    }								\
+while (0)
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+/* YYLLOC_DEFAULT -- Compute the default location (before the actions
+   are run).  */
+
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)         \
+  Current.first_line   = Rhs[1].first_line;      \
+  Current.first_column = Rhs[1].first_column;    \
+  Current.last_line    = Rhs[N].last_line;       \
+  Current.last_column  = Rhs[N].last_column;
+#endif
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (]b4_pure_if([&yylval[]b4_location_if([, &yylloc]), ])[YYLEX_PARAM)
+#else
+# define YYLEX ]b4_c_function_call([yylex], [int], b4_lex_param)[
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+
+#ifndef fprintf
+#define fprintf printk
+#endif
+
+# ifndef YYFPRINTF
+//#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (0)
+
+# define YYDSYMPRINT(Args)			\
+do {						\
+  if (yydebug)					\
+    yysymprint Args;				\
+} while (0)
+
+# define YYDSYMPRINTF(Title, Token, Value, Location)		\
+do {								\
+  if (yydebug)							\
+    {								\
+      YYFPRINTF ( "%s ", Title);				\
+      yysymprint ( Token, Value]b4_location_if([, Location])[);	\
+      YYFPRINTF ( "\n");					\
+    }								\
+} while (0)
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (cinluded).                                                   |
+`------------------------------------------------------------------*/
+
+]b4_c_function_def([yy_stack_print], [static void],
+                   [[short *bottom], [bottom]],
+                   [[short *top],    [top]])[
+{
+  YYFPRINTF ( "Stack now");
+  for (/* Nothing. */; bottom <= top; ++bottom)
+    YYFPRINTF ( " %d", *bottom);
+  YYFPRINTF ( "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+]b4_c_function_def([yy_reduce_print], [static void],
+                   [[int yyrule], [yyrule]])[
+{
+  int yyi;
+  unsigned int yylineno = yyrline[yyrule];
+  YYFPRINTF ( "Reducing stack by rule %d (line %u), ",
+             yyrule - 1, yylineno);
+  /* Print the symbols being reduced, and their result.  */
+  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
+    YYFPRINTF ( "%s ", yytname [yyrhs[yyi]]);
+  YYFPRINTF ( "-> %s\n", yytname [yyr1[yyrule]]);
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (Rule);		\
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YYDSYMPRINT(Args)
+# define YYDSYMPRINTF(Title, Token, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH ]b4_stack_depth_init[
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#if YYMAXDEPTH == 0
+# undef YYMAXDEPTH
+#endif
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH ]b4_stack_depth_max[
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined (__GLIBC__) && defined (_STRING_H)
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+#   if defined (__STDC__) || defined (__cplusplus)
+yystrlen (const char *yystr)
+#   else
+yystrlen (yystr)
+     const char *yystr;
+#   endif
+{
+  register const char *yys = yystr;
+
+  while (*yys++ != '\0')
+    continue;
+
+  return yys - yystr - 1;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+#   if defined (__STDC__) || defined (__cplusplus)
+yystpcpy (char *yydest, const char *yysrc)
+#   else
+yystpcpy (yydest, yysrc)
+     char *yydest;
+     const char *yysrc;
+#   endif
+{
+  register char *yyd = yydest;
+  register const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+#endif /* !YYERROR_VERBOSE */
+
+
+
+#if YYDEBUG
+]b4_yysymprint_generate([b4_c_function_def])[
+#endif /* ! YYDEBUG */
+]b4_yydestruct_generate([b4_c_function_def])
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+
+int yyparse (YYPARSE_PARAM);
+
+
+
+m4_divert_push([KILL])# ======================== M4 code.
+# b4_declare_parser_variables
+# ---------------------------
+# Declare the variables that are global, or local to YYPARSE if
+# pure-parser.
+m4_define([b4_declare_parser_variables],
+[/* The lookahead symbol.  */
+
+int yychar;
+
+
+/* The semantic value of the lookahead symbol.  */
+/*
+YYSTYPE yylval;
+*/
+
+/* Number of syntax errors so far.  */
+
+  int yynerrs;
+
+
+b4_location_if([
+/* Location data for the lookahead symbol.  */
+YYLTYPE yylloc;])
+])
+m4_divert_pop([KILL])dnl# ====================== End of M4 code.
+
+b4_pure_if([],
+           [b4_declare_parser_variables])
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+static
+int yyparse (YYPARSE_PARAM)
+{[
+  ]b4_pure_if([b4_declare_parser_variables])[
+  register int yystate;
+  register int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  short	yyssa[YYINITDEPTH];
+  yyss = yyssa;
+/*  
+  short *yyss = yyssa;
+  register short *yyssp;
+*/
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  yyvs = yyvsa;
+/*
+  YYSTYPE *yyvs = yyvsa;
+  register YYSTYPE *yyvsp;
+*/
+
+]b4_location_if(
+[[  /* The location stack.  */
+  YYLTYPE yylsa[YYINITDEPTH];
+  yyls = yylsa;
+/*  YYLTYPE *yyls = yylsa;
+    YYLTYPE *yylsp;*/
+  YYLTYPE *yylerrsp;]])[
+
+#define YYPOPSTACK   (yyvsp--, yyssp--]b4_location_if([, yylsp--])[)
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+/*  YYSTYPE yyval;*/
+]b4_location_if([  YYLTYPE yyloc;])[
+
+  /* When reducing, the number of symbols on the RHS of the reduced
+     rule.  */
+  int yylen;
+
+  YYDPRINTF (("Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+]b4_location_if([  yylsp = yyls;])[
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed. so pushing a state here evens the stacks.
+     */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack. Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	short *yyss1 = yyss;
+]b4_location_if([	YYLTYPE *yyls1 = yyls;])[
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow ("parser stack overflow",
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+]b4_location_if([		    &yyls1, yysize * sizeof (*yylsp),])[
+		    &yystacksize);
+]b4_location_if([	yyls = yyls1;])[
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyoverflowlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyoverflowlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	short *yyss1 = yyss;
+/*
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyoverflowlab;
+*/
+	YYSTACK_RELOCATE (yyss,YYSIZE,YYSTACKSIZE);
+	YYSTACK_RELOCATE (yyvs,YYSIZE,YYSTACKSIZE);
+]b4_location_if([	YYSTACK_RELOCATE (yyls,YYSIZE,YYSTACKSIZE);])[
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+]b4_location_if([      yylsp = yyls + yysize - 1;])[
+
+      YYDPRINTF (( "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF (( "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+/* Do appropriate processing given the current state.  */
+/* Read a lookahead token if we need one and don't already have one.  */
+/* yyresume: */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF (( "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF (( "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Shift the lookahead token.  */
+  YYDPRINTF (( "Shifting token %s, ", yytname[yytoken]));
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  *++yyvsp = yylval;
+]b4_location_if([  *++yylsp = yylloc;])[
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+]b4_location_if(
+[  /* Default location. */
+  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);])[
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    ]{
+      b4_actions
+    }
+
+/* Line __line__ of yacc.c.  */
+b4_syncline([@oline@], [@ofile@])
+
+[  yyvsp -= yylen;
+  yyssp -= yylen;
+]b4_location_if([  yylsp -= yylen;])[
+
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+]b4_location_if([  *++yylsp = yyloc;])[
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (YYPACT_NINF < yyn && yyn < YYLAST)
+	{
+	  YYSIZE_T yysize = 0;
+	  int yytype = YYTRANSLATE (yychar);
+	  char *yymsg;
+	  int yyx, yycount;
+
+	  yycount = 0;
+	  /* Start YYX at -YYN if negative to avoid negative indexes in
+	     YYCHECK.  */
+	  for (yyx = yyn < 0 ? -yyn : 0;
+	       yyx < (int) (sizeof (yytname) / sizeof (char *)); yyx++)
+	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	      yysize += yystrlen (yytname[yyx]) + 15, yycount++;
+	  yysize += yystrlen ("syntax error, unexpected ") + 1;
+	  yysize += yystrlen (yytname[yytype]);
+	  yymsg = (char *) YYSTACK_ALLOC (yysize);
+	  if (yymsg != 0)
+	    {
+	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
+	      yyp = yystpcpy (yyp, yytname[yytype]);
+
+	      if (yycount < 5)
+		{
+		  yycount = 0;
+		  for (yyx = yyn < 0 ? -yyn : 0;
+		       yyx < (int) (sizeof (yytname) / sizeof (char *));
+		       yyx++)
+		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+		      {
+			const char *yyq = ! yycount ? ", expecting " : " or ";
+			yyp = yystpcpy (yyp, yyq);
+			yyp = yystpcpy (yyp, yytname[yyx]);
+			yycount++;
+		      }
+		}
+	      yyerror (]b4_yyerror_args[yymsg);
+	      YYSTACK_FREE (yymsg);
+	    }
+	  else
+	    yyerror (]b4_yyerror_args["syntax error; also virtual memory exhausted");
+	}
+      else
+#endif /* YYERROR_VERBOSE */
+	yyerror (]b4_yyerror_args["syntax error");
+    }
+
+]b4_location_if([  yylerrsp = yylsp;])[
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      /* Return failure if at end of input.  */
+      if (yychar == YYEOF)
+        {
+	  /* Pop the error token.  */
+          YYPOPSTACK;
+	  /* Pop the rest of the stack.  */
+	  while (yyss < yyssp)
+	    {
+	      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
+	      yydestruct (yystos[*yyssp], yyvsp]b4_location_if([, yylsp])[);
+	      YYPOPSTACK;
+	    }
+	  YYABORT;
+        }
+
+      YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
+      yydestruct (yytoken, &yylval]b4_location_if([, &yylloc])[);
+      yychar = YYEMPTY;
+]b4_location_if([      *++yylerrsp = yylloc;])[
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab2;
+
+
+/*----------------------------------------------------.
+| yyerrlab1 -- error raised explicitly by an action.  |
+`----------------------------------------------------*/
+yyerrlab1:
+
+  /* Suppress GCC warning that yyerrlab1 is unused when no action
+     invokes YYERROR.  */
+#if defined (__GNUC_MINOR__) && 2093 <= (__GNUC__ * 1000 + __GNUC_MINOR__)
+  __attribute__ ((__unused__))
+#endif
+
+]b4_location_if([  yylerrsp = yylsp;
+  *++yylerrsp = yyloc;])[
+  goto yyerrlab2;
+
+
+/*---------------------------------------------------------------.
+| yyerrlab2 -- pop states until the error token can be shifted.  |
+`---------------------------------------------------------------*/
+yyerrlab2:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
+      yydestruct (yystos[yystate], yyvsp]b4_location_if([, yylsp])[);
+      yyvsp--;
+      yystate = *--yyssp;
+]b4_location_if([      yylsp--;])[
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  YYDPRINTF (( "Shifting error token, "));
+
+  *++yyvsp = yylval;
+]b4_location_if([  YYLLOC_DEFAULT (yyloc, yylsp, (yylerrsp - yylsp));
+  *++yylsp = yyloc;])[
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*----------------------------------------------.
+| yyoverflowlab -- parser overflow comes here.  |
+`----------------------------------------------*/
+yyoverflowlab:
+  yyerror (]b4_yyerror_args["parser stack overflow");
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+  return yyresult;
+]}
+
+
+b4_epilogue
+m4_if(b4_defines_flag, 0, [],
+[@output @output_header_name@
+b4_copyright([Skeleton parser for Yacc-like parsing with Bison],
+             [1984, 1989, 1990, 2000, 2001, 2002])
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+b4_token_defines(b4_tokens)
+
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+m4_ifdef([b4_stype],
+[b4_syncline([b4_stype_line], [b4_filename])
+typedef union m4_bregexp(b4_stype, [^{], [YYSTYPE ])b4_stype YYSTYPE;
+/* Line __line__ of yacc.c.  */
+b4_syncline([@oline@], [@ofile@])],
+[typedef int YYSTYPE;])
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+b4_pure_if([],
+[extern YYSTYPE b4_prefix[]lval;])
+
+b4_location_if(
+[#if ! defined (YYLTYPE) && ! defined (YYLTYPE_IS_DECLARED)
+typedef struct YYLTYPE
+{
+  int first_line;
+  int first_column;
+  int last_line;
+  int last_column;
+} YYLTYPE;
+# define yyltype YYLTYPE /* obsolescent; will be withdrawn */
+# define YYLTYPE_IS_DECLARED 1
+# define YYLTYPE_IS_TRIVIAL 1
+#endif
+
+m4_if(b4_pure, [0],
+[extern YYLTYPE b4_prefix[]lloc;])
+])
+])
diff -puN /dev/null parser/bison-1.875/m4sugar/m4sugar.m4
--- /dev/null	2004-10-02 12:38:03.000000000 +0400
+++ reiser4-demidov/parser/bison-1.875/m4sugar/m4sugar.m4	2005-06-28 21:31:13.000000000 +0400
@@ -0,0 +1,1803 @@
+divert(-1)#                                                  -*- Autoconf -*-
+# This file is part of Autoconf.
+# Base M4 layer.
+# Requires GNU M4.
+# Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+# 02111-1307, USA.
+#
+# As a special exception, the Free Software Foundation gives unlimited
+# permission to copy, distribute and modify the configure scripts that
+# are the output of Autoconf.  You need not follow the terms of the GNU
+# General Public License when using or distributing such scripts, even
+# though portions of the text of Autoconf appear in them.  The GNU
+# General Public License (GPL) does govern all other use of the material
+# that constitutes the Autoconf program.
+#
+# Certain portions of the Autoconf source text are designed to be copied
+# (in certain cases, depending on the input) into the output of
+# Autoconf.  We call these the "data" portions.  The rest of the Autoconf
+# source text consists of comments plus executable code that decides which
+# of the data portions to output in any given case.  We call these
+# comments and executable code the "non-data" portions.  Autoconf never
+# copies any of the non-data portions into its output.
+#
+# This special exception to the GPL applies to versions of Autoconf
+# released by the Free Software Foundation.  When you make and
+# distribute a modified version of Autoconf, you may extend this special
+# exception to the GPL to apply to your modified version as well, *unless*
+# your modified version has the potential to copy into its output some
+# of the text that was the non-data portion of the version that you started
+# with.  (In other words, unless your change moves or copies text from
+# the non-data portions to the data portions.)  If your modification has
+# such potential, you must delete any notice of this special exception
+# to the GPL from your modified version.
+#
+# Written by Akim Demaille.
+#
+
+# Set the quotes, whatever the current quoting system.
+changequote()
+changequote([, ])
+
+# Some old m4's don't support m4exit.  But they provide
+# equivalent functionality by core dumping because of the
+# long macros we define.
+ifdef([__gnu__], ,
+[errprint(M4sugar requires GNU M4. Install it before installing M4sugar or
+set the M4 environment variable to its path name.)
+m4exit(2)])
+
+
+## ------------------------------- ##
+## 1. Simulate --prefix-builtins.  ##
+## ------------------------------- ##
+
+# m4_define
+# m4_defn
+# m4_undefine
+define([m4_define],   defn([define]))
+define([m4_defn],     defn([defn]))
+define([m4_undefine], defn([undefine]))
+
+m4_undefine([define])
+m4_undefine([defn])
+m4_undefine([undefine])
+
+
+# m4_copy(SRC, DST)
+# -----------------
+# Define DST as the definition of SRC.
+# What's the difference between:
+# 1. m4_copy([from], [to])
+# 2. m4_define([from], [to($@)])
+# Well, obviously 1 is more expansive in space.  Maybe 2 is more expansive
+# in time, but because of the space cost of 1, it's not that obvious.
+# Nevertheless, one huge difference is the handling of `$0'.  If `from'
+# uses `$0', then with 1, `to''s `$0' is `to', while it is `from' in 2.
+# The user will certainly prefer see `from'.
+m4_define([m4_copy],
+[m4_define([$2], m4_defn([$1]))])
+
+
+# m4_rename(SRC, DST)
+# -------------------
+# Rename the macro SRC as DST.
+m4_define([m4_rename],
+[m4_copy([$1], [$2])m4_undefine([$1])])
+
+
+# m4_rename_m4(MACRO-NAME)
+# ------------------------
+# Rename MACRO-NAME as m4_MACRO-NAME.
+m4_define([m4_rename_m4],
+[m4_rename([$1], [m4_$1])])
+
+
+# m4_copy_unm4(m4_MACRO-NAME)
+# ---------------------------
+# Copy m4_MACRO-NAME as MACRO-NAME.
+m4_define([m4_copy_unm4],
+[m4_copy([$1], m4_bpatsubst([$1], [^m4_\(.*\)], [[\1]]))])
+
+
+# Some m4 internals have names colliding with tokens we might use.
+# Rename them a` la `m4 --prefix-builtins'.
+m4_rename_m4([builtin])
+m4_rename_m4([changecom])
+m4_rename_m4([changequote])
+m4_rename_m4([debugfile])
+m4_rename_m4([debugmode])
+m4_rename_m4([decr])
+m4_undefine([divert])
+m4_rename_m4([divnum])
+m4_rename_m4([dumpdef])
+m4_rename_m4([errprint])
+m4_rename_m4([esyscmd])
+m4_rename_m4([eval])
+m4_rename_m4([format])
+m4_rename_m4([ifdef])
+m4_rename([ifelse], [m4_if])
+m4_rename_m4([include])
+m4_rename_m4([incr])
+m4_rename_m4([index])
+m4_rename_m4([indir])
+m4_rename_m4([len])
+m4_rename([m4exit], [m4_exit])
+m4_rename([m4wrap], [m4_wrap])
+m4_rename_m4([maketemp])
+m4_rename([patsubst], [m4_bpatsubst])
+m4_undefine([popdef])
+m4_rename_m4([pushdef])
+m4_rename([regexp], [m4_bregexp])
+m4_rename_m4([shift])
+m4_rename_m4([sinclude])
+m4_rename_m4([substr])
+m4_rename_m4([symbols])
+m4_rename_m4([syscmd])
+m4_rename_m4([sysval])
+m4_rename_m4([traceoff])
+m4_rename_m4([traceon])
+m4_rename_m4([translit])
+m4_undefine([undivert])
+
+
+## ------------------- ##
+## 2. Error messages.  ##
+## ------------------- ##
+
+
+# m4_location
+# -----------
+m4_define([m4_location],
+[__file__:__line__])
+
+
+# m4_errprintn(MSG)
+# -----------------
+# Same as `errprint', but with the missing end of line.
+m4_define([m4_errprintn],
+[m4_errprint([$1
+])])
+
+
+# m4_warning(MSG)
+# ---------------
+# Warn the user.
+m4_define([m4_warning],
+[m4_errprintn(m4_location[: warning: $1])])
+
+
+# m4_fatal(MSG, [EXIT-STATUS])
+# ----------------------------
+# Fatal the user.                                                      :)
+m4_define([m4_fatal],
+[m4_errprintn(m4_location[: error: $1])dnl
+m4_expansion_stack_dump()dnl
+m4_exit(m4_if([$2],, 1, [$2]))])
+
+
+# m4_assert(EXPRESSION, [EXIT-STATUS = 1])
+# ----------------------------------------
+# This macro ensures that EXPRESSION evaluates to true, and exits if
+# EXPRESSION evaluates to false.
+m4_define([m4_assert],
+[m4_if(m4_eval([$1]), 0,
+       [m4_fatal([assert failed: $1], [$2])])])
+
+
+## ------------- ##
+## 3. Warnings.  ##
+## ------------- ##
+
+
+# m4_warning_ifelse(CATEGORY, IF-TRUE, IF-FALSE)
+# ----------------------------------------------
+# If the CATEGORY of warnings is enabled, expand IF_TRUE otherwise
+# IF-FALSE.
+#
+# The variable `m4_warnings' contains a comma separated list of
+# warnings which order is the converse from the one specified by
+# the user, i.e., if she specified `-W error,none,obsolete',
+# `m4_warnings' is `obsolete,none,error'.  We read it from left to
+# right, and:
+# - if none or noCATEGORY is met, run IF-FALSE
+# - if all or CATEGORY is met, run IF-TRUE
+# - if there is nothing left, run IF-FALSE.
+m4_define([m4_warning_ifelse],
+[_m4_warning_ifelse([$1], [$2], [$3], m4_warnings)])
+
+
+# _m4_warning_ifelse(CATEGORY, IF-TRUE, IF-FALSE, WARNING1, ...)
+# --------------------------------------------------------------
+# Implementation of the loop described above.
+m4_define([_m4_warning_ifelse],
+[m4_case([$4],
+         [$1],    [$2],
+         [all],   [$2],
+         [],      [$3],
+         [none],  [$3],
+         [no-$1], [$3],
+         [$0([$1], [$2], [$3], m4_shiftn(4, $@))])])
+
+
+# _m4_warning_error_ifelse(IF-TRUE, IF-FALSE)
+# -------------------------------------------
+# The same as m4_warning_ifelse, but scan for `error' only.
+m4_define([_m4_warning_error_ifelse],
+[__m4_warning_error_ifelse([$1], [$2], m4_warnings)])
+
+
+# __m4_warning_error_ifelse(IF-TRUE, IF-FALSE)
+# --------------------------------------------
+# The same as _m4_warning_ifelse, but scan for `error' only.
+m4_define([__m4_warning_error_ifelse],
+[m4_case([$3],
+         [error],    [$1],
+         [],         [$2],
+         [no-error], [$2],
+         [$0([$1], [$2], m4_shiftn(3, $@))])])
+
+
+
+# _m4_warn(MESSAGE)
+# -----------------
+# Report MESSAGE as a warning, unless the user requested -W error,
+# in which case report a fatal error.
+m4_define([_m4_warn],
+[_m4_warning_error_ifelse([m4_fatal([$1])],
+                          [m4_warning([$1])])])
+
+
+# m4_warn(CATEGORY, MESSAGE)
+# --------------------------
+# Report a MESSAGE to the autoconf user if the CATEGORY of warnings
+# is requested (in fact, not disabled).
+m4_define([m4_warn],
+[m4_warning_ifelse([$1], [_m4_warn([$2])])])
+
+
+
+
+## ------------------- ##
+## 4. File inclusion.  ##
+## ------------------- ##
+
+
+# We also want to neutralize include (and sinclude for symmetry),
+# but we want to extend them slightly: warn when a file is included
+# several times.  This is in general a dangerous operation because
+# quite nobody quotes the first argument of m4_define.
+#
+# For instance in the following case:
+#   m4_define(foo, [bar])
+# then a second reading will turn into
+#   m4_define(bar, [bar])
+# which is certainly not what was meant.
+
+# m4_include_unique(FILE)
+# -----------------------
+# Declare that the FILE was loading; and warn if it has already
+# been included.
+m4_define([m4_include_unique],
+[m4_ifdef([m4_include($1)],
+          [m4_warn([syntax], [file `$1' included several times])])dnl
+m4_define([m4_include($1)])])
+
+
+# m4_include(FILE)
+# ----------------
+# As the builtin include, but warns against multiple inclusions.
+m4_define([m4_include],
+[m4_include_unique([$1])dnl
+m4_builtin([include], [$1])])
+
+
+# m4_sinclude(FILE)
+# -----------------
+# As the builtin sinclude, but warns against multiple inclusions.
+m4_define([m4_sinclude],
+[m4_include_unique([$1])dnl
+m4_builtin([sinclude], [$1])])
+
+
+
+## ------------------------------------ ##
+## 5. Additional branching constructs.  ##
+## ------------------------------------ ##
+
+# Both `m4_ifval' and `m4_ifset' tests against the empty string.  The
+# difference is that `m4_ifset' is specialized on macros.
+#
+# In case of arguments of macros, eg $[1], it makes little difference.
+# In the case of a macro `FOO', you don't want to check `m4_ifval(FOO,
+# TRUE)', because if `FOO' expands with commas, there is a shifting of
+# the arguments.  So you want to run `m4_ifval([FOO])', but then you just
+# compare the *string* `FOO' against `', which, of course fails.
+#
+# So you want a variation of `m4_ifset' that expects a macro name as $[1].
+# If this macro is both defined and defined to a non empty value, then
+# it runs TRUE etc.
+
+
+# m4_ifval(COND, [IF-TRUE], [IF-FALSE])
+# -------------------------------------
+# If COND is not the empty string, expand IF-TRUE, otherwise IF-FALSE.
+# Comparable to m4_ifdef.
+m4_define([m4_ifval],
+[m4_if([$1], [], [$3], [$2])])
+
+
+# m4_n(TEXT)
+# ----------
+# If TEXT is not empty, return TEXT and a new line, otherwise nothing.
+m4_define([m4_n],
+[m4_if([$1],
+       [], [],
+           [$1
+])])
+
+
+# m4_ifvaln(COND, [IF-TRUE], [IF-FALSE])
+# --------------------------------------
+# Same as `m4_ifval', but add an extra newline to IF-TRUE or IF-FALSE
+# unless that argument is empty.
+m4_define([m4_ifvaln],
+[m4_if([$1],
+       [],   [m4_n([$3])],
+             [m4_n([$2])])])
+
+
+# m4_ifset(MACRO, [IF-TRUE], [IF-FALSE])
+# --------------------------------------
+# If MACRO has no definition, or of its definition is the empty string,
+# expand IF-FALSE, otherwise IF-TRUE.
+m4_define([m4_ifset],
+[m4_ifdef([$1],
+          [m4_if(m4_defn([$1]), [], [$3], [$2])],
+          [$3])])
+
+
+# m4_ifndef(NAME, [IF-NOT-DEFINED], [IF-DEFINED])
+# -----------------------------------------------
+m4_define([m4_ifndef],
+[m4_ifdef([$1], [$3], [$2])])
+
+
+# m4_case(SWITCH, VAL1, IF-VAL1, VAL2, IF-VAL2, ..., DEFAULT)
+# -----------------------------------------------------------
+# m4 equivalent of
+# switch (SWITCH)
+# {
+#   case VAL1:
+#     IF-VAL1;
+#     break;
+#   case VAL2:
+#     IF-VAL2;
+#     break;
+#   ...
+#   default:
+#     DEFAULT;
+#     break;
+# }.
+# All the values are optional, and the macro is robust to active
+# symbols properly quoted.
+m4_define([m4_case],
+[m4_if([$#], 0, [],
+       [$#], 1, [],
+       [$#], 2, [$2],
+       [$1], [$2], [$3],
+       [$0([$1], m4_shiftn(3, $@))])])
+
+
+# m4_bmatch(SWITCH, RE1, VAL1, RE2, VAL2, ..., DEFAULT)
+# -----------------------------------------------------
+# m4 equivalent of
+#
+# if (SWITCH =~ RE1)
+#   VAL1;
+# elif (SWITCH =~ RE2)
+#   VAL2;
+# elif ...
+#   ...
+# else
+#   DEFAULT
+#
+# All the values are optional, and the macro is robust to active symbols
+# properly quoted.
+m4_define([m4_bmatch],
+[m4_if([$#], 0, [],
+       [$#], 1, [],
+       [$#], 2, [$2],
+       [m4_if(m4_bregexp([$1], [$2]), -1, [$0([$1], m4_shiftn(3, $@))],
+	      [$3])])])
+
+
+# m4_map(MACRO, LIST)
+# -------------------
+# Invoke MACRO($1), MACRO($2) etc. where $1, $2... are the elements
+# of LIST (which can be lists themselves, for multiple arguments MACROs).
+m4_define([m4_fst], [$1])
+m4_define([m4_map],
+[m4_if([$2], [], [],
+       [$2], [[]], [],
+       [$1(m4_fst($2))[]dnl
+m4_map([$1], m4_cdr($2))])])
+
+
+# m4_map_sep(MACRO, SEPARATOR, LIST)
+# ----------------------------------
+# Invoke MACRO($1), SEPARATOR, MACRO($2), ..., MACRO($N) where $1, $2... $N
+# are the elements of LIST (which can be lists themselves, for multiple
+# arguments MACROs).
+m4_define([m4_map_sep],
+[m4_if([$3], [[]], [],
+       [$1(m4_fst($3))[]dnl
+m4_if(m4_cdr($3),
+      [[]], [],
+      [$2])[]dnl
+m4_map_sep([$1], [$2], m4_cdr($3))])])
+
+
+## ---------------------------------------- ##
+## 6. Enhanced version of some primitives.  ##
+## ---------------------------------------- ##
+
+# m4_patsubsts(STRING, RE1, SUBST1, RE2, SUBST2, ...)
+# ---------------------------------------------------
+# m4 equivalent of
+#
+#   $_ = STRING;
+#   s/RE1/SUBST1/g;
+#   s/RE2/SUBST2/g;
+#   ...
+#
+# All the values are optional, and the macro is robust to active symbols
+# properly quoted.
+#
+# I would have liked to name this macro `m4_patsubst', unfortunately,
+# due to quotation problems, I need to double quote $1 below, therefore
+# the anchors are broken :(  I can't let users be trapped by that.
+m4_define([m4_bpatsubsts],
+[m4_if([$#], 0, [m4_fatal([$0: too few arguments: $#])],
+       [$#], 1, [m4_fatal([$0: too few arguments: $#: $1])],
+       [$#], 2, [m4_builtin([patsubst], $@)],
+       [$0(m4_builtin([patsubst], [[$1]], [$2], [$3]),
+           m4_shiftn(3, $@))])])
+
+
+
+# m4_do(STRING, ...)
+# ------------------
+# This macro invokes all its arguments (in sequence, of course).  It is
+# useful for making your macros more structured and readable by dropping
+# unnecessary dnl's and have the macros indented properly.
+m4_define([m4_do],
+[m4_if($#, 0, [],
+       $#, 1, [$1],
+       [$1[]m4_do(m4_shift($@))])])
+
+
+# m4_define_default(MACRO, VALUE)
+# -------------------------------
+# If MACRO is undefined, set it to VALUE.
+m4_define([m4_define_default],
+[m4_ifndef([$1], [m4_define($@)])])
+
+
+# m4_default(EXP1, EXP2)
+# ----------------------
+# Returns EXP1 if non empty, otherwise EXP2.
+m4_define([m4_default],
+[m4_ifval([$1], [$1], [$2])])
+
+
+# m4_defn(NAME)
+# -------------
+# Unlike to the original, don't tolerate popping something which is
+# undefined.
+m4_define([m4_defn],
+[m4_ifndef([$1],
+           [m4_fatal([$0: undefined macro: $1])])dnl
+m4_builtin([defn], $@)])
+
+
+# _m4_dumpdefs_up(NAME)
+# ---------------------
+m4_define([_m4_dumpdefs_up],
+[m4_ifdef([$1],
+          [m4_pushdef([_m4_dumpdefs], m4_defn([$1]))dnl
+m4_dumpdef([$1])dnl
+m4_popdef([$1])dnl
+_m4_dumpdefs_up([$1])])])
+
+
+# _m4_dumpdefs_down(NAME)
+# -----------------------
+m4_define([_m4_dumpdefs_down],
+[m4_ifdef([_m4_dumpdefs],
+          [m4_pushdef([$1], m4_defn([_m4_dumpdefs]))dnl
+m4_popdef([_m4_dumpdefs])dnl
+_m4_dumpdefs_down([$1])])])
+
+
+# m4_dumpdefs(NAME)
+# -----------------
+# Similar to `m4_dumpdef(NAME)', but if NAME was m4_pushdef'ed, display its
+# value stack (most recent displayed first).
+m4_define([m4_dumpdefs],
+[_m4_dumpdefs_up([$1])dnl
+_m4_dumpdefs_down([$1])])
+
+
+# m4_popdef(NAME)
+# ---------------
+# Unlike to the original, don't tolerate popping something which is
+# undefined.
+m4_define([m4_popdef],
+[m4_ifndef([$1],
+           [m4_fatal([$0: undefined macro: $1])])dnl
+m4_builtin([popdef], $@)])
+
+
+# m4_quote(ARGS)
+# --------------
+# Return ARGS as a single arguments.
+#
+# It is important to realize the difference between `m4_quote(exp)' and
+# `[exp]': in the first case you obtain the quoted *result* of the
+# expansion of EXP, while in the latter you just obtain the string
+# `exp'.
+m4_define([m4_quote],  [[$*]])
+m4_define([m4_dquote],  [[$@]])
+
+
+# m4_noquote(STRING)
+# ------------------
+# Return the result of ignoring all quotes in STRING and invoking the
+# macros it contains.  Amongst other things useful for enabling macro
+# invocations inside strings with [] blocks (for instance regexps and
+# help-strings).
+m4_define([m4_noquote],
+[m4_changequote(-=<{,}>=-)$1-=<{}>=-m4_changequote([,])])
+
+
+# m4_shiftn(N, ...)
+# -----------------
+# Returns ... shifted N times.  Useful for recursive "varargs" constructs.
+m4_define([m4_shiftn],
+[m4_assert(($1 >= 0) && ($# > $1))dnl
+_m4_shiftn($@)])
+
+m4_define([_m4_shiftn],
+[m4_if([$1], 0,
+       [m4_shift($@)],
+       [_m4_shiftn(m4_eval([$1]-1), m4_shift(m4_shift($@)))])])
+
+
+# m4_undefine(NAME)
+# -----------------
+# Unlike to the original, don't tolerate undefining something which is
+# undefined.
+m4_define([m4_undefine],
+[m4_ifndef([$1],
+           [m4_fatal([$0: undefined macro: $1])])dnl
+m4_builtin([undefine], $@)])
+
+
+## -------------------------- ##
+## 7. Implementing m4 loops.  ##
+## -------------------------- ##
+
+
+# m4_for(VARIABLE, FIRST, LAST, [STEP = +/-1], EXPRESSION)
+# --------------------------------------------------------
+# Expand EXPRESSION defining VARIABLE to FROM, FROM + 1, ..., TO.
+# Both limits are included, and bounds are checked for consistency.
+m4_define([m4_for],
+[m4_case(m4_sign(m4_eval($3 - $2)),
+         1, [m4_assert(m4_sign(m4_default($4, 1)) == 1)],
+        -1, [m4_assert(m4_sign(m4_default($4, -1)) == -1)])dnl
+m4_pushdef([$1], [$2])dnl
+m4_if(m4_eval([$3 > $2]), 1,
+      [_m4_for([$1], [$3], m4_default([$4], 1), [$5])],
+      [_m4_for([$1], [$3], m4_default([$4], -1), [$5])])dnl
+m4_popdef([$1])])
+
+
+# _m4_for(VARIABLE, FIRST, LAST, STEP, EXPRESSION)
+# ------------------------------------------------
+# Core of the loop, no consistency checks.
+m4_define([_m4_for],
+[$4[]dnl
+m4_if($1, [$2], [],
+      [m4_define([$1], m4_eval($1+[$3]))_m4_for([$1], [$2], [$3], [$4])])])
+
+
+# Implementing `foreach' loops in m4 is much more tricky than it may
+# seem.  Actually, the example of a `foreach' loop in the m4
+# documentation is wrong: it does not quote the arguments properly,
+# which leads to undesirable expansions.
+#
+# The example in the documentation is:
+#
+# | # foreach(VAR, (LIST), STMT)
+# | m4_define([foreach],
+# |        [m4_pushdef([$1])_foreach([$1], [$2], [$3])m4_popdef([$1])])
+# | m4_define([_arg1], [$1])
+# | m4_define([_foreach],
+# | 	      [m4_if([$2], [()], ,
+# | 		     [m4_define([$1], _arg1$2)$3[]_foreach([$1],
+# |                                                        (shift$2),
+# |                                                        [$3])])])
+#
+# But then if you run
+#
+# | m4_define(a, 1)
+# | m4_define(b, 2)
+# | m4_define(c, 3)
+# | foreach([f], [([a], [(b], [c)])], [echo f
+# | ])
+#
+# it gives
+#
+#  => echo 1
+#  => echo (2,3)
+#
+# which is not what is expected.
+#
+# Of course the problem is that many quotes are missing.  So you add
+# plenty of quotes at random places, until you reach the expected
+# result.  Alternatively, if you are a quoting wizard, you directly
+# reach the following implementation (but if you really did, then
+# apply to the maintenance of m4sugar!).
+#
+# | # foreach(VAR, (LIST), STMT)
+# | m4_define([foreach], [m4_pushdef([$1])_foreach($@)m4_popdef([$1])])
+# | m4_define([_arg1], [[$1]])
+# | m4_define([_foreach],
+# |  [m4_if($2, [()], ,
+# | 	    [m4_define([$1], [_arg1$2])$3[]_foreach([$1],
+# |                                                 [(shift$2)],
+# |                                                 [$3])])])
+#
+# which this time answers
+#
+#  => echo a
+#  => echo (b
+#  => echo c)
+#
+# Bingo!
+#
+# Well, not quite.
+#
+# With a better look, you realize that the parens are more a pain than
+# a help: since anyway you need to quote properly the list, you end up
+# with always using an outermost pair of parens and an outermost pair
+# of quotes.  Rejecting the parens both eases the implementation, and
+# simplifies the use:
+#
+# | # foreach(VAR, (LIST), STMT)
+# | m4_define([foreach], [m4_pushdef([$1])_foreach($@)m4_popdef([$1])])
+# | m4_define([_arg1], [$1])
+# | m4_define([_foreach],
+# |  [m4_if($2, [], ,
+# | 	    [m4_define([$1], [_arg1($2)])$3[]_foreach([$1],
+# |                                                   [shift($2)],
+# |                                                   [$3])])])
+#
+#
+# Now, just replace the `$2' with `m4_quote($2)' in the outer `m4_if'
+# to improve robustness, and you come up with a quite satisfactory
+# implementation.
+
+
+# m4_foreach(VARIABLE, LIST, EXPRESSION)
+# --------------------------------------
+#
+# Expand EXPRESSION assigning each value of the LIST to VARIABLE.
+# LIST should have the form `item_1, item_2, ..., item_n', i.e. the
+# whole list must *quoted*.  Quote members too if you don't want them
+# to be expanded.
+#
+# This macro is robust to active symbols:
+#      | m4_define(active, [ACT, IVE])
+#      | m4_foreach(Var, [active, active], [-Var-])
+#     => -ACT--IVE--ACT--IVE-
+#
+#      | m4_foreach(Var, [[active], [active]], [-Var-])
+#     => -ACT, IVE--ACT, IVE-
+#
+#      | m4_foreach(Var, [[[active]], [[active]]], [-Var-])
+#     => -active--active-
+m4_define([m4_foreach],
+[m4_pushdef([$1])_m4_foreach($@)m4_popdef([$1])])
+
+# Low level macros used to define m4_foreach.
+m4_define([m4_car], [[$1]])
+m4_define([m4_cdr], [m4_dquote(m4_shift($@))])
+m4_define([_m4_foreach],
+[m4_if([$2], [[]], [],
+       [m4_define([$1], m4_car($2))$3[]_m4_foreach([$1],
+                                                   m4_cdr($2),
+                                                   [$3])])])
+
+
+
+## --------------------------- ##
+## 8. More diversion support.  ##
+## --------------------------- ##
+
+
+# _m4_divert(DIVERSION-NAME or NUMBER)
+# ------------------------------------
+# If DIVERSION-NAME is the name of a diversion, return its number,
+# otherwise if is a NUMBER return it.
+m4_define([_m4_divert],
+[m4_ifdef([_m4_divert($1)],
+          [m4_indir([_m4_divert($1)])],
+          [$1])])
+
+# KILL is only used to suppress output.
+m4_define([_m4_divert(KILL)],           -1)
+
+
+# m4_divert(DIVERSION-NAME)
+# -------------------------
+# Change the diversion stream to DIVERSION-NAME.
+m4_define([m4_divert],
+[m4_define([m4_divert_stack],
+           m4_location[: $0: $1]m4_ifdef([m4_divert_stack], [
+m4_defn([m4_divert_stack])]))dnl
+m4_builtin([divert], _m4_divert([$1]))dnl
+])
+
+
+# m4_divert_push(DIVERSION-NAME)
+# ------------------------------
+# Change the diversion stream to DIVERSION-NAME, while stacking old values.
+m4_define([m4_divert_push],
+[m4_pushdef([m4_divert_stack],
+            m4_location[: $0: $1]m4_ifdef([m4_divert_stack], [
+m4_defn([m4_divert_stack])]))dnl
+m4_pushdef([_m4_divert_diversion], [$1])dnl
+m4_builtin([divert], _m4_divert(_m4_divert_diversion))dnl
+])
+
+
+# m4_divert_pop([DIVERSION-NAME])
+# -------------------------------
+# Change the diversion stream to its previous value, unstacking it.
+# If specified, verify we left DIVERSION-NAME.
+m4_define([m4_divert_pop],
+[m4_ifval([$1],
+     [m4_if(_m4_divert([$1]), m4_divnum, [],
+            [m4_fatal([$0($1): diversion mismatch: ]
+m4_defn([m4_divert_stack]))])])dnl
+m4_popdef([_m4_divert_diversion])dnl
+dnl m4_ifndef([_m4_divert_diversion],
+dnl           [m4_fatal([too many m4_divert_pop])])dnl
+m4_builtin([divert],
+           m4_ifdef([_m4_divert_diversion],
+                    [_m4_divert(_m4_divert_diversion)], -1))dnl
+m4_popdef([m4_divert_stack])dnl
+])
+
+
+# m4_divert_text(DIVERSION-NAME, CONTENT)
+# ---------------------------------------
+# Output CONTENT into DIVERSION-NAME (which may be a number actually).
+# An end of line is appended for free to CONTENT.
+m4_define([m4_divert_text],
+[m4_divert_push([$1])dnl
+$2
+m4_divert_pop([$1])dnl
+])
+
+
+# m4_divert_once(DIVERSION-NAME, CONTENT)
+# ---------------------------------------
+# Output once CONTENT into DIVERSION-NAME (which may be a number
+# actually).  An end of line is appended for free to CONTENT.
+m4_define([m4_divert_once],
+[m4_expand_once([m4_divert_text([$1], [$2])])])
+
+
+# m4_undivert(DIVERSION-NAME)
+# ---------------------------
+# Undivert DIVERSION-NAME.
+m4_define([m4_undivert],
+[m4_builtin([undivert], _m4_divert([$1]))])
+
+
+## -------------------------------------------- ##
+## 8. Defining macros with bells and whistles.  ##
+## -------------------------------------------- ##
+
+# `m4_defun' is basically `m4_define' but it equips the macro with the
+# needed machinery for `m4_require'.  A macro must be m4_defun'd if
+# either it is m4_require'd, or it m4_require's.
+#
+# Two things deserve attention and are detailed below:
+#  1. Implementation of m4_require
+#  2. Keeping track of the expansion stack
+#
+# 1. Implementation of m4_require
+# ===============================
+#
+# Of course m4_defun AC_PROVIDE's the macro, so that a macro which has
+# been expanded is not expanded again when m4_require'd, but the
+# difficult part is the proper expansion of macros when they are
+# m4_require'd.
+#
+# The implementation is based on two ideas, (i) using diversions to
+# prepare the expansion of the macro and its dependencies (by Franois
+# Pinard), and (ii) expand the most recently m4_require'd macros _after_
+# the previous macros (by Axel Thimm).
+#
+#
+# The first idea: why using diversions?
+# -------------------------------------
+#
+# When a macro requires another, the other macro is expanded in new
+# diversion, GROW.  When the outer macro is fully expanded, we first
+# undivert the most nested diversions (GROW - 1...), and finally
+# undivert GROW.  To understand why we need several diversions,
+# consider the following example:
+#
+# | m4_defun([TEST1], [Test...REQUIRE([TEST2])1])
+# | m4_defun([TEST2], [Test...REQUIRE([TEST3])2])
+# | m4_defun([TEST3], [Test...3])
+#
+# Because m4_require is not required to be first in the outer macros, we
+# must keep the expansions of the various level of m4_require separated.
+# Right before executing the epilogue of TEST1, we have:
+#
+# 	   GROW - 2: Test...3
+# 	   GROW - 1: Test...2
+# 	   GROW:     Test...1
+# 	   BODY:
+#
+# Finally the epilogue of TEST1 undiverts GROW - 2, GROW - 1, and
+# GROW into the regular flow, BODY.
+#
+# 	   GROW - 2:
+# 	   GROW - 1:
+# 	   GROW:
+# 	   BODY:        Test...3; Test...2; Test...1
+#
+# (The semicolons are here for clarification, but of course are not
+# emitted.)  This is what Autoconf 2.0 (I think) to 2.13 (I'm sure)
+# implement.
+#
+#
+# The second idea: first required first out
+# -----------------------------------------
+#
+# The natural implementation of the idea above is buggy and produces
+# very surprising results in some situations.  Let's consider the
+# following example to explain the bug:
+#
+# | m4_defun([TEST1],  [REQUIRE([TEST2a])REQUIRE([TEST2b])])
+# | m4_defun([TEST2a], [])
+# | m4_defun([TEST2b], [REQUIRE([TEST3])])
+# | m4_defun([TEST3],  [REQUIRE([TEST2a])])
+# |
+# | AC_INIT
+# | TEST1
+#
+# The dependencies between the macros are:
+#
+# 		 3 --- 2b
+# 		/        \              is m4_require'd by
+# 	       /          \       left -------------------- right
+# 	    2a ------------ 1
+#
+# If you strictly apply the rules given in the previous section you get:
+#
+# 	   GROW - 2: TEST3
+# 	   GROW - 1: TEST2a; TEST2b
+# 	   GROW:     TEST1
+# 	   BODY:
+#
+# (TEST2a, although required by TEST3 is not expanded in GROW - 3
+# because is has already been expanded before in GROW - 1, so it has
+# been AC_PROVIDE'd, so it is not expanded again) so when you undivert
+# the stack of diversions, you get:
+#
+# 	   GROW - 2:
+# 	   GROW - 1:
+# 	   GROW:
+# 	   BODY:        TEST3; TEST2a; TEST2b; TEST1
+#
+# i.e., TEST2a is expanded after TEST3 although the latter required the
+# former.
+#
+# Starting from 2.50, uses an implementation provided by Axel Thimm.
+# The idea is simple: the order in which macros are emitted must be the
+# same as the one in which macro are expanded.  (The bug above can
+# indeed be described as: a macro has been AC_PROVIDE'd, but it is
+# emitted after: the lack of correlation between emission and expansion
+# order is guilty).
+#
+# How to do that?  You keeping the stack of diversions to elaborate the
+# macros, but each time a macro is fully expanded, emit it immediately.
+#
+# In the example above, when TEST2a is expanded, but it's epilogue is
+# not run yet, you have:
+#
+# 	   GROW - 2:
+# 	   GROW - 1: TEST2a
+# 	   GROW:     Elaboration of TEST1
+# 	   BODY:
+#
+# The epilogue of TEST2a emits it immediately:
+#
+# 	   GROW - 2:
+# 	   GROW - 1:
+# 	   GROW:     Elaboration of TEST1
+# 	   BODY:     TEST2a
+#
+# TEST2b then requires TEST3, so right before the epilogue of TEST3, you
+# have:
+#
+# 	   GROW - 2: TEST3
+# 	   GROW - 1: Elaboration of TEST2b
+# 	   GROW:     Elaboration of TEST1
+# 	   BODY:      TEST2a
+#
+# The epilogue of TEST3 emits it:
+#
+# 	   GROW - 2:
+# 	   GROW - 1: Elaboration of TEST2b
+# 	   GROW:     Elaboration of TEST1
+# 	   BODY:     TEST2a; TEST3
+#
+# TEST2b is now completely expanded, and emitted:
+#
+# 	   GROW - 2:
+# 	   GROW - 1:
+# 	   GROW:     Elaboration of TEST1
+# 	   BODY:     TEST2a; TEST3; TEST2b
+#
+# and finally, TEST1 is finished and emitted:
+#
+# 	   GROW - 2:
+# 	   GROW - 1:
+# 	   GROW:
+# 	   BODY:     TEST2a; TEST3; TEST2b: TEST1
+#
+# The idea, is simple, but the implementation is a bit evolved.  If you
+# are like me, you will want to see the actual functioning of this
+# implementation to be convinced.  The next section gives the full
+# details.
+#
+#
+# The Axel Thimm implementation at work
+# -------------------------------------
+#
+# We consider the macros above, and this configure.ac:
+#
+# 	    AC_INIT
+# 	    TEST1
+#
+# You should keep the definitions of _m4_defun_pro, _m4_defun_epi, and
+# m4_require at hand to follow the steps.
+#
+# This implements tries not to assume that of the current diversion is
+# BODY, so as soon as a macro (m4_defun'd) is expanded, we first
+# record the current diversion under the name _m4_divert_dump (denoted
+# DUMP below for short).  This introduces an important difference with
+# the previous versions of Autoconf: you cannot use m4_require if you
+# were not inside an m4_defun'd macro, and especially, you cannot
+# m4_require directly from the top level.
+#
+# We have not tried to simulate the old behavior (better yet, we
+# diagnose it), because it is too dangerous: a macro m4_require'd from
+# the top level is expanded before the body of `configure', i.e., before
+# any other test was run.  I let you imagine the result of requiring
+# AC_STDC_HEADERS for instance, before AC_PROG_CC was actually run....
+#
+# After AC_INIT was run, the current diversion is BODY.
+# * AC_INIT was run
+#   DUMP:                undefined
+#   diversion stack:     BODY |-
+#
+# * TEST1 is expanded
+# The prologue of TEST1 sets AC_DIVERSION_DUMP, which is the diversion
+# where the current elaboration will be dumped, to the current
+# diversion.  It also m4_divert_push to GROW, where the full
+# expansion of TEST1 and its dependencies will be elaborated.
+#   DUMP:       BODY
+#   BODY:       empty
+#   diversions: GROW, BODY |-
+#
+# * TEST1 requires TEST2a: prologue
+# m4_require m4_divert_pushes another temporary diversion GROW - 1 (in
+# fact, the diversion whose number is one less than the current
+# diversion), and expands TEST2a in there.
+#   DUMP:       BODY
+#   BODY:       empty
+#   diversions: GROW-1, GROW, BODY |-
+#
+# * TEST2a is expanded.
+# Its prologue pushes the current diversion again.
+#   DUMP:       BODY
+#   BODY:       empty
+#   diversions: GROW - 1, GROW - 1, GROW, BODY |-
+# It is expanded in GROW - 1, and GROW - 1 is popped by the epilogue
+# of TEST2a.
+#   DUMP:        BODY
+#   BODY:        nothing
+#   GROW - 1:    TEST2a
+#   diversions:  GROW - 1, GROW, BODY |-
+#
+# * TEST1 requires TEST2a: epilogue
+# The content of the current diversion is appended to DUMP (and removed
+# from the current diversion).  A diversion is popped.
+#   DUMP:       BODY
+#   BODY:       TEST2a
+#   diversions: GROW, BODY |-
+#
+# * TEST1 requires TEST2b: prologue
+# m4_require pushes GROW - 1 and expands TEST2b.
+#   DUMP:       BODY
+#   BODY:       TEST2a
+#   diversions: GROW - 1, GROW, BODY |-
+#
+# * TEST2b is expanded.
+# Its prologue pushes the current diversion again.
+#   DUMP:       BODY
+#   BODY:       TEST2a
+#   diversions: GROW - 1, GROW - 1, GROW, BODY |-
+# The body is expanded here.
+#
+# * TEST2b requires TEST3: prologue
+# m4_require pushes GROW - 2 and expands TEST3.
+#   DUMP:       BODY
+#   BODY:       TEST2a
+#   diversions: GROW - 2, GROW - 1, GROW - 1, GROW, BODY |-
+#
+# * TEST3 is expanded.
+# Its prologue pushes the current diversion again.
+#   DUMP:       BODY
+#   BODY:       TEST2a
+#   diversions: GROW-2, GROW-2, GROW-1, GROW-1, GROW, BODY |-
+# TEST3 requires TEST2a, but TEST2a has already been AC_PROVIDE'd, so
+# nothing happens.  It's body is expanded here, and its epilogue pops a
+# diversion.
+#   DUMP:       BODY
+#   BODY:       TEST2a
+#   GROW - 2:   TEST3
+#   diversions: GROW - 2, GROW - 1, GROW - 1, GROW, BODY |-
+#
+# * TEST2b requires TEST3: epilogue
+# The current diversion is appended to DUMP, and a diversion is popped.
+#   DUMP:       BODY
+#   BODY:       TEST2a; TEST3
+#   diversions: GROW - 1, GROW - 1, GROW, BODY |-
+# The content of TEST2b is expanded here.
+#   DUMP:       BODY
+#   BODY:       TEST2a; TEST3
+#   GROW - 1:   TEST2b,
+#   diversions: GROW - 1, GROW - 1, GROW, BODY |-
+# The epilogue of TEST2b pops a diversion.
+#   DUMP:       BODY
+#   BODY:       TEST2a; TEST3
+#   GROW - 1:   TEST2b,
+#   diversions: GROW - 1, GROW, BODY |-
+#
+# * TEST1 requires TEST2b: epilogue
+# The current diversion is appended to DUMP, and a diversion is popped.
+#   DUMP:       BODY
+#   BODY:       TEST2a; TEST3; TEST2b
+#   diversions: GROW, BODY |-
+#
+# * TEST1 is expanded: epilogue
+# TEST1's own content is in GROW, and it's epilogue pops a diversion.
+#   DUMP:       BODY
+#   BODY:       TEST2a; TEST3; TEST2b
+#   GROW:       TEST1
+#   diversions: BODY |-
+# Here, the epilogue of TEST1 notices the elaboration is done because
+# DUMP and the current diversion are the same, it then undiverts
+# GROW by hand, and undefines DUMP.
+#   DUMP:       undefined
+#   BODY:       TEST2a; TEST3; TEST2b; TEST1
+#   diversions: BODY |-
+#
+#
+# 2. Keeping track of the expansion stack
+# =======================================
+#
+# When M4 expansion goes wrong it is often extremely hard to find the
+# path amongst macros that drove to the failure.  What is needed is
+# the stack of macro `calls'. One could imagine that GNU M4 would
+# maintain a stack of macro expansions, unfortunately it doesn't, so
+# we do it by hand.  This is of course extremely costly, but the help
+# this stack provides is worth it.  Nevertheless to limit the
+# performance penalty this is implemented only for m4_defun'd macros,
+# not for define'd macros.
+#
+# The scheme is simplistic: each time we enter an m4_defun'd macros,
+# we prepend its name in m4_expansion_stack, and when we exit the
+# macro, we remove it (thanks to pushdef/popdef).
+#
+# In addition, we want to use the expansion stack to detect circular
+# m4_require dependencies.  This means we need to browse the stack to
+# check whether a macro being expanded is m4_require'd.  For ease of
+# implementation, and certainly for the benefit of performances, we
+# don't browse the m4_expansion_stack, rather each time we expand a
+# macro FOO we define _m4_expanding(FOO).  Then m4_require(BAR) simply
+# needs to check whether _m4_expanding(BAR) is defined to diagnose a
+# circular dependency.
+#
+# To improve the diagnostic, in addition to keeping track of the stack
+# of macro calls, m4_expansion_stack also records the m4_require
+# stack.  Note that therefore an m4_defun'd macro being required will
+# appear twice in the stack: the first time because it is required,
+# the second because it is expanded.  We can avoid this, but it has
+# two small drawbacks: (i) the implementation is slightly more
+# complex, and (ii) it hides the difference between define'd macros
+# (which don't appear in m4_expansion_stack) and m4_defun'd macros
+# (which do).  The more debugging information, the better.
+
+
+# m4_expansion_stack_push(TEXT)
+# -----------------------------
+m4_define([m4_expansion_stack_push],
+[m4_pushdef([m4_expansion_stack],
+            [$1]m4_ifdef([m4_expansion_stack], [
+m4_defn([m4_expansion_stack])]))])
+
+
+# m4_expansion_stack_pop
+# ----------------------
+# Dump the expansion stack.
+m4_define([m4_expansion_stack_pop],
+[m4_popdef([m4_expansion_stack])])
+
+
+# m4_expansion_stack_dump
+# -----------------------
+# Dump the expansion stack.
+m4_define([m4_expansion_stack_dump],
+[m4_ifdef([m4_expansion_stack],
+          [m4_errprintn(m4_defn([m4_expansion_stack]))])dnl
+m4_errprintn(m4_location[: the top level])])
+
+
+# _m4_divert(GROW)
+# ----------------
+# This diversion is used by the m4_defun/m4_require machinery.  It is
+# important to keep room before GROW because for each nested
+# AC_REQUIRE we use an additional diversion (i.e., two m4_require's
+# will use GROW - 2.  More than 3 levels has never seemed to be
+# needed.)
+#
+# ...
+# - GROW - 2
+#   m4_require'd code, 2 level deep
+# - GROW - 1
+#   m4_require'd code, 1 level deep
+# - GROW
+#   m4_defun'd macros are elaborated here.
+
+m4_define([_m4_divert(GROW)],       10000)
+
+
+# _m4_defun_pro(MACRO-NAME)
+# -------------------------
+# The prologue for Autoconf macros.
+m4_define([_m4_defun_pro],
+[m4_expansion_stack_push(m4_defn([m4_location($1)])[: $1 is expanded from...])dnl
+m4_pushdef([_m4_expanding($1)])dnl
+m4_ifdef([_m4_divert_dump],
+         [m4_divert_push(m4_defn([_m4_divert_diversion]))],
+         [m4_copy([_m4_divert_diversion], [_m4_divert_dump])dnl
+m4_divert_push([GROW])])dnl
+])
+
+
+# _m4_defun_epi(MACRO-NAME)
+# -------------------------
+# The Epilogue for Autoconf macros.  MACRO-NAME only helps tracing
+# the PRO/EPI pairs.
+m4_define([_m4_defun_epi],
+[m4_divert_pop()dnl
+m4_if(_m4_divert_dump, _m4_divert_diversion,
+      [m4_undivert([GROW])dnl
+m4_undefine([_m4_divert_dump])])dnl
+m4_expansion_stack_pop()dnl
+m4_popdef([_m4_expanding($1)])dnl
+m4_provide([$1])dnl
+])
+
+
+# m4_defun(NAME, EXPANSION)
+# -------------------------
+# Define a macro which automatically provides itself.  Add machinery
+# so the macro automatically switches expansion to the diversion
+# stack if it is not already using it.  In this case, once finished,
+# it will bring back all the code accumulated in the diversion stack.
+# This, combined with m4_require, achieves the topological ordering of
+# macros.  We don't use this macro to define some frequently called
+# macros that are not involved in ordering constraints, to save m4
+# processing.
+m4_define([m4_defun],
+[m4_define([m4_location($1)], m4_location)dnl
+m4_define([$1],
+          [_m4_defun_pro([$1])$2[]_m4_defun_epi([$1])])])
+
+
+# m4_defun_once(NAME, EXPANSION)
+# ------------------------------
+# As m4_defun, but issues the EXPANSION only once, and warns if used
+# several times.
+m4_define([m4_defun_once],
+[m4_define([m4_location($1)], m4_location)dnl
+m4_define([$1],
+          [m4_provide_if([$1],
+                         [m4_warn([syntax], [$1 invoked multiple times])],
+                         [_m4_defun_pro([$1])$2[]_m4_defun_epi([$1])])])])
+
+
+# m4_pattern_forbid(ERE, [WHY])
+# -----------------------------
+# Declare that no token matching the extended regular expression ERE
+# should be seen in the output but if...
+m4_define([m4_pattern_forbid], [])
+
+
+# m4_pattern_allow(ERE)
+# ---------------------
+# ... but if that token matches the extended regular expression ERE.
+# Both used via traces.
+m4_define([m4_pattern_allow], [])
+
+
+## ----------------------------- ##
+## Dependencies between macros.  ##
+## ----------------------------- ##
+
+
+# m4_before(THIS-MACRO-NAME, CALLED-MACRO-NAME)
+# ---------------------------------------------
+m4_define([m4_before],
+[m4_provide_if([$2],
+               [m4_warn([syntax], [$2 was called before $1])])])
+
+
+# m4_require(NAME-TO-CHECK, [BODY-TO-EXPAND = NAME-TO-CHECK])
+# -----------------------------------------------------------
+# If NAME-TO-CHECK has never been expanded (actually, if it is not
+# m4_provide'd), expand BODY-TO-EXPAND *before* the current macro
+# expansion.  Once expanded, emit it in _m4_divert_dump.  Keep track
+# of the m4_require chain in m4_expansion_stack.
+#
+# The normal cases are:
+#
+# - NAME-TO-CHECK == BODY-TO-EXPAND
+#   Which you can use for regular macros with or without arguments, e.g.,
+#     m4_require([AC_PROG_CC], [AC_PROG_CC])
+#     m4_require([AC_CHECK_HEADERS(limits.h)], [AC_CHECK_HEADERS(limits.h)])
+#   which is just the same as
+#     m4_require([AC_PROG_CC])
+#     m4_require([AC_CHECK_HEADERS(limits.h)])
+#
+# - BODY-TO-EXPAND == m4_indir([NAME-TO-CHECK])
+#   In the case of macros with irregular names.  For instance:
+#     m4_require([AC_LANG_COMPILER(C)], [indir([AC_LANG_COMPILER(C)])])
+#   which means `if the macro named `AC_LANG_COMPILER(C)' (the parens are
+#   part of the name, it is not an argument) has not been run, then
+#   call it.'
+#   Had you used
+#     m4_require([AC_LANG_COMPILER(C)], [AC_LANG_COMPILER(C)])
+#   then m4_require would have tried to expand `AC_LANG_COMPILER(C)', i.e.,
+#   call the macro `AC_LANG_COMPILER' with `C' as argument.
+#
+#   You could argue that `AC_LANG_COMPILER', when it receives an argument
+#   such as `C' should dispatch the call to `AC_LANG_COMPILER(C)'.  But this
+#   `extension' prevents `AC_LANG_COMPILER' from having actual arguments that
+#   it passes to `AC_LANG_COMPILER(C)'.
+m4_define([m4_require],
+[m4_expansion_stack_push(m4_location[: $1 is required by...])dnl
+m4_ifdef([_m4_expanding($1)],
+         [m4_fatal([$0: circular dependency of $1])])dnl
+m4_ifndef([_m4_divert_dump],
+          [m4_fatal([$0: cannot be used outside of an m4_defun'd macro])])dnl
+m4_provide_if([$1],
+              [],
+              [m4_divert_push(m4_eval(m4_divnum - 1))dnl
+m4_default([$2], [$1])
+m4_divert(m4_defn([_m4_divert_dump]))dnl
+m4_undivert(m4_defn([_m4_divert_diversion]))dnl
+m4_divert_pop(m4_defn([_m4_divert_dump]))])dnl
+m4_provide_if([$1],
+              [],
+              [m4_warn([syntax],
+                       [$1 is m4_require'd but is not m4_defun'd])])dnl
+m4_expansion_stack_pop()dnl
+])
+
+
+# m4_expand_once(TEXT, [WITNESS = TEXT])
+# --------------------------------------
+# If TEXT has never been expanded, expand it *here*.  Use WITNESS as
+# as a memory that TEXT has already been expanded.
+m4_define([m4_expand_once],
+[m4_provide_if(m4_ifval([$2], [[$2]], [[$1]]),
+               [],
+               [m4_provide(m4_ifval([$2], [[$2]], [[$1]]))[]$1])])
+
+
+# m4_provide(MACRO-NAME)
+# ----------------------
+m4_define([m4_provide],
+[m4_define([m4_provide($1)])])
+
+
+# m4_provide_if(MACRO-NAME, IF-PROVIDED, IF-NOT-PROVIDED)
+# -------------------------------------------------------
+# If MACRO-NAME is provided do IF-PROVIDED, else IF-NOT-PROVIDED.
+# The purpose of this macro is to provide the user with a means to
+# check macros which are provided without letting her know how the
+# information is coded.
+m4_define([m4_provide_if],
+[m4_ifdef([m4_provide($1)],
+          [$2], [$3])])
+
+
+## -------------------- ##
+## 9. Text processing.  ##
+## -------------------- ##
+
+
+# m4_cr_letters
+# m4_cr_LETTERS
+# m4_cr_Letters
+# -------------
+m4_define([m4_cr_letters], [abcdefghijklmnopqrstuvwxyz])
+m4_define([m4_cr_LETTERS], [ABCDEFGHIJKLMNOPQRSTUVWXYZ])
+m4_define([m4_cr_Letters],
+m4_defn([m4_cr_letters])dnl
+m4_defn([m4_cr_LETTERS])dnl
+)
+
+
+# m4_cr_digits
+# ------------
+m4_define([m4_cr_digits], [0123456789])
+
+
+# m4_cr_symbols1 & m4_cr_symbols2
+# -------------------------------
+m4_define([m4_cr_symbols1],
+m4_defn([m4_cr_Letters])dnl
+_)
+
+m4_define([m4_cr_symbols2],
+m4_defn([m4_cr_symbols1])dnl
+m4_defn([m4_cr_digits])dnl
+)
+
+
+# m4_re_escape(STRING)
+# --------------------
+# Escape BRE active characters in STRING.
+m4_define([m4_re_escape],
+[m4_bpatsubst([$1],
+              [[][+*.]], [\\\&])])
+
+
+# m4_re_string
+# ------------
+# Regexp for `[a-zA-Z_0-9]*'
+m4_define([m4_re_string],
+m4_defn([m4_cr_symbols2])dnl
+[*]dnl
+)
+
+
+# m4_re_word
+# ----------
+# Regexp for `[a-zA-Z_][a-zA-Z_0-9]*'
+m4_define([m4_re_word],
+m4_defn([m4_cr_symbols1])dnl
+m4_defn([m4_re_string])dnl
+)
+
+
+# m4_tolower(STRING)
+# m4_toupper(STRING)
+# ------------------
+# These macros lowercase and uppercase strings.
+m4_define([m4_tolower],
+[m4_translit([$1], m4_defn([m4_cr_LETTERS]), m4_defn([m4_cr_letters]))])
+m4_define([m4_toupper],
+[m4_translit([$1], m4_defn([m4_cr_letters]), m4_defn([m4_cr_LETTERS]))])
+
+
+# m4_split(STRING, [REGEXP])
+# --------------------------
+#
+# Split STRING into an m4 list of quoted elements.  The elements are
+# quoted with [ and ].  Beginning spaces and end spaces *are kept*.
+# Use m4_strip to remove them.
+#
+# REGEXP specifies where to split.  Default is [\t ]+.
+#
+# Pay attention to the m4_changequotes.  Inner m4_changequotes exist for
+# obvious reasons (we want to insert square brackets).  Outer
+# m4_changequotes are needed because otherwise the m4 parser, when it
+# sees the closing bracket we add to the result, believes it is the
+# end of the body of the macro we define.
+#
+# Also, notice that $1 is quoted twice, since we want the result to
+# be quoted.  Then you should understand that the argument of
+# patsubst is ``STRING'' (i.e., with additional `` and '').
+#
+# This macro is safe on active symbols, i.e.:
+#   m4_define(active, ACTIVE)
+#   m4_split([active active ])end
+#   => [active], [active], []end
+
+m4_changequote(<<, >>)
+m4_define(<<m4_split>>,
+<<m4_changequote(``, '')dnl
+[dnl Can't use m4_default here instead of m4_if, because m4_default uses
+dnl [ and ] as quotes.
+m4_bpatsubst(````$1'''',
+	     m4_if(``$2'',, ``[ 	]+'', ``$2''),
+	     ``], ['')]dnl
+m4_changequote([, ])>>)
+m4_changequote([, ])
+
+
+
+# m4_flatten(STRING)
+# ------------------
+# If STRING contains end of lines, replace them with spaces.  If there
+# are backslashed end of lines, remove them.  This macro is safe with
+# active symbols.
+#    m4_define(active, ACTIVE)
+#    m4_flatten([active
+#    act\
+#    ive])end
+#    => active activeend
+m4_define([m4_flatten],
+[m4_translit(m4_bpatsubst([[[$1]]], [\\
+]), [
+], [ ])])
+
+
+# m4_strip(STRING)
+# ----------------
+# Expands into STRING with tabs and spaces singled out into a single
+# space, and removing leading and trailing spaces.
+#
+# This macro is robust to active symbols.
+#    m4_define(active, ACTIVE)
+#    m4_strip([  active  		active ])end
+#    => active activeend
+#
+# This macro is fun!  Because we want to preserve active symbols, STRING
+# must be quoted for each evaluation, which explains there are 4 levels
+# of brackets around $1 (don't forget that the result must be quoted
+# too, hence one more quoting than applications).
+#
+# Then notice the 2 last patterns: they are in charge of removing the
+# leading/trailing spaces.  Why not just `[^ ]'?  Because they are
+# applied to doubly quoted strings, i.e. more or less [[STRING]].  So
+# if there is a leading space in STRING, then it is the *third*
+# character, since there are two leading `['; equally for the last pattern.
+m4_define([m4_strip],
+[m4_bpatsubsts([[$1]],
+               [[ 	]+], [ ],
+               [^\(..\) ],    [\1],
+               [ \(..\)$],    [\1])])
+
+
+# m4_normalize(STRING)
+# --------------------
+# Apply m4_flatten and m4_strip to STRING.
+#
+# The argument is quoted, so that the macro is robust to active symbols:
+#
+#    m4_define(active, ACTIVE)
+#    m4_normalize([  act\
+#    ive
+#    active ])end
+#    => active activeend
+
+m4_define([m4_normalize],
+[m4_strip(m4_flatten([$1]))])
+
+
+
+# m4_join(SEP, ARG1, ARG2...)
+# ---------------------------
+# Produce ARG1SEPARG2...SEPARGn.
+m4_defun([m4_join],
+[m4_case([$#],
+         [1], [],
+         [2], [[$2]],
+         [[$2][$1]$0([$1], m4_shiftn(2, $@))])])
+
+
+
+# m4_append(MACRO-NAME, STRING, [SEPARATOR])
+# ------------------------------------------
+# Redefine MACRO-NAME to hold its former content plus `SEPARATOR`'STRING'
+# at the end.  It is valid to use this macro with MACRO-NAME undefined,
+# in which case no SEPARATOR is added.  Be aware that the criterion is
+# `not being defined', and not `not being empty'.
+#
+# This macro is robust to active symbols.  It can be used to grow
+# strings.
+#
+#    | m4_define(active, ACTIVE)
+#    | m4_append([sentence], [This is an])
+#    | m4_append([sentence], [ active ])
+#    | m4_append([sentence], [symbol.])
+#    | sentence
+#    | m4_undefine([active])dnl
+#    | sentence
+#    => This is an ACTIVE symbol.
+#    => This is an active symbol.
+#
+# It can be used to define hooks.
+#
+#    | m4_define(active, ACTIVE)
+#    | m4_append([hooks], [m4_define([act1], [act2])])
+#    | m4_append([hooks], [m4_define([act2], [active])])
+#    | m4_undefine([active])
+#    | act1
+#    | hooks
+#    | act1
+#    => act1
+#    =>
+#    => active
+m4_define([m4_append],
+[m4_define([$1],
+           m4_ifdef([$1], [m4_defn([$1])$3])[$2])])
+
+
+# m4_append_uniq(MACRO-NAME, STRING, [SEPARATOR])
+# -----------------------------------------------
+# As `m4_append', but append only if not yet present.
+m4_define([m4_append_uniq],
+[m4_ifdef([$1],
+          [m4_bmatch([$3]m4_defn([$1])[$3], m4_re_escape([$3$2$3]), [],
+                     [m4_append($@)])],
+          [m4_append($@)])])
+
+
+# m4_text_wrap(STRING, [PREFIX], [FIRST-PREFIX], [WIDTH])
+# -------------------------------------------------------
+# Expands into STRING wrapped to hold in WIDTH columns (default = 79).
+# If prefix is set, each line is prefixed with it.  If FIRST-PREFIX is
+# specified, then the first line is prefixed with it.  As a special
+# case, if the length of the first prefix is greater than that of
+# PREFIX, then FIRST-PREFIX will be left alone on the first line.
+#
+# Typical outputs are:
+#
+# m4_text_wrap([Short string */], [   ], [/* ], 20)
+#  => /* Short string */
+#
+# m4_text_wrap([Much longer string */], [   ], [/* ], 20)
+#  => /* Much longer
+#  =>    string */
+#
+# m4_text_wrap([Short doc.], [          ], [  --short ], 30)
+#  =>   --short Short doc.
+#
+# m4_text_wrap([Short doc.], [          ], [  --too-wide ], 30)
+#  =>   --too-wide
+#  =>           Short doc.
+#
+# m4_text_wrap([Super long documentation.], [          ], [  --too-wide ], 30)
+#  =>   --too-wide
+#  => 	  Super long
+#  => 	  documentation.
+#
+# FIXME: there is no checking of a longer PREFIX than WIDTH, but do
+# we really want to bother with people trying each single corner
+# of a software?
+#
+# This macro does not leave a trailing space behind the last word,
+# what complicates it a bit.  The algorithm is stupid simple: all the
+# words are preceded by m4_Separator which is defined to empty for the
+# first word, and then ` ' (single space) for all the others.
+m4_define([m4_text_wrap],
+[m4_pushdef([m4_Prefix], m4_default([$2], []))dnl
+m4_pushdef([m4_Prefix1], m4_default([$3], [m4_Prefix]))dnl
+m4_pushdef([m4_Width], m4_default([$4], 79))dnl
+m4_pushdef([m4_Cursor], m4_len(m4_Prefix1))dnl
+m4_pushdef([m4_Separator], [])dnl
+m4_Prefix1[]dnl
+m4_if(m4_eval(m4_Cursor > m4_len(m4_Prefix)),
+      1, [m4_define([m4_Cursor], m4_len(m4_Prefix))
+m4_Prefix])[]dnl
+m4_foreach([m4_Word], m4_quote(m4_split(m4_normalize([$1]))),
+[m4_define([m4_Cursor], m4_eval(m4_Cursor + m4_len(m4_defn([m4_Word])) + 1))dnl
+dnl New line if too long, else insert a space unless it is the first
+dnl of the words.
+m4_if(m4_eval(m4_Cursor > m4_Width),
+      1, [m4_define([m4_Cursor],
+                    m4_eval(m4_len(m4_Prefix) + m4_len(m4_defn([m4_Word])) + 1))]
+m4_Prefix,
+       [m4_Separator])[]dnl
+m4_defn([m4_Word])[]dnl
+m4_define([m4_Separator], [ ])])dnl
+m4_popdef([m4_Separator])dnl
+m4_popdef([m4_Cursor])dnl
+m4_popdef([m4_Width])dnl
+m4_popdef([m4_Prefix1])dnl
+m4_popdef([m4_Prefix])dnl
+])
+
+
+# m4_text_box(MESSAGE, [FRAME-CHARACTER = `-'])
+# ---------------------------------------------
+m4_define([m4_text_box],
+[@%:@@%:@ m4_bpatsubst([$1], [.], m4_if([$2], [], [[-]], [[$2]])) @%:@@%:@
+@%:@@%:@ $1 @%:@@%:@
+@%:@@%:@ m4_bpatsubst([$1], [.], m4_if([$2], [], [[-]], [[$2]])) @%:@@%:@[]dnl
+])
+
+
+
+## ----------------------- ##
+## 10. Number processing.  ##
+## ----------------------- ##
+
+# m4_sign(A)
+# ----------
+#
+# The sign of the integer A.
+m4_define([m4_sign],
+[m4_bmatch([$1],
+           [^-], -1,
+           [^0+], 0,
+                  1)])
+
+# m4_cmp(A, B)
+# ------------
+#
+# Compare two integers.
+# A < B -> -1
+# A = B ->  0
+# A > B ->  1
+m4_define([m4_cmp],
+[m4_sign(m4_eval([$1 - $2]))])
+
+
+# m4_list_cmp(A, B)
+# -----------------
+#
+# Compare the two lists of integers A and B.  For instance:
+#   m4_list_cmp((1, 0),     (1))    ->  0
+#   m4_list_cmp((1, 0),     (1, 0)) ->  0
+#   m4_list_cmp((1, 2),     (1, 0)) ->  1
+#   m4_list_cmp((1, 2, 3),  (1, 2)) ->  1
+#   m4_list_cmp((1, 2, -3), (1, 2)) -> -1
+#   m4_list_cmp((1, 0),     (1, 2)) -> -1
+#   m4_list_cmp((1),        (1, 2)) -> -1
+m4_define([m4_list_cmp],
+[m4_if([$1$2], [()()], 0,
+       [$1], [()], [$0((0), [$2])],
+       [$2], [()], [$0([$1], (0))],
+       [m4_case(m4_cmp(m4_car$1, m4_car$2),
+                -1, -1,
+                 1, 1,
+                 0, [$0((m4_shift$1), (m4_shift$2))])])])
+
+
+
+## ------------------------ ##
+## 11. Version processing.  ##
+## ------------------------ ##
+
+
+# m4_version_unletter(VERSION)
+# ----------------------------
+# Normalize beta version numbers with letters to numbers only for comparison.
+#
+#   Nl -> (N+1).-1.(l#)
+#
+#i.e., 2.14a -> 2.15.-1.1, 2.14b -> 2.15.-1.2, etc.
+# This macro is absolutely not robust to active macro, it expects
+# reasonable version numbers and is valid up to `z', no double letters.
+m4_define([m4_version_unletter],
+[m4_translit(m4_bpatsubsts([$1],
+                           [\([0-9]+\)\([abcdefghi]\)],
+                             [m4_eval(\1 + 1).-1.\2],
+                           [\([0-9]+\)\([jklmnopqrs]\)],
+                             [m4_eval(\1 + 1).-1.1\2],
+                           [\([0-9]+\)\([tuvwxyz]\)],
+                             [m4_eval(\1 + 1).-1.2\2]),
+             [abcdefghijklmnopqrstuvwxyz],
+             [12345678901234567890123456])])
+
+
+# m4_version_compare(VERSION-1, VERSION-2)
+# ----------------------------------------
+# Compare the two version numbers and expand into
+#  -1 if VERSION-1 < VERSION-2
+#   0 if           =
+#   1 if           >
+m4_define([m4_version_compare],
+[m4_list_cmp((m4_split(m4_version_unletter([$1]), [\.])),
+             (m4_split(m4_version_unletter([$2]), [\.])))])
+
+
+# m4_version_prereq(VERSION, [IF-OK], [IF-NOT = FAIL])
+# ----------------------------------------------------
+# Check this Autoconf version against VERSION.
+m4_define([m4_version_prereq],
+[m4_if(m4_version_compare(m4_defn([m4_PACKAGE_VERSION]), [$1]), -1,
+       [m4_default([$3],
+                   [m4_fatal([Autoconf version $1 or higher is required])])],
+       [$2])[]dnl
+])
+
+
+
+## ------------------- ##
+## 12. File handling.  ##
+## ------------------- ##
+
+
+# It is a real pity that M4 comes with no macros to bind a diversion
+# to a file.  So we have to deal without, which makes us a lot more
+# fragile that we should.
+
+
+# m4_file_append(FILE-NAME, CONTENT)
+# ----------------------------------
+m4_define([m4_file_append],
+[m4_syscmd([cat >>$1 <<_m4eof
+$2
+_m4eof
+])
+m4_if(m4_sysval, [0], [],
+      [m4_fatal([$0: cannot write: $1])])])
+
+
+
+## ------------------------ ##
+## 13. Setting M4sugar up.  ##
+## ------------------------ ##
+
+
+# m4_init
+# -------
+m4_define([m4_init],
+[# All the M4sugar macros start with `m4_', except `dnl' kept as is
+# for sake of simplicity.
+m4_pattern_forbid([^_?m4_])
+m4_pattern_forbid([^dnl$])
+
+# Check the divert push/pop perfect balance.
+m4_wrap([m4_ifdef([_m4_divert_diversion],
+                  [m4_fatal([$0: unbalanced m4_divert_push:]
+m4_defn([m4_divert_stack]))])[]])
+
+m4_divert_push([KILL])
+m4_wrap([m4_divert_pop([KILL])[]])
+])

_
